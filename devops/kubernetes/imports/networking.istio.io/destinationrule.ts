// generated by cdk8s
import { ApiObject } from 'cdk8s';
import { Construct } from 'constructs';

/**
 * 
 *
 * @schema DestinationRule
 */
export class DestinationRule extends ApiObject {
  /**
   * Defines a "DestinationRule" API object
   * @param scope the scope in which to define this object
   * @param name a scope-local name for the object
   * @param options configuration options
   */
  public constructor(scope: Construct, name: string, options: DestinationRuleOptions = {}) {
    super(scope, name, {
      ...options,
      kind: 'DestinationRule',
      apiVersion: 'networking.istio.io/v1alpha3',
    });
  }
}

/**
 * @schema DestinationRule
 */
export interface DestinationRuleOptions {
  /**
   * Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
   *
   * @schema DestinationRule#spec
   */
  readonly spec?: DestinationRuleSpec;

}

/**
 * Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
 *
 * @schema DestinationRuleSpec
 */
export interface DestinationRuleSpec {
  /**
   * A list of namespaces to which this destination rule is exported.
   *
   * @schema DestinationRuleSpec#exportTo
   */
  readonly exportTo?: string[];

  /**
   * The name of a service from the service registry.
   *
   * @schema DestinationRuleSpec#host
   */
  readonly host?: string;

  /**
   * @schema DestinationRuleSpec#subsets
   */
  readonly subsets?: DestinationRuleSpecSubsets[];

  /**
   * @schema DestinationRuleSpec#trafficPolicy
   */
  readonly trafficPolicy?: DestinationRuleSpecTrafficPolicy;

}

/**
 * @schema DestinationRuleSpecSubsets
 */
export interface DestinationRuleSpecSubsets {
  /**
   * @schema DestinationRuleSpecSubsets#labels
   */
  readonly labels?: { [key: string]: string };

  /**
   * Name of the subset.
   *
   * @schema DestinationRuleSpecSubsets#name
   */
  readonly name?: string;

  /**
   * Traffic policies that apply to this subset.
   *
   * @schema DestinationRuleSpecSubsets#trafficPolicy
   */
  readonly trafficPolicy?: DestinationRuleSpecSubsetsTrafficPolicy;

}

/**
 * @schema DestinationRuleSpecTrafficPolicy
 */
export interface DestinationRuleSpecTrafficPolicy {
  /**
   * @schema DestinationRuleSpecTrafficPolicy#connectionPool
   */
  readonly connectionPool?: DestinationRuleSpecTrafficPolicyConnectionPool;

  /**
   * Settings controlling the load balancer algorithms.
   *
   * @schema DestinationRuleSpecTrafficPolicy#loadBalancer
   */
  readonly loadBalancer?: DestinationRuleSpecTrafficPolicyLoadBalancer;

  /**
   * @schema DestinationRuleSpecTrafficPolicy#outlierDetection
   */
  readonly outlierDetection?: DestinationRuleSpecTrafficPolicyOutlierDetection;

  /**
   * Traffic policies specific to individual ports.
   *
   * @schema DestinationRuleSpecTrafficPolicy#portLevelSettings
   */
  readonly portLevelSettings?: DestinationRuleSpecTrafficPolicyPortLevelSettings[];

  /**
   * TLS related settings for connections to the upstream service.
   *
   * @schema DestinationRuleSpecTrafficPolicy#tls
   */
  readonly tls?: DestinationRuleSpecTrafficPolicyTls;

}

/**
 * Traffic policies that apply to this subset.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicy
 */
export interface DestinationRuleSpecSubsetsTrafficPolicy {
  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicy#connectionPool
   */
  readonly connectionPool?: DestinationRuleSpecSubsetsTrafficPolicyConnectionPool;

  /**
   * Settings controlling the load balancer algorithms.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicy#loadBalancer
   */
  readonly loadBalancer?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicy#outlierDetection
   */
  readonly outlierDetection?: DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection;

  /**
   * Traffic policies specific to individual ports.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicy#portLevelSettings
   */
  readonly portLevelSettings?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings[];

  /**
   * TLS related settings for connections to the upstream service.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicy#tls
   */
  readonly tls?: DestinationRuleSpecSubsetsTrafficPolicyTls;

}

/**
 * @schema DestinationRuleSpecTrafficPolicyConnectionPool
 */
export interface DestinationRuleSpecTrafficPolicyConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPool#http
   */
  readonly http?: DestinationRuleSpecTrafficPolicyConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPool#tcp
   */
  readonly tcp?: DestinationRuleSpecTrafficPolicyConnectionPoolTcp;

}

/**
 * Settings controlling the load balancer algorithms.
 *
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancer
 */
export interface DestinationRuleSpecTrafficPolicyLoadBalancer {
  /**
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancer#consistentHash
   */
  readonly consistentHash?: DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash;

  /**
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancer#localityLbSetting
   */
  readonly localityLbSetting?: DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting;

  /**
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancer#simple
   */
  readonly simple?: DestinationRuleSpecTrafficPolicyLoadBalancerSimple;

}

/**
 * @schema DestinationRuleSpecTrafficPolicyOutlierDetection
 */
export interface DestinationRuleSpecTrafficPolicyOutlierDetection {
  /**
   * Minimum ejection duration.
   *
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Number of 5xx errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#consecutive5xxErrors
   */
  readonly consecutive5xxErrors?: number;

  /**
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#consecutiveErrors
   */
  readonly consecutiveErrors?: number;

  /**
   * Number of gateway errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#interval
   */
  readonly interval?: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * @schema DestinationRuleSpecTrafficPolicyOutlierDetection#minHealthPercent
   */
  readonly minHealthPercent?: number;

}

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettings
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettings {
  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettings#connectionPool
   */
  readonly connectionPool?: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool;

  /**
   * Settings controlling the load balancer algorithms.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettings#loadBalancer
   */
  readonly loadBalancer?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettings#outlierDetection
   */
  readonly outlierDetection?: DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettings#port
   */
  readonly port?: DestinationRuleSpecTrafficPolicyPortLevelSettingsPort;

  /**
   * TLS related settings for connections to the upstream service.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettings#tls
   */
  readonly tls?: DestinationRuleSpecTrafficPolicyPortLevelSettingsTls;

}

/**
 * TLS related settings for connections to the upstream service.
 *
 * @schema DestinationRuleSpecTrafficPolicyTls
 */
export interface DestinationRuleSpecTrafficPolicyTls {
  /**
   * @schema DestinationRuleSpecTrafficPolicyTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecTrafficPolicyTls#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyTls#mode
   */
  readonly mode?: DestinationRuleSpecTrafficPolicyTlsMode;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecTrafficPolicyTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * SNI string to present to the server during TLS handshake.
   *
   * @schema DestinationRuleSpecTrafficPolicyTls#sni
   */
  readonly sni?: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

}

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPool
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPool#http
   */
  readonly http?: DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPool#tcp
   */
  readonly tcp?: DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp;

}

/**
 * Settings controlling the load balancer algorithms.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer {
  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer#consistentHash
   */
  readonly consistentHash?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer#localityLbSetting
   */
  readonly localityLbSetting?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancer#simple
   */
  readonly simple?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerSimple;

}

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection {
  /**
   * Minimum ejection duration.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Number of 5xx errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#consecutive5xxErrors
   */
  readonly consecutive5xxErrors?: number;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#consecutiveErrors
   */
  readonly consecutiveErrors?: number;

  /**
   * Number of gateway errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#interval
   */
  readonly interval?: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection#minHealthPercent
   */
  readonly minHealthPercent?: number;

}

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings {
  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings#connectionPool
   */
  readonly connectionPool?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool;

  /**
   * Settings controlling the load balancer algorithms.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings#loadBalancer
   */
  readonly loadBalancer?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings#outlierDetection
   */
  readonly outlierDetection?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings#port
   */
  readonly port?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort;

  /**
   * TLS related settings for connections to the upstream service.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings#tls
   */
  readonly tls?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls;

}

/**
 * TLS related settings for connections to the upstream service.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyTls
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyTls {
  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#mode
   */
  readonly mode?: DestinationRuleSpecSubsetsTrafficPolicyTlsMode;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * SNI string to present to the server during TLS handshake.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#sni
   */
  readonly sni?: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

}

/**
 * HTTP connection pool settings.
 *
 * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp
 */
export interface DestinationRuleSpecTrafficPolicyConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: DestinationRuleSpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of pending HTTP requests to a destination.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of requests to a backend.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcp
 */
export interface DestinationRuleSpecTrafficPolicyConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive;

}

/**
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash
 */
export interface DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash {
  /**
   * Hash based on HTTP cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash#httpCookie
   */
  readonly httpCookie?: DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie;

  /**
   * Hash based on a specific HTTP header.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash#httpHeaderName
   */
  readonly httpHeaderName?: string;

  /**
   * Hash based on a specific HTTP query parameter.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash#httpQueryParameterName
   */
  readonly httpQueryParameterName?: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

  /**
   * Hash based on the source IP address.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHash#useSourceIp
   */
  readonly useSourceIp?: boolean;

}

/**
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting
 */
export interface DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting {
  /**
   * Optional: only one of distribute or failover can be set.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting#distribute
   */
  readonly distribute?: DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute[];

  /**
   * enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting#enabled
   */
  readonly enabled?: boolean;

  /**
   * Optional: only failover or distribute can be set.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSetting#failover
   */
  readonly failover?: DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover[];

}

/**
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancerSimple
 */
export enum DestinationRuleSpecTrafficPolicyLoadBalancerSimple {
  /** ROUND_ROBIN */
  ROUND_ROBIN = "ROUND_ROBIN",
  /** LEAST_CONN */
  LEAST_CONN = "LEAST_CONN",
  /** RANDOM */
  RANDOM = "RANDOM",
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
}

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool#http
   */
  readonly http?: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool#tcp
   */
  readonly tcp?: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp;

}

/**
 * Settings controlling the load balancer algorithms.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer {
  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer#consistentHash
   */
  readonly consistentHash?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer#localityLbSetting
   */
  readonly localityLbSetting?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancer#simple
   */
  readonly simple?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerSimple;

}

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection {
  /**
   * Minimum ejection duration.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Number of 5xx errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#consecutive5xxErrors
   */
  readonly consecutive5xxErrors?: number;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveErrors
   */
  readonly consecutiveErrors?: number;

  /**
   * Number of gateway errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#interval
   */
  readonly interval?: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection#minHealthPercent
   */
  readonly minHealthPercent?: number;

}

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsPort
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsPort {
  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsPort#number
   */
  readonly number?: number;

}

/**
 * TLS related settings for connections to the upstream service.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsTls {
  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#mode
   */
  readonly mode?: DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsMode;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * SNI string to present to the server during TLS handshake.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#sni
   */
  readonly sni?: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

}

/**
 * @schema DestinationRuleSpecTrafficPolicyTlsMode
 */
export enum DestinationRuleSpecTrafficPolicyTlsMode {
  /** DISABLE */
  DISABLE = "DISABLE",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** ISTIO_MUTUAL */
  ISTIO_MUTUAL = "ISTIO_MUTUAL",
}

/**
 * HTTP connection pool settings.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of pending HTTP requests to a destination.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of requests to a backend.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive;

}

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash {
  /**
   * Hash based on HTTP cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash#httpCookie
   */
  readonly httpCookie?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie;

  /**
   * Hash based on a specific HTTP header.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash#httpHeaderName
   */
  readonly httpHeaderName?: string;

  /**
   * Hash based on a specific HTTP query parameter.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash#httpQueryParameterName
   */
  readonly httpQueryParameterName?: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

  /**
   * Hash based on the source IP address.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHash#useSourceIp
   */
  readonly useSourceIp?: boolean;

}

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting {
  /**
   * Optional: only one of distribute or failover can be set.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting#distribute
   */
  readonly distribute?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute[];

  /**
   * enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting#enabled
   */
  readonly enabled?: boolean;

  /**
   * Optional: only failover or distribute can be set.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSetting#failover
   */
  readonly failover?: DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover[];

}

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerSimple
 */
export enum DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerSimple {
  /** ROUND_ROBIN */
  ROUND_ROBIN = "ROUND_ROBIN",
  /** LEAST_CONN */
  LEAST_CONN = "LEAST_CONN",
  /** RANDOM */
  RANDOM = "RANDOM",
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
}

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool {
  /**
   * HTTP connection pool settings.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool#http
   */
  readonly http?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp;

  /**
   * Settings common to both HTTP and TCP upstream connections.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool#tcp
   */
  readonly tcp?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp;

}

/**
 * Settings controlling the load balancer algorithms.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer {
  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer#consistentHash
   */
  readonly consistentHash?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer#localityLbSetting
   */
  readonly localityLbSetting?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancer#simple
   */
  readonly simple?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple;

}

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection {
  /**
   * Minimum ejection duration.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#baseEjectionTime
   */
  readonly baseEjectionTime?: string;

  /**
   * Number of 5xx errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#consecutive5xxErrors
   */
  readonly consecutive5xxErrors?: number;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveErrors
   */
  readonly consecutiveErrors?: number;

  /**
   * Number of gateway errors before a host is ejected from the connection pool.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#consecutiveGatewayErrors
   */
  readonly consecutiveGatewayErrors?: number;

  /**
   * Time interval between ejection sweep analysis.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#interval
   */
  readonly interval?: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#maxEjectionPercent
   */
  readonly maxEjectionPercent?: number;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection#minHealthPercent
   */
  readonly minHealthPercent?: number;

}

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort {
  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort#number
   */
  readonly number?: number;

}

/**
 * TLS related settings for connections to the upstream service.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls {
  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#caCertificates
   */
  readonly caCertificates?: string;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#clientCertificate
   */
  readonly clientCertificate?: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#credentialName
   */
  readonly credentialName?: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#mode
   */
  readonly mode?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsMode;

  /**
   * REQUIRED if mode is `MUTUAL`.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#privateKey
   */
  readonly privateKey?: string;

  /**
   * SNI string to present to the server during TLS handshake.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#sni
   */
  readonly sni?: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls#subjectAltNames
   */
  readonly subjectAltNames?: string[];

}

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyTlsMode
 */
export enum DestinationRuleSpecSubsetsTrafficPolicyTlsMode {
  /** DISABLE */
  DISABLE = "DISABLE",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** ISTIO_MUTUAL */
  ISTIO_MUTUAL = "ISTIO_MUTUAL",
}

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * @schema DestinationRuleSpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy
 */
export enum DestinationRuleSpecTrafficPolicyConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_NOT_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive
 */
export interface DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * @schema DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Hash based on HTTP cookie.
 *
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie
 */
export interface DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie {
  /**
   * Name of the cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie#name
   */
  readonly name?: string;

  /**
   * Path to set for the cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie#path
   */
  readonly path?: string;

  /**
   * Lifetime of the cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerConsistentHashHttpCookie#ttl
   */
  readonly ttl?: string;

}

/**
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute
 */
export interface DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute {
  /**
   * Originating locality, '/' separated, e.g.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute#from
   */
  readonly from?: string;

  /**
   * Map of upstream localities to traffic distribution weights.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingDistribute#to
   */
  readonly to?: { [key: string]: number };

}

/**
 * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover
 */
export interface DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover {
  /**
   * Originating region.
   *
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover#from
   */
  readonly from?: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyLoadBalancerLocalityLbSettingFailover#to
   */
  readonly to?: string;

}

/**
 * HTTP connection pool settings.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of pending HTTP requests to a destination.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of requests to a backend.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive;

}

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash {
  /**
   * Hash based on HTTP cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpCookie
   */
  readonly httpCookie?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie;

  /**
   * Hash based on a specific HTTP header.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpHeaderName
   */
  readonly httpHeaderName?: string;

  /**
   * Hash based on a specific HTTP query parameter.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpQueryParameterName
   */
  readonly httpQueryParameterName?: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

  /**
   * Hash based on the source IP address.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#useSourceIp
   */
  readonly useSourceIp?: boolean;

}

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting {
  /**
   * Optional: only one of distribute or failover can be set.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#distribute
   */
  readonly distribute?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute[];

  /**
   * enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#enabled
   */
  readonly enabled?: boolean;

  /**
   * Optional: only failover or distribute can be set.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#failover
   */
  readonly failover?: DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover[];

}

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerSimple
 */
export enum DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerSimple {
  /** ROUND_ROBIN */
  ROUND_ROBIN = "ROUND_ROBIN",
  /** LEAST_CONN */
  LEAST_CONN = "LEAST_CONN",
  /** RANDOM */
  RANDOM = "RANDOM",
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
}

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsMode
 */
export enum DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsMode {
  /** DISABLE */
  DISABLE = "DISABLE",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** ISTIO_MUTUAL */
  ISTIO_MUTUAL = "ISTIO_MUTUAL",
}

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy
 */
export enum DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_NOT_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Hash based on HTTP cookie.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie {
  /**
   * Name of the cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie#name
   */
  readonly name?: string;

  /**
   * Path to set for the cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie#path
   */
  readonly path?: string;

  /**
   * Lifetime of the cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerConsistentHashHttpCookie#ttl
   */
  readonly ttl?: string;

}

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute {
  /**
   * Originating locality, '/' separated, e.g.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute#from
   */
  readonly from?: string;

  /**
   * Map of upstream localities to traffic distribution weights.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingDistribute#to
   */
  readonly to?: { [key: string]: number };

}

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover {
  /**
   * Originating region.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover#from
   */
  readonly from?: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyLoadBalancerLocalityLbSettingFailover#to
   */
  readonly to?: string;

}

/**
 * HTTP connection pool settings.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp {
  /**
   * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#h2UpgradePolicy
   */
  readonly h2UpgradePolicy?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy;

  /**
   * Maximum number of pending HTTP requests to a destination.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#http1MaxPendingRequests
   */
  readonly http1MaxPendingRequests?: number;

  /**
   * Maximum number of requests to a backend.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#http2MaxRequests
   */
  readonly http2MaxRequests?: number;

  /**
   * The idle timeout for upstream connection pool connections.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#idleTimeout
   */
  readonly idleTimeout?: string;

  /**
   * Maximum number of requests per connection to a backend.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxRequestsPerConnection
   */
  readonly maxRequestsPerConnection?: number;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * If set to true, client protocol will be preserved while initiating connection to backend.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp#useClientProtocol
   */
  readonly useClientProtocol?: boolean;

}

/**
 * Settings common to both HTTP and TCP upstream connections.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp {
  /**
   * TCP connection timeout.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp#connectTimeout
   */
  readonly connectTimeout?: string;

  /**
   * Maximum number of HTTP1 /TCP connections to a destination host.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp#maxConnections
   */
  readonly maxConnections?: number;

  /**
   * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp#tcpKeepalive
   */
  readonly tcpKeepalive?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive;

}

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash {
  /**
   * Hash based on HTTP cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpCookie
   */
  readonly httpCookie?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie;

  /**
   * Hash based on a specific HTTP header.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpHeaderName
   */
  readonly httpHeaderName?: string;

  /**
   * Hash based on a specific HTTP query parameter.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#httpQueryParameterName
   */
  readonly httpQueryParameterName?: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#minimumRingSize
   */
  readonly minimumRingSize?: number;

  /**
   * Hash based on the source IP address.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHash#useSourceIp
   */
  readonly useSourceIp?: boolean;

}

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting {
  /**
   * Optional: only one of distribute or failover can be set.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#distribute
   */
  readonly distribute?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute[];

  /**
   * enable locality load balancing, this is DestinationRule-level and will override mesh wide settings in entirety.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#enabled
   */
  readonly enabled?: boolean;

  /**
   * Optional: only failover or distribute can be set.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSetting#failover
   */
  readonly failover?: DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover[];

}

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple
 */
export enum DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerSimple {
  /** ROUND_ROBIN */
  ROUND_ROBIN = "ROUND_ROBIN",
  /** LEAST_CONN */
  LEAST_CONN = "LEAST_CONN",
  /** RANDOM */
  RANDOM = "RANDOM",
  /** PASSTHROUGH */
  PASSTHROUGH = "PASSTHROUGH",
}

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsMode
 */
export enum DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsMode {
  /** DISABLE */
  DISABLE = "DISABLE",
  /** SIMPLE */
  SIMPLE = "SIMPLE",
  /** MUTUAL */
  MUTUAL = "MUTUAL",
  /** ISTIO_MUTUAL */
  ISTIO_MUTUAL = "ISTIO_MUTUAL",
}

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy
 */
export enum DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_NOT_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Hash based on HTTP cookie.
 *
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie {
  /**
   * Name of the cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#name
   */
  readonly name?: string;

  /**
   * Path to set for the cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#path
   */
  readonly path?: string;

  /**
   * Lifetime of the cookie.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#ttl
   */
  readonly ttl?: string;

}

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute {
  /**
   * Originating locality, '/' separated, e.g.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute#from
   */
  readonly from?: string;

  /**
   * Map of upstream localities to traffic distribution weights.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute#to
   */
  readonly to?: { [key: string]: number };

}

/**
 * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover
 */
export interface DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover {
  /**
   * Originating region.
   *
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover#from
   */
  readonly from?: string;

  /**
   * @schema DestinationRuleSpecTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover#to
   */
  readonly to?: string;

}

/**
 * Specify if http1.1 connection should be upgraded to http2 for the associated destination.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy
 */
export enum DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpH2UpgradePolicy {
  /** DEFAULT */
  DEFAULT = "DEFAULT",
  /** DO_NOT_UPGRADE */
  DO_NOT_UPGRADE = "DO_NOT_UPGRADE",
  /** UPGRADE */
  UPGRADE = "UPGRADE",
}

/**
 * If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive {
  /**
   * The time duration between keep-alive probes.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#interval
   */
  readonly interval?: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#probes
   */
  readonly probes?: number;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive#time
   */
  readonly time?: string;

}

/**
 * Hash based on HTTP cookie.
 *
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie {
  /**
   * Name of the cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#name
   */
  readonly name?: string;

  /**
   * Path to set for the cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#path
   */
  readonly path?: string;

  /**
   * Lifetime of the cookie.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerConsistentHashHttpCookie#ttl
   */
  readonly ttl?: string;

}

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute {
  /**
   * Originating locality, '/' separated, e.g.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute#from
   */
  readonly from?: string;

  /**
   * Map of upstream localities to traffic distribution weights.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingDistribute#to
   */
  readonly to?: { [key: string]: number };

}

/**
 * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover
 */
export interface DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover {
  /**
   * Originating region.
   *
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover#from
   */
  readonly from?: string;

  /**
   * @schema DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsLoadBalancerLocalityLbSettingFailover#to
   */
  readonly to?: string;

}

