// generated by cdk8s
import { ApiObject } from 'cdk8s';
import { Construct } from 'constructs';

/**
 * 
 *
 * @schema KafkaBridge
 */
export class KafkaBridge extends ApiObject {
  /**
   * Defines a "KafkaBridge" API object
   * @param scope the scope in which to define this object
   * @param name a scope-local name for the object
   * @param options configuration options
   */
  public constructor(scope: Construct, name: string, options: KafkaBridgeOptions = {}) {
    super(scope, name, {
      ...options,
      kind: 'KafkaBridge',
      apiVersion: 'kafka.strimzi.io/v1alpha1',
    });
  }
}

/**
 * @schema KafkaBridge
 */
export interface KafkaBridgeOptions {
  /**
   * The specification of the Kafka Bridge.
   *
   * @schema KafkaBridge#spec
   */
  readonly spec?: KafkaBridgeSpec;

}

/**
 * The specification of the Kafka Bridge.
 *
 * @schema KafkaBridgeSpec
 */
export interface KafkaBridgeSpec {
  /**
   * The number of pods in the `Deployment`.
   *
   * @schema KafkaBridgeSpec#replicas
   */
  readonly replicas?: number;

  /**
   * The docker image for the pods.
   *
   * @schema KafkaBridgeSpec#image
   */
  readonly image?: string;

  /**
   * A list of host:port pairs for establishing the initial connection to the Kafka cluster.
   *
   * @schema KafkaBridgeSpec#bootstrapServers
   */
  readonly bootstrapServers: string;

  /**
   * TLS configuration for connecting Kafka Bridge to the cluster.
   *
   * @schema KafkaBridgeSpec#tls
   */
  readonly tls?: KafkaBridgeSpecTls;

  /**
   * Authentication configuration for connecting to the cluster.
   *
   * @schema KafkaBridgeSpec#authentication
   */
  readonly authentication?: KafkaBridgeSpecAuthentication;

  /**
   * The HTTP related configuration.
   *
   * @schema KafkaBridgeSpec#http
   */
  readonly http?: KafkaBridgeSpecHttp;

  /**
   * Kafka consumer related configuration.
   *
   * @schema KafkaBridgeSpec#consumer
   */
  readonly consumer?: KafkaBridgeSpecConsumer;

  /**
   * Kafka producer related configuration.
   *
   * @schema KafkaBridgeSpec#producer
   */
  readonly producer?: KafkaBridgeSpecProducer;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaBridgeSpec#resources
   */
  readonly resources?: KafkaBridgeSpecResources;

  /**
   * **Currently not supported** JVM Options for pods.
   *
   * @schema KafkaBridgeSpec#jvmOptions
   */
  readonly jvmOptions?: KafkaBridgeSpecJvmOptions;

  /**
   * Logging configuration for Kafka Bridge.
   *
   * @schema KafkaBridgeSpec#logging
   */
  readonly logging?: KafkaBridgeSpecLogging;

  /**
   * Enable the metrics for the Kafka Bridge. Default is false.
   *
   * @default false.
   * @schema KafkaBridgeSpec#enableMetrics
   */
  readonly enableMetrics?: boolean;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaBridgeSpec#livenessProbe
   */
  readonly livenessProbe?: KafkaBridgeSpecLivenessProbe;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaBridgeSpec#readinessProbe
   */
  readonly readinessProbe?: KafkaBridgeSpecReadinessProbe;

  /**
   * Template for Kafka Bridge resources. The template allows users to specify how is the `Deployment` and `Pods` generated.
   *
   * @schema KafkaBridgeSpec#template
   */
  readonly template?: KafkaBridgeSpecTemplate;

  /**
   * The configuration of tracing in Kafka Bridge.
   *
   * @schema KafkaBridgeSpec#tracing
   */
  readonly tracing?: KafkaBridgeSpecTracing;

}

/**
 * TLS configuration for connecting Kafka Bridge to the cluster.
 *
 * @schema KafkaBridgeSpecTls
 */
export interface KafkaBridgeSpecTls {
  /**
   * Trusted certificates for TLS connection.
   *
   * @schema KafkaBridgeSpecTls#trustedCertificates
   */
  readonly trustedCertificates?: KafkaBridgeSpecTlsTrustedCertificates[];

}

/**
 * Authentication configuration for connecting to the cluster.
 *
 * @schema KafkaBridgeSpecAuthentication
 */
export interface KafkaBridgeSpecAuthentication {
  /**
   * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
   *
   * @schema KafkaBridgeSpecAuthentication#accessToken
   */
  readonly accessToken?: KafkaBridgeSpecAuthenticationAccessToken;

  /**
   * Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
   *
   * @default true`.
   * @schema KafkaBridgeSpecAuthentication#accessTokenIsJwt
   */
  readonly accessTokenIsJwt?: boolean;

  /**
   * Reference to the `Secret` which holds the certificate and private key pair.
   *
   * @schema KafkaBridgeSpecAuthentication#certificateAndKey
   */
  readonly certificateAndKey?: KafkaBridgeSpecAuthenticationCertificateAndKey;

  /**
   * OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
   *
   * @schema KafkaBridgeSpecAuthentication#clientId
   */
  readonly clientId?: string;

  /**
   * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
   *
   * @schema KafkaBridgeSpecAuthentication#clientSecret
   */
  readonly clientSecret?: KafkaBridgeSpecAuthenticationClientSecret;

  /**
   * Enable or disable TLS hostname verification. Default value is `false`.
   *
   * @schema KafkaBridgeSpecAuthentication#disableTlsHostnameVerification
   */
  readonly disableTlsHostnameVerification?: boolean;

  /**
   * Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
   *
   * @schema KafkaBridgeSpecAuthentication#maxTokenExpirySeconds
   */
  readonly maxTokenExpirySeconds?: number;

  /**
   * Reference to the `Secret` which holds the password.
   *
   * @schema KafkaBridgeSpecAuthentication#passwordSecret
   */
  readonly passwordSecret?: KafkaBridgeSpecAuthenticationPasswordSecret;

  /**
   * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
   *
   * @schema KafkaBridgeSpecAuthentication#refreshToken
   */
  readonly refreshToken?: KafkaBridgeSpecAuthenticationRefreshToken;

  /**
   * OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
   *
   * @schema KafkaBridgeSpecAuthentication#scope
   */
  readonly scope?: string;

  /**
   * Trusted certificates for TLS connection to the OAuth server.
   *
   * @schema KafkaBridgeSpecAuthentication#tlsTrustedCertificates
   */
  readonly tlsTrustedCertificates?: KafkaBridgeSpecAuthenticationTlsTrustedCertificates[];

  /**
   * Authorization server token endpoint URI.
   *
   * @schema KafkaBridgeSpecAuthentication#tokenEndpointUri
   */
  readonly tokenEndpointUri?: string;

  /**
   * Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
   *
   * @schema KafkaBridgeSpecAuthentication#type
   */
  readonly type: KafkaBridgeSpecAuthenticationType;

  /**
   * Username used for the authentication.
   *
   * @schema KafkaBridgeSpecAuthentication#username
   */
  readonly username?: string;

}

/**
 * The HTTP related configuration.
 *
 * @schema KafkaBridgeSpecHttp
 */
export interface KafkaBridgeSpecHttp {
  /**
   * The port which is the server listening on.
   *
   * @schema KafkaBridgeSpecHttp#port
   */
  readonly port?: number;

  /**
   * CORS configuration for the HTTP Bridge.
   *
   * @schema KafkaBridgeSpecHttp#cors
   */
  readonly cors?: KafkaBridgeSpecHttpCors;

}

/**
 * Kafka consumer related configuration.
 *
 * @schema KafkaBridgeSpecConsumer
 */
export interface KafkaBridgeSpecConsumer {
  /**
   * The Kafka consumer configuration used for consumer instances created by the bridge. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, group.id, sasl., security. (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
   *
   * @schema KafkaBridgeSpecConsumer#config
   */
  readonly config?: any;

}

/**
 * Kafka producer related configuration.
 *
 * @schema KafkaBridgeSpecProducer
 */
export interface KafkaBridgeSpecProducer {
  /**
   * The Kafka producer configuration used for producer instances created by the bridge. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, sasl., security. (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
   *
   * @schema KafkaBridgeSpecProducer#config
   */
  readonly config?: any;

}

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaBridgeSpecResources
 */
export interface KafkaBridgeSpecResources {
  /**
   * @schema KafkaBridgeSpecResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaBridgeSpecResources#requests
   */
  readonly requests?: any;

}

/**
 * **Currently not supported** JVM Options for pods.
 *
 * @schema KafkaBridgeSpecJvmOptions
 */
export interface KafkaBridgeSpecJvmOptions {
  /**
   * A map of -XX options to the JVM.
   *
   * @schema KafkaBridgeSpecJvmOptions#-XX
   */
  readonly xx?: any;

  /**
   * -Xms option to to the JVM.
   *
   * @schema KafkaBridgeSpecJvmOptions#-Xms
   */
  readonly xms?: string;

  /**
   * -Xmx option to to the JVM.
   *
   * @schema KafkaBridgeSpecJvmOptions#-Xmx
   */
  readonly xmx?: string;

  /**
   * Specifies whether the Garbage Collection logging is enabled. The default is false.
   *
   * @schema KafkaBridgeSpecJvmOptions#gcLoggingEnabled
   */
  readonly gcLoggingEnabled?: boolean;

  /**
   * A map of additional system properties which will be passed using the `-D` option to the JVM.
   *
   * @schema KafkaBridgeSpecJvmOptions#javaSystemProperties
   */
  readonly javaSystemProperties?: KafkaBridgeSpecJvmOptionsJavaSystemProperties[];

}

/**
 * Logging configuration for Kafka Bridge.
 *
 * @schema KafkaBridgeSpecLogging
 */
export interface KafkaBridgeSpecLogging {
  /**
   * A Map from logger name to logger level.
   *
   * @schema KafkaBridgeSpecLogging#loggers
   */
  readonly loggers?: any;

  /**
   * The name of the `ConfigMap` from which to get the logging configuration.
   *
   * @schema KafkaBridgeSpecLogging#name
   */
  readonly name?: string;

  /**
   * Logging type, must be either 'inline' or 'external'.
   *
   * @schema KafkaBridgeSpecLogging#type
   */
  readonly type: KafkaBridgeSpecLoggingType;

}

/**
 * Pod liveness checking.
 *
 * @schema KafkaBridgeSpecLivenessProbe
 */
export interface KafkaBridgeSpecLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaBridgeSpecLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaBridgeSpecLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaBridgeSpecLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaBridgeSpecLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaBridgeSpecLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Pod readiness checking.
 *
 * @schema KafkaBridgeSpecReadinessProbe
 */
export interface KafkaBridgeSpecReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaBridgeSpecReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaBridgeSpecReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaBridgeSpecReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaBridgeSpecReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaBridgeSpecReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Template for Kafka Bridge resources. The template allows users to specify how is the `Deployment` and `Pods` generated.
 *
 * @schema KafkaBridgeSpecTemplate
 */
export interface KafkaBridgeSpecTemplate {
  /**
   * Template for Kafka Bridge `Deployment`.
   *
   * @schema KafkaBridgeSpecTemplate#deployment
   */
  readonly deployment?: KafkaBridgeSpecTemplateDeployment;

  /**
   * Template for Kafka Bridge `Pods`.
   *
   * @schema KafkaBridgeSpecTemplate#pod
   */
  readonly pod?: KafkaBridgeSpecTemplatePod;

  /**
   * Template for Kafka Bridge API `Service`.
   *
   * @schema KafkaBridgeSpecTemplate#apiService
   */
  readonly apiService?: KafkaBridgeSpecTemplateApiService;

  /**
   * Template for the Kafka Bridge container.
   *
   * @schema KafkaBridgeSpecTemplate#bridgeContainer
   */
  readonly bridgeContainer?: KafkaBridgeSpecTemplateBridgeContainer;

  /**
   * Template for Kafka Bridge `PodDisruptionBudget`.
   *
   * @schema KafkaBridgeSpecTemplate#podDisruptionBudget
   */
  readonly podDisruptionBudget?: KafkaBridgeSpecTemplatePodDisruptionBudget;

}

/**
 * The configuration of tracing in Kafka Bridge.
 *
 * @schema KafkaBridgeSpecTracing
 */
export interface KafkaBridgeSpecTracing {
  /**
   * Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
   *
   * @schema KafkaBridgeSpecTracing#type
   */
  readonly type: KafkaBridgeSpecTracingType;

}

/**
 * @schema KafkaBridgeSpecTlsTrustedCertificates
 */
export interface KafkaBridgeSpecTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaBridgeSpecTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaBridgeSpecTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
 *
 * @schema KafkaBridgeSpecAuthenticationAccessToken
 */
export interface KafkaBridgeSpecAuthenticationAccessToken {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaBridgeSpecAuthenticationAccessToken#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaBridgeSpecAuthenticationAccessToken#secretName
   */
  readonly secretName: string;

}

/**
 * Reference to the `Secret` which holds the certificate and private key pair.
 *
 * @schema KafkaBridgeSpecAuthenticationCertificateAndKey
 */
export interface KafkaBridgeSpecAuthenticationCertificateAndKey {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaBridgeSpecAuthenticationCertificateAndKey#certificate
   */
  readonly certificate: string;

  /**
   * The name of the private key in the Secret.
   *
   * @schema KafkaBridgeSpecAuthenticationCertificateAndKey#key
   */
  readonly key: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaBridgeSpecAuthenticationCertificateAndKey#secretName
   */
  readonly secretName: string;

}

/**
 * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
 *
 * @schema KafkaBridgeSpecAuthenticationClientSecret
 */
export interface KafkaBridgeSpecAuthenticationClientSecret {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaBridgeSpecAuthenticationClientSecret#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaBridgeSpecAuthenticationClientSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Reference to the `Secret` which holds the password.
 *
 * @schema KafkaBridgeSpecAuthenticationPasswordSecret
 */
export interface KafkaBridgeSpecAuthenticationPasswordSecret {
  /**
   * The name of the key in the Secret under which the password is stored.
   *
   * @schema KafkaBridgeSpecAuthenticationPasswordSecret#password
   */
  readonly password: string;

  /**
   * The name of the Secret containing the password.
   *
   * @schema KafkaBridgeSpecAuthenticationPasswordSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
 *
 * @schema KafkaBridgeSpecAuthenticationRefreshToken
 */
export interface KafkaBridgeSpecAuthenticationRefreshToken {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaBridgeSpecAuthenticationRefreshToken#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaBridgeSpecAuthenticationRefreshToken#secretName
   */
  readonly secretName: string;

}

/**
 * @schema KafkaBridgeSpecAuthenticationTlsTrustedCertificates
 */
export interface KafkaBridgeSpecAuthenticationTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaBridgeSpecAuthenticationTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaBridgeSpecAuthenticationTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
 *
 * @schema KafkaBridgeSpecAuthenticationType
 */
export enum KafkaBridgeSpecAuthenticationType {
  /** tls */
  TLS = "tls",
  /** scram-sha-512 */
  SCRAM_SHA_512 = "scram-sha-512",
  /** plain */
  PLAIN = "plain",
  /** oauth */
  OAUTH = "oauth",
}

/**
 * CORS configuration for the HTTP Bridge.
 *
 * @schema KafkaBridgeSpecHttpCors
 */
export interface KafkaBridgeSpecHttpCors {
  /**
   * List of allowed origins. Java regular expressions can be used.
   *
   * @schema KafkaBridgeSpecHttpCors#allowedOrigins
   */
  readonly allowedOrigins: string[];

  /**
   * List of allowed HTTP methods.
   *
   * @schema KafkaBridgeSpecHttpCors#allowedMethods
   */
  readonly allowedMethods: string[];

}

/**
 * @schema KafkaBridgeSpecJvmOptionsJavaSystemProperties
 */
export interface KafkaBridgeSpecJvmOptionsJavaSystemProperties {
  /**
   * The system property name.
   *
   * @schema KafkaBridgeSpecJvmOptionsJavaSystemProperties#name
   */
  readonly name?: string;

  /**
   * The system property value.
   *
   * @schema KafkaBridgeSpecJvmOptionsJavaSystemProperties#value
   */
  readonly value?: string;

}

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaBridgeSpecLoggingType
 */
export enum KafkaBridgeSpecLoggingType {
  /** inline */
  INLINE = "inline",
  /** external */
  EXTERNAL = "external",
}

/**
 * Template for Kafka Bridge `Deployment`.
 *
 * @schema KafkaBridgeSpecTemplateDeployment
 */
export interface KafkaBridgeSpecTemplateDeployment {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaBridgeSpecTemplateDeployment#metadata
   */
  readonly metadata?: KafkaBridgeSpecTemplateDeploymentMetadata;

}

/**
 * Template for Kafka Bridge `Pods`.
 *
 * @schema KafkaBridgeSpecTemplatePod
 */
export interface KafkaBridgeSpecTemplatePod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaBridgeSpecTemplatePod#metadata
   */
  readonly metadata?: KafkaBridgeSpecTemplatePodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaBridgeSpecTemplatePod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaBridgeSpecTemplatePodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaBridgeSpecTemplatePod#securityContext
   */
  readonly securityContext?: KafkaBridgeSpecTemplatePodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaBridgeSpecTemplatePod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaBridgeSpecTemplatePod#affinity
   */
  readonly affinity?: KafkaBridgeSpecTemplatePodAffinity;

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaBridgeSpecTemplatePod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaBridgeSpecTemplatePod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaBridgeSpecTemplatePod#tolerations
   */
  readonly tolerations?: KafkaBridgeSpecTemplatePodTolerations[];

}

/**
 * Template for Kafka Bridge API `Service`.
 *
 * @schema KafkaBridgeSpecTemplateApiService
 */
export interface KafkaBridgeSpecTemplateApiService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaBridgeSpecTemplateApiService#metadata
   */
  readonly metadata?: KafkaBridgeSpecTemplateApiServiceMetadata;

}

/**
 * Template for the Kafka Bridge container.
 *
 * @schema KafkaBridgeSpecTemplateBridgeContainer
 */
export interface KafkaBridgeSpecTemplateBridgeContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaBridgeSpecTemplateBridgeContainer#env
   */
  readonly env?: KafkaBridgeSpecTemplateBridgeContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaBridgeSpecTemplateBridgeContainer#securityContext
   */
  readonly securityContext?: KafkaBridgeSpecTemplateBridgeContainerSecurityContext;

}

/**
 * Template for Kafka Bridge `PodDisruptionBudget`.
 *
 * @schema KafkaBridgeSpecTemplatePodDisruptionBudget
 */
export interface KafkaBridgeSpecTemplatePodDisruptionBudget {
  /**
   * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
   *
   * @schema KafkaBridgeSpecTemplatePodDisruptionBudget#metadata
   */
  readonly metadata?: KafkaBridgeSpecTemplatePodDisruptionBudgetMetadata;

  /**
   * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
   *
   * @default 1.
   * @schema KafkaBridgeSpecTemplatePodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: number;

}

/**
 * Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
 *
 * @schema KafkaBridgeSpecTracingType
 */
export enum KafkaBridgeSpecTracingType {
  /** jaeger */
  JAEGER = "jaeger",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaBridgeSpecTemplateDeploymentMetadata
 */
export interface KafkaBridgeSpecTemplateDeploymentMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaBridgeSpecTemplateDeploymentMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaBridgeSpecTemplateDeploymentMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaBridgeSpecTemplatePodMetadata
 */
export interface KafkaBridgeSpecTemplatePodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaBridgeSpecTemplatePodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaBridgeSpecTemplatePodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaBridgeSpecTemplatePodImagePullSecrets
 */
export interface KafkaBridgeSpecTemplatePodImagePullSecrets {
  /**
   * @schema KafkaBridgeSpecTemplatePodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaBridgeSpecTemplatePodSecurityContext
 */
export interface KafkaBridgeSpecTemplatePodSecurityContext {
  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaBridgeSpecTemplatePodSecurityContextSysctls[];

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions;

}

/**
 * The pod's affinity rules.
 *
 * @schema KafkaBridgeSpecTemplatePodAffinity
 */
export interface KafkaBridgeSpecTemplatePodAffinity {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaBridgeSpecTemplatePodAffinityNodeAffinity;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaBridgeSpecTemplatePodAffinityPodAffinity;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinity;

}

/**
 * @schema KafkaBridgeSpecTemplatePodTolerations
 */
export interface KafkaBridgeSpecTemplatePodTolerations {
  /**
   * @schema KafkaBridgeSpecTemplatePodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaBridgeSpecTemplatePodTolerations#value
   */
  readonly value?: string;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaBridgeSpecTemplateApiServiceMetadata
 */
export interface KafkaBridgeSpecTemplateApiServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaBridgeSpecTemplateApiServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaBridgeSpecTemplateApiServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaBridgeSpecTemplateBridgeContainerEnv
 */
export interface KafkaBridgeSpecTemplateBridgeContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaBridgeSpecTemplateBridgeContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaBridgeSpecTemplateBridgeContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext
 */
export interface KafkaBridgeSpecTemplateBridgeContainerSecurityContext {
  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaBridgeSpecTemplateBridgeContainerSecurityContextCapabilities;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions;

}

/**
 * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
 *
 * @schema KafkaBridgeSpecTemplatePodDisruptionBudgetMetadata
 */
export interface KafkaBridgeSpecTemplatePodDisruptionBudgetMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaBridgeSpecTemplatePodDisruptionBudgetMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaBridgeSpecTemplatePodDisruptionBudgetMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaBridgeSpecTemplatePodSecurityContextSysctls
 */
export interface KafkaBridgeSpecTemplatePodSecurityContextSysctls {
  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions {
  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinity
 */
export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinity {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinity
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAffinity {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinity {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextCapabilities
 */
export interface KafkaBridgeSpecTemplateBridgeContainerSecurityContextCapabilities {
  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions
 */
export interface KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions
 */
export interface KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

