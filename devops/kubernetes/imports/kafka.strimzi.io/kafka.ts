// generated by cdk8s
import { ApiObject } from 'cdk8s';
import { Construct } from 'constructs';

/**
 * 
 *
 * @schema Kafka
 */
export class Kafka extends ApiObject {
  /**
   * Defines a "Kafka" API object
   * @param scope the scope in which to define this object
   * @param name a scope-local name for the object
   * @param options configuration options
   */
  public constructor(scope: Construct, name: string, options: KafkaOptions = {}) {
    super(scope, name, {
      ...options,
      kind: 'Kafka',
      apiVersion: 'kafka.strimzi.io/v1beta1',
    });
  }
}

/**
 * @schema Kafka
 */
export interface KafkaOptions {
  /**
   * The specification of the Kafka and ZooKeeper clusters, and Topic Operator.
   *
   * @schema Kafka#spec
   */
  readonly spec?: KafkaSpec;

}

/**
 * The specification of the Kafka and ZooKeeper clusters, and Topic Operator.
 *
 * @schema KafkaSpec
 */
export interface KafkaSpec {
  /**
   * Configuration of the Kafka cluster.
   *
   * @schema KafkaSpec#kafka
   */
  readonly kafka: KafkaSpecKafka;

  /**
   * Configuration of the ZooKeeper cluster.
   *
   * @schema KafkaSpec#zookeeper
   */
  readonly zookeeper: KafkaSpecZookeeper;

  /**
   * Configuration of the Topic Operator.
   *
   * @schema KafkaSpec#topicOperator
   */
  readonly topicOperator?: KafkaSpecTopicOperator;

  /**
   * Configuration of the Entity Operator.
   *
   * @schema KafkaSpec#entityOperator
   */
  readonly entityOperator?: KafkaSpecEntityOperator;

  /**
   * Configuration of the cluster certificate authority.
   *
   * @schema KafkaSpec#clusterCa
   */
  readonly clusterCa?: KafkaSpecClusterCa;

  /**
   * Configuration of the clients certificate authority.
   *
   * @schema KafkaSpec#clientsCa
   */
  readonly clientsCa?: KafkaSpecClientsCa;

  /**
   * Configuration for Cruise Control deployment. Deploys a Cruise Control instance when specified.
   *
   * @schema KafkaSpec#cruiseControl
   */
  readonly cruiseControl?: KafkaSpecCruiseControl;

  /**
   * Configuration for JmxTrans. When the property is present a JmxTrans deployment is created for gathering JMX metrics from each Kafka broker. For more information see https://github.com/jmxtrans/jmxtrans[JmxTrans GitHub].
   *
   * @schema KafkaSpec#jmxTrans
   */
  readonly jmxTrans?: KafkaSpecJmxTrans;

  /**
   * Configuration of the Kafka Exporter. Kafka Exporter can provide additional metrics, for example lag of consumer group at topic/partition.
   *
   * @schema KafkaSpec#kafkaExporter
   */
  readonly kafkaExporter?: KafkaSpecKafkaExporter;

  /**
   * A list of time windows for maintenance tasks (that is, certificates renewal). Each time window is defined by a cron expression.
   *
   * @schema KafkaSpec#maintenanceTimeWindows
   */
  readonly maintenanceTimeWindows?: string[];

}

/**
 * Configuration of the Kafka cluster.
 *
 * @schema KafkaSpecKafka
 */
export interface KafkaSpecKafka {
  /**
   * The number of pods in the cluster.
   *
   * @schema KafkaSpecKafka#replicas
   */
  readonly replicas: number;

  /**
   * The docker image for the pods. The default value depends on the configured `Kafka.spec.kafka.version`.
   *
   * @schema KafkaSpecKafka#image
   */
  readonly image?: string;

  /**
   * Storage configuration (disk). Cannot be updated.
   *
   * @schema KafkaSpecKafka#storage
   */
  readonly storage: KafkaSpecKafkaStorage;

  /**
   * @schema KafkaSpecKafka#listeners
   */
  readonly listeners: any;

  /**
   * Authorization configuration for Kafka brokers.
   *
   * @schema KafkaSpecKafka#authorization
   */
  readonly authorization?: KafkaSpecKafkaAuthorization;

  /**
   * Kafka broker config properties with the following prefixes cannot be set: listeners, advertised., broker., listener., host.name, port, inter.broker.listener.name, sasl., ssl., security., password., principal.builder.class, log.dir, zookeeper.connect, zookeeper.set.acl, zookeeper.ssl, zookeeper.clientCnxnSocket, authorizer., super.user, cruise.control.metrics.topic, cruise.control.metrics.reporter.bootstrap.servers (with the exception of: zookeeper.connection.timeout.ms, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols,cruise.control.metrics.topic.num.partitions, cruise.control.metrics.topic.replication.factor, cruise.control.metrics.topic.retention.ms,cruise.control.metrics.topic.auto.create.retries, cruise.control.metrics.topic.auto.create.timeout.ms).
   *
   * @schema KafkaSpecKafka#config
   */
  readonly config?: any;

  /**
   * Configuration of the `broker.rack` broker config.
   *
   * @schema KafkaSpecKafka#rack
   */
  readonly rack?: KafkaSpecKafkaRack;

  /**
   * The image of the init container used for initializing the `broker.rack`.
   *
   * @schema KafkaSpecKafka#brokerRackInitImage
   */
  readonly brokerRackInitImage?: string;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaSpecKafka#affinity
   */
  readonly affinity?: KafkaSpecKafkaAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaSpecKafka#tolerations
   */
  readonly tolerations?: KafkaSpecKafkaTolerations[];

  /**
   * Pod liveness checking.
   *
   * @schema KafkaSpecKafka#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecKafkaLivenessProbe;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaSpecKafka#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecKafkaReadinessProbe;

  /**
   * JVM Options for pods.
   *
   * @schema KafkaSpecKafka#jvmOptions
   */
  readonly jvmOptions?: KafkaSpecKafkaJvmOptions;

  /**
   * JMX Options for Kafka brokers.
   *
   * @schema KafkaSpecKafka#jmxOptions
   */
  readonly jmxOptions?: KafkaSpecKafkaJmxOptions;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecKafka#resources
   */
  readonly resources?: KafkaSpecKafkaResources;

  /**
   * The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
   *
   * @schema KafkaSpecKafka#metrics
   */
  readonly metrics?: any;

  /**
   * Logging configuration for Kafka.
   *
   * @schema KafkaSpecKafka#logging
   */
  readonly logging?: KafkaSpecKafkaLogging;

  /**
   * TLS sidecar configuration.
   *
   * @schema KafkaSpecKafka#tlsSidecar
   */
  readonly tlsSidecar?: KafkaSpecKafkaTlsSidecar;

  /**
   * Template for Kafka cluster resources. The template allows users to specify how are the `StatefulSet`, `Pods` and `Services` generated.
   *
   * @schema KafkaSpecKafka#template
   */
  readonly template?: KafkaSpecKafkaTemplate;

  /**
   * The kafka broker version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
   *
   * @default DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
   * @schema KafkaSpecKafka#version
   */
  readonly version?: string;

}

/**
 * Configuration of the ZooKeeper cluster.
 *
 * @schema KafkaSpecZookeeper
 */
export interface KafkaSpecZookeeper {
  /**
   * The number of pods in the cluster.
   *
   * @schema KafkaSpecZookeeper#replicas
   */
  readonly replicas: number;

  /**
   * The docker image for the pods.
   *
   * @schema KafkaSpecZookeeper#image
   */
  readonly image?: string;

  /**
   * Storage configuration (disk). Cannot be updated.
   *
   * @schema KafkaSpecZookeeper#storage
   */
  readonly storage: KafkaSpecZookeeperStorage;

  /**
   * The ZooKeeper broker config. Properties with the following prefixes cannot be set: server., dataDir, dataLogDir, clientPort, authProvider, quorum.auth, requireClientAuthScheme, snapshot.trust.empty, standaloneEnabled, reconfigEnabled, 4lw.commands.whitelist, secureClientPort, ssl., serverCnxnFactory, sslQuorum (with the exception of: ssl.protocol, ssl.quorum.protocol, ssl.enabledProtocols, ssl.quorum.enabledProtocols, ssl.ciphersuites, ssl.quorum.ciphersuites, ssl.hostnameVerification, ssl.quorum.hostnameVerification).
   *
   * @schema KafkaSpecZookeeper#config
   */
  readonly config?: any;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaSpecZookeeper#affinity
   */
  readonly affinity?: KafkaSpecZookeeperAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaSpecZookeeper#tolerations
   */
  readonly tolerations?: KafkaSpecZookeeperTolerations[];

  /**
   * Pod liveness checking.
   *
   * @schema KafkaSpecZookeeper#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecZookeeperLivenessProbe;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaSpecZookeeper#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecZookeeperReadinessProbe;

  /**
   * JVM Options for pods.
   *
   * @schema KafkaSpecZookeeper#jvmOptions
   */
  readonly jvmOptions?: KafkaSpecZookeeperJvmOptions;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecZookeeper#resources
   */
  readonly resources?: KafkaSpecZookeeperResources;

  /**
   * The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
   *
   * @schema KafkaSpecZookeeper#metrics
   */
  readonly metrics?: any;

  /**
   * Logging configuration for ZooKeeper.
   *
   * @schema KafkaSpecZookeeper#logging
   */
  readonly logging?: KafkaSpecZookeeperLogging;

  /**
   * Template for ZooKeeper cluster resources. The template allows users to specify how are the `StatefulSet`, `Pods` and `Services` generated.
   *
   * @schema KafkaSpecZookeeper#template
   */
  readonly template?: KafkaSpecZookeeperTemplate;

  /**
   * TLS sidecar configuration. The TLS sidecar is not used anymore and this option will be ignored.
   *
   * @schema KafkaSpecZookeeper#tlsSidecar
   */
  readonly tlsSidecar?: KafkaSpecZookeeperTlsSidecar;

}

/**
 * Configuration of the Topic Operator.
 *
 * @schema KafkaSpecTopicOperator
 */
export interface KafkaSpecTopicOperator {
  /**
   * The namespace the Topic Operator should watch.
   *
   * @schema KafkaSpecTopicOperator#watchedNamespace
   */
  readonly watchedNamespace?: string;

  /**
   * The image to use for the Topic Operator.
   *
   * @schema KafkaSpecTopicOperator#image
   */
  readonly image?: string;

  /**
   * Interval between periodic reconciliations.
   *
   * @schema KafkaSpecTopicOperator#reconciliationIntervalSeconds
   */
  readonly reconciliationIntervalSeconds?: number;

  /**
   * Timeout for the ZooKeeper session.
   *
   * @schema KafkaSpecTopicOperator#zookeeperSessionTimeoutSeconds
   */
  readonly zookeeperSessionTimeoutSeconds?: number;

  /**
   * Pod affinity rules.
   *
   * @schema KafkaSpecTopicOperator#affinity
   */
  readonly affinity?: KafkaSpecTopicOperatorAffinity;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecTopicOperator#resources
   */
  readonly resources?: KafkaSpecTopicOperatorResources;

  /**
   * The number of attempts at getting topic metadata.
   *
   * @schema KafkaSpecTopicOperator#topicMetadataMaxAttempts
   */
  readonly topicMetadataMaxAttempts?: number;

  /**
   * TLS sidecar configuration.
   *
   * @schema KafkaSpecTopicOperator#tlsSidecar
   */
  readonly tlsSidecar?: KafkaSpecTopicOperatorTlsSidecar;

  /**
   * Logging configuration.
   *
   * @schema KafkaSpecTopicOperator#logging
   */
  readonly logging?: KafkaSpecTopicOperatorLogging;

  /**
   * JVM Options for pods.
   *
   * @schema KafkaSpecTopicOperator#jvmOptions
   */
  readonly jvmOptions?: KafkaSpecTopicOperatorJvmOptions;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaSpecTopicOperator#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecTopicOperatorLivenessProbe;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaSpecTopicOperator#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecTopicOperatorReadinessProbe;

}

/**
 * Configuration of the Entity Operator.
 *
 * @schema KafkaSpecEntityOperator
 */
export interface KafkaSpecEntityOperator {
  /**
   * Configuration of the Topic Operator.
   *
   * @schema KafkaSpecEntityOperator#topicOperator
   */
  readonly topicOperator?: KafkaSpecEntityOperatorTopicOperator;

  /**
   * Configuration of the User Operator.
   *
   * @schema KafkaSpecEntityOperator#userOperator
   */
  readonly userOperator?: KafkaSpecEntityOperatorUserOperator;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaSpecEntityOperator#affinity
   */
  readonly affinity?: KafkaSpecEntityOperatorAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaSpecEntityOperator#tolerations
   */
  readonly tolerations?: KafkaSpecEntityOperatorTolerations[];

  /**
   * TLS sidecar configuration.
   *
   * @schema KafkaSpecEntityOperator#tlsSidecar
   */
  readonly tlsSidecar?: KafkaSpecEntityOperatorTlsSidecar;

  /**
   * Template for Entity Operator resources. The template allows users to specify how is the `Deployment` and `Pods` generated.
   *
   * @schema KafkaSpecEntityOperator#template
   */
  readonly template?: KafkaSpecEntityOperatorTemplate;

}

/**
 * Configuration of the cluster certificate authority.
 *
 * @schema KafkaSpecClusterCa
 */
export interface KafkaSpecClusterCa {
  /**
   * If true then Certificate Authority certificates will be generated automatically. Otherwise the user will need to provide a Secret with the CA certificate. Default is true.
   *
   * @default true.
   * @schema KafkaSpecClusterCa#generateCertificateAuthority
   */
  readonly generateCertificateAuthority?: boolean;

  /**
   * The number of days generated certificates should be valid for. The default is 365.
   *
   * @schema KafkaSpecClusterCa#validityDays
   */
  readonly validityDays?: number;

  /**
   * The number of days in the certificate renewal period. This is the number of days before the a certificate expires during which renewal actions may be performed. When `generateCertificateAuthority` is true, this will cause the generation of a new certificate. When `generateCertificateAuthority` is true, this will cause extra logging at WARN level about the pending certificate expiry. Default is 30.
   *
   * @default 30.
   * @schema KafkaSpecClusterCa#renewalDays
   */
  readonly renewalDays?: number;

  /**
   * How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.
   *
   * @schema KafkaSpecClusterCa#certificateExpirationPolicy
   */
  readonly certificateExpirationPolicy?: KafkaSpecClusterCaCertificateExpirationPolicy;

}

/**
 * Configuration of the clients certificate authority.
 *
 * @schema KafkaSpecClientsCa
 */
export interface KafkaSpecClientsCa {
  /**
   * If true then Certificate Authority certificates will be generated automatically. Otherwise the user will need to provide a Secret with the CA certificate. Default is true.
   *
   * @default true.
   * @schema KafkaSpecClientsCa#generateCertificateAuthority
   */
  readonly generateCertificateAuthority?: boolean;

  /**
   * The number of days generated certificates should be valid for. The default is 365.
   *
   * @schema KafkaSpecClientsCa#validityDays
   */
  readonly validityDays?: number;

  /**
   * The number of days in the certificate renewal period. This is the number of days before the a certificate expires during which renewal actions may be performed. When `generateCertificateAuthority` is true, this will cause the generation of a new certificate. When `generateCertificateAuthority` is true, this will cause extra logging at WARN level about the pending certificate expiry. Default is 30.
   *
   * @default 30.
   * @schema KafkaSpecClientsCa#renewalDays
   */
  readonly renewalDays?: number;

  /**
   * How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.
   *
   * @schema KafkaSpecClientsCa#certificateExpirationPolicy
   */
  readonly certificateExpirationPolicy?: KafkaSpecClientsCaCertificateExpirationPolicy;

}

/**
 * Configuration for Cruise Control deployment. Deploys a Cruise Control instance when specified.
 *
 * @schema KafkaSpecCruiseControl
 */
export interface KafkaSpecCruiseControl {
  /**
   * The docker image for the pods.
   *
   * @schema KafkaSpecCruiseControl#image
   */
  readonly image?: string;

  /**
   * TLS sidecar configuration.
   *
   * @schema KafkaSpecCruiseControl#tlsSidecar
   */
  readonly tlsSidecar?: KafkaSpecCruiseControlTlsSidecar;

  /**
   * CPU and memory resources to reserve for the Cruise Control container.
   *
   * @schema KafkaSpecCruiseControl#resources
   */
  readonly resources?: KafkaSpecCruiseControlResources;

  /**
   * Pod liveness checking for the Cruise Control container.
   *
   * @schema KafkaSpecCruiseControl#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecCruiseControlLivenessProbe;

  /**
   * Pod readiness checking for the Cruise Control container.
   *
   * @schema KafkaSpecCruiseControl#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecCruiseControlReadinessProbe;

  /**
   * JVM Options for the Cruise Control container.
   *
   * @schema KafkaSpecCruiseControl#jvmOptions
   */
  readonly jvmOptions?: KafkaSpecCruiseControlJvmOptions;

  /**
   * Logging configuration (log4j1) for Cruise Control.
   *
   * @schema KafkaSpecCruiseControl#logging
   */
  readonly logging?: KafkaSpecCruiseControlLogging;

  /**
   * Template to specify how Cruise Control resources, `Deployments` and `Pods`, are generated.
   *
   * @schema KafkaSpecCruiseControl#template
   */
  readonly template?: KafkaSpecCruiseControlTemplate;

  /**
   * The Cruise Control `brokerCapacity` configuration.
   *
   * @schema KafkaSpecCruiseControl#brokerCapacity
   */
  readonly brokerCapacity?: KafkaSpecCruiseControlBrokerCapacity;

  /**
   * The Cruise Control configuration. For a full list of configuration options refer to https://github.com/linkedin/cruise-control/wiki/Configurations. Note that properties with the following prefixes cannot be set: bootstrap.servers, client.id, zookeeper., network., security., failed.brokers.zk.path,webserver.http., webserver.api.urlprefix, webserver.session.path, webserver.accesslog., two.step., request.reason.required,metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, partition.metric.sample.store.topic, broker.metric.sample.store.topic,capacity.config.file, self.healing., anomaly.detection., ssl.
   *
   * @schema KafkaSpecCruiseControl#config
   */
  readonly config?: any;

  /**
   * The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
   *
   * @schema KafkaSpecCruiseControl#metrics
   */
  readonly metrics?: any;

}

/**
 * Configuration for JmxTrans. When the property is present a JmxTrans deployment is created for gathering JMX metrics from each Kafka broker. For more information see https://github.com/jmxtrans/jmxtrans[JmxTrans GitHub].
 *
 * @schema KafkaSpecJmxTrans
 */
export interface KafkaSpecJmxTrans {
  /**
   * The image to use for the JmxTrans.
   *
   * @schema KafkaSpecJmxTrans#image
   */
  readonly image?: string;

  /**
   * Defines the output hosts that will be referenced later on. For more information on these properties see, xref:type-JmxTransOutputDefinitionTemplate-reference[`JmxTransOutputDefinitionTemplate` schema reference].
   *
   * @schema KafkaSpecJmxTrans#outputDefinitions
   */
  readonly outputDefinitions: KafkaSpecJmxTransOutputDefinitions[];

  /**
   * Sets the logging level of the JmxTrans deployment.For more information see, https://github.com/jmxtrans/jmxtrans-agent/wiki/Troubleshooting[JmxTrans Logging Level].
   *
   * @schema KafkaSpecJmxTrans#logLevel
   */
  readonly logLevel?: string;

  /**
   * Queries to send to the Kafka brokers to define what data should be read from each broker. For more information on these properties see, xref:type-JmxTransQueryTemplate-reference[`JmxTransQueryTemplate` schema reference].
   *
   * @schema KafkaSpecJmxTrans#kafkaQueries
   */
  readonly kafkaQueries: KafkaSpecJmxTransKafkaQueries[];

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecJmxTrans#resources
   */
  readonly resources?: KafkaSpecJmxTransResources;

  /**
   * Template for JmxTrans resources.
   *
   * @schema KafkaSpecJmxTrans#template
   */
  readonly template?: KafkaSpecJmxTransTemplate;

}

/**
 * Configuration of the Kafka Exporter. Kafka Exporter can provide additional metrics, for example lag of consumer group at topic/partition.
 *
 * @schema KafkaSpecKafkaExporter
 */
export interface KafkaSpecKafkaExporter {
  /**
   * The docker image for the pods.
   *
   * @schema KafkaSpecKafkaExporter#image
   */
  readonly image?: string;

  /**
   * Regular expression to specify which consumer groups to collect. Default value is `.*`.
   *
   * @schema KafkaSpecKafkaExporter#groupRegex
   */
  readonly groupRegex?: string;

  /**
   * Regular expression to specify which topics to collect. Default value is `.*`.
   *
   * @schema KafkaSpecKafkaExporter#topicRegex
   */
  readonly topicRegex?: string;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecKafkaExporter#resources
   */
  readonly resources?: KafkaSpecKafkaExporterResources;

  /**
   * Only log messages with the given severity or above. Valid levels: [`debug`, `info`, `warn`, `error`, `fatal`]. Default log level is `info`.
   *
   * @schema KafkaSpecKafkaExporter#logging
   */
  readonly logging?: string;

  /**
   * Enable Sarama logging, a Go client library used by the Kafka Exporter.
   *
   * @schema KafkaSpecKafkaExporter#enableSaramaLogging
   */
  readonly enableSaramaLogging?: boolean;

  /**
   * Customization of deployment templates and pods.
   *
   * @schema KafkaSpecKafkaExporter#template
   */
  readonly template?: KafkaSpecKafkaExporterTemplate;

  /**
   * Pod liveness check.
   *
   * @schema KafkaSpecKafkaExporter#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecKafkaExporterLivenessProbe;

  /**
   * Pod readiness check.
   *
   * @schema KafkaSpecKafkaExporter#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecKafkaExporterReadinessProbe;

}

/**
 * Storage configuration (disk). Cannot be updated.
 *
 * @schema KafkaSpecKafkaStorage
 */
export interface KafkaSpecKafkaStorage {
  /**
   * The storage class to use for dynamic volume allocation.
   *
   * @schema KafkaSpecKafkaStorage#class
   */
  readonly class?: string;

  /**
   * Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
   *
   * @schema KafkaSpecKafkaStorage#deleteClaim
   */
  readonly deleteClaim?: boolean;

  /**
   * Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
   *
   * @schema KafkaSpecKafkaStorage#id
   */
  readonly id?: number;

  /**
   * Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
   *
   * @schema KafkaSpecKafkaStorage#overrides
   */
  readonly overrides?: KafkaSpecKafkaStorageOverrides[];

  /**
   * Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
   *
   * @schema KafkaSpecKafkaStorage#selector
   */
  readonly selector?: any;

  /**
   * When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
   *
   * @schema KafkaSpecKafkaStorage#size
   */
  readonly size?: string;

  /**
   * When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
   *
   * @schema KafkaSpecKafkaStorage#sizeLimit
   */
  readonly sizeLimit?: string;

  /**
   * Storage type, must be either 'ephemeral', 'persistent-claim', or 'jbod'.
   *
   * @schema KafkaSpecKafkaStorage#type
   */
  readonly type: KafkaSpecKafkaStorageType;

  /**
   * List of volumes as Storage objects representing the JBOD disks array.
   *
   * @schema KafkaSpecKafkaStorage#volumes
   */
  readonly volumes?: KafkaSpecKafkaStorageVolumes[];

}

/**
 * Authorization configuration for Kafka brokers.
 *
 * @schema KafkaSpecKafkaAuthorization
 */
export interface KafkaSpecKafkaAuthorization {
  /**
   * Defines whether a Kafka client should be allowed or denied by default when the authorizer fails to query the Open Policy Agent, for example, when it is temporarily unavailable). Defaults to `false` - all actions will be denied.
   *
   * @default false` - all actions will be denied.
   * @schema KafkaSpecKafkaAuthorization#allowOnError
   */
  readonly allowOnError?: boolean;

  /**
   * OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
   *
   * @schema KafkaSpecKafkaAuthorization#clientId
   */
  readonly clientId?: string;

  /**
   * Whether authorization decision should be delegated to the 'Simple' authorizer if DENIED by Keycloak Authorization Services policies. Default value is `false`.
   *
   * @schema KafkaSpecKafkaAuthorization#delegateToKafkaAcls
   */
  readonly delegateToKafkaAcls?: boolean;

  /**
   * Enable or disable TLS hostname verification. Default value is `false`.
   *
   * @schema KafkaSpecKafkaAuthorization#disableTlsHostnameVerification
   */
  readonly disableTlsHostnameVerification?: boolean;

  /**
   * The expiration of the records kept in the local cache to avoid querying the Open Policy Agent for every request. Defines how often the cached authorization decisions are reloaded from the Open Policy Agent server. In milliseconds. Defaults to `3600000`.
   *
   * @default 3600000`.
   * @schema KafkaSpecKafkaAuthorization#expireAfterMs
   */
  readonly expireAfterMs?: number;

  /**
   * The time between two consecutive grants refresh runs in seconds. The default value is 60.
   *
   * @schema KafkaSpecKafkaAuthorization#grantsRefreshPeriodSeconds
   */
  readonly grantsRefreshPeriodSeconds?: number;

  /**
   * The number of threads to use to refresh grants for active sessions. The more threads, the more parallelism, so the sooner the job completes. However, using more threads places a heavier load on the authorization server. The default value is 5.
   *
   * @schema KafkaSpecKafkaAuthorization#grantsRefreshPoolSize
   */
  readonly grantsRefreshPoolSize?: number;

  /**
   * Initial capacity of the local cache used by the authorizer to avoid querying the Open Policy Agent for every request Defaults to `5000`.
   *
   * @default 5000`.
   * @schema KafkaSpecKafkaAuthorization#initialCacheCapacity
   */
  readonly initialCacheCapacity?: number;

  /**
   * Maximum capacity of the local cache used by the authorizer to avoid querying the Open Policy Agent for every request. Defaults to `50000`.
   *
   * @default 50000`.
   * @schema KafkaSpecKafkaAuthorization#maximumCacheSize
   */
  readonly maximumCacheSize?: number;

  /**
   * List of super users. Should contain list of user principals which should get unlimited access rights.
   *
   * @schema KafkaSpecKafkaAuthorization#superUsers
   */
  readonly superUsers?: string[];

  /**
   * Trusted certificates for TLS connection to the OAuth server.
   *
   * @schema KafkaSpecKafkaAuthorization#tlsTrustedCertificates
   */
  readonly tlsTrustedCertificates?: KafkaSpecKafkaAuthorizationTlsTrustedCertificates[];

  /**
   * Authorization server token endpoint URI.
   *
   * @schema KafkaSpecKafkaAuthorization#tokenEndpointUri
   */
  readonly tokenEndpointUri?: string;

  /**
   * Authorization type. Currently, the supported types are `simple`, `keycloak`, and `opa`. `simple` authorization type uses Kafka's `kafka.security.authorizer.AclAuthorizer` class for authorization. `keycloak` authorization type uses Keycloak Authorization Services for authorization. `opa` authorization type uses Open Policy Agent based authorization.
   *
   * @schema KafkaSpecKafkaAuthorization#type
   */
  readonly type: KafkaSpecKafkaAuthorizationType;

  /**
   * The URL used to connect to the Open Policy Agent server. The URL has to include the policy which will be queried by the authorizer. This option is required.
   *
   * @schema KafkaSpecKafkaAuthorization#url
   */
  readonly url?: string;

}

/**
 * Configuration of the `broker.rack` broker config.
 *
 * @schema KafkaSpecKafkaRack
 */
export interface KafkaSpecKafkaRack {
  /**
   * A key that matches labels assigned to the Kubernetes cluster nodes. The value of the label is used to set the broker's `broker.rack` config.
   *
   * @schema KafkaSpecKafkaRack#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecKafkaAffinity
 */
export interface KafkaSpecKafkaAffinity {
  /**
   * @schema KafkaSpecKafkaAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaSpecKafkaAffinityNodeAffinity;

  /**
   * @schema KafkaSpecKafkaAffinity#podAffinity
   */
  readonly podAffinity?: KafkaSpecKafkaAffinityPodAffinity;

  /**
   * @schema KafkaSpecKafkaAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaSpecKafkaAffinityPodAntiAffinity;

}

/**
 * @schema KafkaSpecKafkaTolerations
 */
export interface KafkaSpecKafkaTolerations {
  /**
   * @schema KafkaSpecKafkaTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaSpecKafkaTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaSpecKafkaTolerations#value
   */
  readonly value?: string;

}

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecKafkaLivenessProbe
 */
export interface KafkaSpecKafkaLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecKafkaLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecKafkaLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecKafkaLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecKafkaLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecKafkaLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecKafkaReadinessProbe
 */
export interface KafkaSpecKafkaReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecKafkaReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecKafkaReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecKafkaReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecKafkaReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecKafkaReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * JVM Options for pods.
 *
 * @schema KafkaSpecKafkaJvmOptions
 */
export interface KafkaSpecKafkaJvmOptions {
  /**
   * A map of -XX options to the JVM.
   *
   * @schema KafkaSpecKafkaJvmOptions#-XX
   */
  readonly xx?: any;

  /**
   * -Xms option to to the JVM.
   *
   * @schema KafkaSpecKafkaJvmOptions#-Xms
   */
  readonly xms?: string;

  /**
   * -Xmx option to to the JVM.
   *
   * @schema KafkaSpecKafkaJvmOptions#-Xmx
   */
  readonly xmx?: string;

  /**
   * Specifies whether the Garbage Collection logging is enabled. The default is false.
   *
   * @schema KafkaSpecKafkaJvmOptions#gcLoggingEnabled
   */
  readonly gcLoggingEnabled?: boolean;

  /**
   * A map of additional system properties which will be passed using the `-D` option to the JVM.
   *
   * @schema KafkaSpecKafkaJvmOptions#javaSystemProperties
   */
  readonly javaSystemProperties?: KafkaSpecKafkaJvmOptionsJavaSystemProperties[];

}

/**
 * JMX Options for Kafka brokers.
 *
 * @schema KafkaSpecKafkaJmxOptions
 */
export interface KafkaSpecKafkaJmxOptions {
  /**
   * Authentication configuration for connecting to the Kafka JMX port.
   *
   * @schema KafkaSpecKafkaJmxOptions#authentication
   */
  readonly authentication?: KafkaSpecKafkaJmxOptionsAuthentication;

}

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecKafkaResources
 */
export interface KafkaSpecKafkaResources {
  /**
   * @schema KafkaSpecKafkaResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecKafkaResources#requests
   */
  readonly requests?: any;

}

/**
 * Logging configuration for Kafka.
 *
 * @schema KafkaSpecKafkaLogging
 */
export interface KafkaSpecKafkaLogging {
  /**
   * A Map from logger name to logger level.
   *
   * @schema KafkaSpecKafkaLogging#loggers
   */
  readonly loggers?: any;

  /**
   * The name of the `ConfigMap` from which to get the logging configuration.
   *
   * @schema KafkaSpecKafkaLogging#name
   */
  readonly name?: string;

  /**
   * Logging type, must be either 'inline' or 'external'.
   *
   * @schema KafkaSpecKafkaLogging#type
   */
  readonly type: KafkaSpecKafkaLoggingType;

}

/**
 * TLS sidecar configuration.
 *
 * @schema KafkaSpecKafkaTlsSidecar
 */
export interface KafkaSpecKafkaTlsSidecar {
  /**
   * The docker image for the container.
   *
   * @schema KafkaSpecKafkaTlsSidecar#image
   */
  readonly image?: string;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaSpecKafkaTlsSidecar#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecKafkaTlsSidecarLivenessProbe;

  /**
   * The log level for the TLS sidecar. Default value is `notice`.
   *
   * @schema KafkaSpecKafkaTlsSidecar#logLevel
   */
  readonly logLevel?: KafkaSpecKafkaTlsSidecarLogLevel;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaSpecKafkaTlsSidecar#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecKafkaTlsSidecarReadinessProbe;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecKafkaTlsSidecar#resources
   */
  readonly resources?: KafkaSpecKafkaTlsSidecarResources;

}

/**
 * Template for Kafka cluster resources. The template allows users to specify how are the `StatefulSet`, `Pods` and `Services` generated.
 *
 * @schema KafkaSpecKafkaTemplate
 */
export interface KafkaSpecKafkaTemplate {
  /**
   * Template for Kafka `StatefulSet`.
   *
   * @schema KafkaSpecKafkaTemplate#statefulset
   */
  readonly statefulset?: KafkaSpecKafkaTemplateStatefulset;

  /**
   * Template for Kafka `Pods`.
   *
   * @schema KafkaSpecKafkaTemplate#pod
   */
  readonly pod?: KafkaSpecKafkaTemplatePod;

  /**
   * Template for Kafka bootstrap `Service`.
   *
   * @schema KafkaSpecKafkaTemplate#bootstrapService
   */
  readonly bootstrapService?: KafkaSpecKafkaTemplateBootstrapService;

  /**
   * Template for Kafka broker `Service`.
   *
   * @schema KafkaSpecKafkaTemplate#brokersService
   */
  readonly brokersService?: KafkaSpecKafkaTemplateBrokersService;

  /**
   * Template for Kafka external bootstrap `Service`.
   *
   * @schema KafkaSpecKafkaTemplate#externalBootstrapService
   */
  readonly externalBootstrapService?: KafkaSpecKafkaTemplateExternalBootstrapService;

  /**
   * Template for Kafka per-pod `Services` used for access from outside of Kubernetes.
   *
   * @schema KafkaSpecKafkaTemplate#perPodService
   */
  readonly perPodService?: KafkaSpecKafkaTemplatePerPodService;

  /**
   * Template for Kafka external bootstrap `Route`.
   *
   * @schema KafkaSpecKafkaTemplate#externalBootstrapRoute
   */
  readonly externalBootstrapRoute?: KafkaSpecKafkaTemplateExternalBootstrapRoute;

  /**
   * Template for Kafka per-pod `Routes` used for access from outside of OpenShift.
   *
   * @schema KafkaSpecKafkaTemplate#perPodRoute
   */
  readonly perPodRoute?: KafkaSpecKafkaTemplatePerPodRoute;

  /**
   * Template for Kafka external bootstrap `Ingress`.
   *
   * @schema KafkaSpecKafkaTemplate#externalBootstrapIngress
   */
  readonly externalBootstrapIngress?: KafkaSpecKafkaTemplateExternalBootstrapIngress;

  /**
   * Template for Kafka per-pod `Ingress` used for access from outside of Kubernetes.
   *
   * @schema KafkaSpecKafkaTemplate#perPodIngress
   */
  readonly perPodIngress?: KafkaSpecKafkaTemplatePerPodIngress;

  /**
   * Template for all Kafka `PersistentVolumeClaims`.
   *
   * @schema KafkaSpecKafkaTemplate#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: KafkaSpecKafkaTemplatePersistentVolumeClaim;

  /**
   * Template for Kafka `PodDisruptionBudget`.
   *
   * @schema KafkaSpecKafkaTemplate#podDisruptionBudget
   */
  readonly podDisruptionBudget?: KafkaSpecKafkaTemplatePodDisruptionBudget;

  /**
   * Template for the Kafka broker container.
   *
   * @schema KafkaSpecKafkaTemplate#kafkaContainer
   */
  readonly kafkaContainer?: KafkaSpecKafkaTemplateKafkaContainer;

  /**
   * Template for the Kafka broker TLS sidecar container.
   *
   * @schema KafkaSpecKafkaTemplate#tlsSidecarContainer
   */
  readonly tlsSidecarContainer?: KafkaSpecKafkaTemplateTlsSidecarContainer;

  /**
   * Template for the Kafka init container.
   *
   * @schema KafkaSpecKafkaTemplate#initContainer
   */
  readonly initContainer?: KafkaSpecKafkaTemplateInitContainer;

}

/**
 * Storage configuration (disk). Cannot be updated.
 *
 * @schema KafkaSpecZookeeperStorage
 */
export interface KafkaSpecZookeeperStorage {
  /**
   * The storage class to use for dynamic volume allocation.
   *
   * @schema KafkaSpecZookeeperStorage#class
   */
  readonly class?: string;

  /**
   * Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
   *
   * @schema KafkaSpecZookeeperStorage#deleteClaim
   */
  readonly deleteClaim?: boolean;

  /**
   * Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
   *
   * @schema KafkaSpecZookeeperStorage#id
   */
  readonly id?: number;

  /**
   * Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
   *
   * @schema KafkaSpecZookeeperStorage#overrides
   */
  readonly overrides?: KafkaSpecZookeeperStorageOverrides[];

  /**
   * Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
   *
   * @schema KafkaSpecZookeeperStorage#selector
   */
  readonly selector?: any;

  /**
   * When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
   *
   * @schema KafkaSpecZookeeperStorage#size
   */
  readonly size?: string;

  /**
   * When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
   *
   * @schema KafkaSpecZookeeperStorage#sizeLimit
   */
  readonly sizeLimit?: string;

  /**
   * Storage type, must be either 'ephemeral' or 'persistent-claim'.
   *
   * @schema KafkaSpecZookeeperStorage#type
   */
  readonly type: KafkaSpecZookeeperStorageType;

}

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecZookeeperAffinity
 */
export interface KafkaSpecZookeeperAffinity {
  /**
   * @schema KafkaSpecZookeeperAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaSpecZookeeperAffinityNodeAffinity;

  /**
   * @schema KafkaSpecZookeeperAffinity#podAffinity
   */
  readonly podAffinity?: KafkaSpecZookeeperAffinityPodAffinity;

  /**
   * @schema KafkaSpecZookeeperAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaSpecZookeeperAffinityPodAntiAffinity;

}

/**
 * @schema KafkaSpecZookeeperTolerations
 */
export interface KafkaSpecZookeeperTolerations {
  /**
   * @schema KafkaSpecZookeeperTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaSpecZookeeperTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaSpecZookeeperTolerations#value
   */
  readonly value?: string;

}

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecZookeeperLivenessProbe
 */
export interface KafkaSpecZookeeperLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecZookeeperLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecZookeeperLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecZookeeperLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecZookeeperLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecZookeeperLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecZookeeperReadinessProbe
 */
export interface KafkaSpecZookeeperReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecZookeeperReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecZookeeperReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecZookeeperReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecZookeeperReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecZookeeperReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * JVM Options for pods.
 *
 * @schema KafkaSpecZookeeperJvmOptions
 */
export interface KafkaSpecZookeeperJvmOptions {
  /**
   * A map of -XX options to the JVM.
   *
   * @schema KafkaSpecZookeeperJvmOptions#-XX
   */
  readonly xx?: any;

  /**
   * -Xms option to to the JVM.
   *
   * @schema KafkaSpecZookeeperJvmOptions#-Xms
   */
  readonly xms?: string;

  /**
   * -Xmx option to to the JVM.
   *
   * @schema KafkaSpecZookeeperJvmOptions#-Xmx
   */
  readonly xmx?: string;

  /**
   * Specifies whether the Garbage Collection logging is enabled. The default is false.
   *
   * @schema KafkaSpecZookeeperJvmOptions#gcLoggingEnabled
   */
  readonly gcLoggingEnabled?: boolean;

  /**
   * A map of additional system properties which will be passed using the `-D` option to the JVM.
   *
   * @schema KafkaSpecZookeeperJvmOptions#javaSystemProperties
   */
  readonly javaSystemProperties?: KafkaSpecZookeeperJvmOptionsJavaSystemProperties[];

}

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecZookeeperResources
 */
export interface KafkaSpecZookeeperResources {
  /**
   * @schema KafkaSpecZookeeperResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecZookeeperResources#requests
   */
  readonly requests?: any;

}

/**
 * Logging configuration for ZooKeeper.
 *
 * @schema KafkaSpecZookeeperLogging
 */
export interface KafkaSpecZookeeperLogging {
  /**
   * A Map from logger name to logger level.
   *
   * @schema KafkaSpecZookeeperLogging#loggers
   */
  readonly loggers?: any;

  /**
   * The name of the `ConfigMap` from which to get the logging configuration.
   *
   * @schema KafkaSpecZookeeperLogging#name
   */
  readonly name?: string;

  /**
   * Logging type, must be either 'inline' or 'external'.
   *
   * @schema KafkaSpecZookeeperLogging#type
   */
  readonly type: KafkaSpecZookeeperLoggingType;

}

/**
 * Template for ZooKeeper cluster resources. The template allows users to specify how are the `StatefulSet`, `Pods` and `Services` generated.
 *
 * @schema KafkaSpecZookeeperTemplate
 */
export interface KafkaSpecZookeeperTemplate {
  /**
   * Template for ZooKeeper `StatefulSet`.
   *
   * @schema KafkaSpecZookeeperTemplate#statefulset
   */
  readonly statefulset?: KafkaSpecZookeeperTemplateStatefulset;

  /**
   * Template for ZooKeeper `Pods`.
   *
   * @schema KafkaSpecZookeeperTemplate#pod
   */
  readonly pod?: KafkaSpecZookeeperTemplatePod;

  /**
   * Template for ZooKeeper client `Service`.
   *
   * @schema KafkaSpecZookeeperTemplate#clientService
   */
  readonly clientService?: KafkaSpecZookeeperTemplateClientService;

  /**
   * Template for ZooKeeper nodes `Service`.
   *
   * @schema KafkaSpecZookeeperTemplate#nodesService
   */
  readonly nodesService?: KafkaSpecZookeeperTemplateNodesService;

  /**
   * Template for all ZooKeeper `PersistentVolumeClaims`.
   *
   * @schema KafkaSpecZookeeperTemplate#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: KafkaSpecZookeeperTemplatePersistentVolumeClaim;

  /**
   * Template for ZooKeeper `PodDisruptionBudget`.
   *
   * @schema KafkaSpecZookeeperTemplate#podDisruptionBudget
   */
  readonly podDisruptionBudget?: KafkaSpecZookeeperTemplatePodDisruptionBudget;

  /**
   * Template for the ZooKeeper container.
   *
   * @schema KafkaSpecZookeeperTemplate#zookeeperContainer
   */
  readonly zookeeperContainer?: KafkaSpecZookeeperTemplateZookeeperContainer;

  /**
   * Template for the Zookeeper server TLS sidecar container. The TLS sidecar is not used anymore and this option will be ignored.
   *
   * @schema KafkaSpecZookeeperTemplate#tlsSidecarContainer
   */
  readonly tlsSidecarContainer?: KafkaSpecZookeeperTemplateTlsSidecarContainer;

}

/**
 * TLS sidecar configuration. The TLS sidecar is not used anymore and this option will be ignored.
 *
 * @schema KafkaSpecZookeeperTlsSidecar
 */
export interface KafkaSpecZookeeperTlsSidecar {
  /**
   * The docker image for the container.
   *
   * @schema KafkaSpecZookeeperTlsSidecar#image
   */
  readonly image?: string;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaSpecZookeeperTlsSidecar#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecZookeeperTlsSidecarLivenessProbe;

  /**
   * The log level for the TLS sidecar. Default value is `notice`.
   *
   * @schema KafkaSpecZookeeperTlsSidecar#logLevel
   */
  readonly logLevel?: KafkaSpecZookeeperTlsSidecarLogLevel;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaSpecZookeeperTlsSidecar#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecZookeeperTlsSidecarReadinessProbe;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecZookeeperTlsSidecar#resources
   */
  readonly resources?: KafkaSpecZookeeperTlsSidecarResources;

}

/**
 * Pod affinity rules.
 *
 * @schema KafkaSpecTopicOperatorAffinity
 */
export interface KafkaSpecTopicOperatorAffinity {
  /**
   * @schema KafkaSpecTopicOperatorAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaSpecTopicOperatorAffinityNodeAffinity;

  /**
   * @schema KafkaSpecTopicOperatorAffinity#podAffinity
   */
  readonly podAffinity?: KafkaSpecTopicOperatorAffinityPodAffinity;

  /**
   * @schema KafkaSpecTopicOperatorAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaSpecTopicOperatorAffinityPodAntiAffinity;

}

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecTopicOperatorResources
 */
export interface KafkaSpecTopicOperatorResources {
  /**
   * @schema KafkaSpecTopicOperatorResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecTopicOperatorResources#requests
   */
  readonly requests?: any;

}

/**
 * TLS sidecar configuration.
 *
 * @schema KafkaSpecTopicOperatorTlsSidecar
 */
export interface KafkaSpecTopicOperatorTlsSidecar {
  /**
   * The docker image for the container.
   *
   * @schema KafkaSpecTopicOperatorTlsSidecar#image
   */
  readonly image?: string;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaSpecTopicOperatorTlsSidecar#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecTopicOperatorTlsSidecarLivenessProbe;

  /**
   * The log level for the TLS sidecar. Default value is `notice`.
   *
   * @schema KafkaSpecTopicOperatorTlsSidecar#logLevel
   */
  readonly logLevel?: KafkaSpecTopicOperatorTlsSidecarLogLevel;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaSpecTopicOperatorTlsSidecar#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecTopicOperatorTlsSidecarReadinessProbe;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecTopicOperatorTlsSidecar#resources
   */
  readonly resources?: KafkaSpecTopicOperatorTlsSidecarResources;

}

/**
 * Logging configuration.
 *
 * @schema KafkaSpecTopicOperatorLogging
 */
export interface KafkaSpecTopicOperatorLogging {
  /**
   * A Map from logger name to logger level.
   *
   * @schema KafkaSpecTopicOperatorLogging#loggers
   */
  readonly loggers?: any;

  /**
   * The name of the `ConfigMap` from which to get the logging configuration.
   *
   * @schema KafkaSpecTopicOperatorLogging#name
   */
  readonly name?: string;

  /**
   * Logging type, must be either 'inline' or 'external'.
   *
   * @schema KafkaSpecTopicOperatorLogging#type
   */
  readonly type: KafkaSpecTopicOperatorLoggingType;

}

/**
 * JVM Options for pods.
 *
 * @schema KafkaSpecTopicOperatorJvmOptions
 */
export interface KafkaSpecTopicOperatorJvmOptions {
  /**
   * A map of -XX options to the JVM.
   *
   * @schema KafkaSpecTopicOperatorJvmOptions#-XX
   */
  readonly xx?: any;

  /**
   * -Xms option to to the JVM.
   *
   * @schema KafkaSpecTopicOperatorJvmOptions#-Xms
   */
  readonly xms?: string;

  /**
   * -Xmx option to to the JVM.
   *
   * @schema KafkaSpecTopicOperatorJvmOptions#-Xmx
   */
  readonly xmx?: string;

  /**
   * Specifies whether the Garbage Collection logging is enabled. The default is false.
   *
   * @schema KafkaSpecTopicOperatorJvmOptions#gcLoggingEnabled
   */
  readonly gcLoggingEnabled?: boolean;

  /**
   * A map of additional system properties which will be passed using the `-D` option to the JVM.
   *
   * @schema KafkaSpecTopicOperatorJvmOptions#javaSystemProperties
   */
  readonly javaSystemProperties?: KafkaSpecTopicOperatorJvmOptionsJavaSystemProperties[];

}

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecTopicOperatorLivenessProbe
 */
export interface KafkaSpecTopicOperatorLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecTopicOperatorLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecTopicOperatorLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecTopicOperatorLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecTopicOperatorLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecTopicOperatorLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecTopicOperatorReadinessProbe
 */
export interface KafkaSpecTopicOperatorReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecTopicOperatorReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecTopicOperatorReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecTopicOperatorReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecTopicOperatorReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecTopicOperatorReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Configuration of the Topic Operator.
 *
 * @schema KafkaSpecEntityOperatorTopicOperator
 */
export interface KafkaSpecEntityOperatorTopicOperator {
  /**
   * The namespace the Topic Operator should watch.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#watchedNamespace
   */
  readonly watchedNamespace?: string;

  /**
   * The image to use for the Topic Operator.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#image
   */
  readonly image?: string;

  /**
   * Interval between periodic reconciliations.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#reconciliationIntervalSeconds
   */
  readonly reconciliationIntervalSeconds?: number;

  /**
   * Timeout for the ZooKeeper session.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#zookeeperSessionTimeoutSeconds
   */
  readonly zookeeperSessionTimeoutSeconds?: number;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecEntityOperatorTopicOperatorLivenessProbe;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecEntityOperatorTopicOperatorReadinessProbe;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#resources
   */
  readonly resources?: KafkaSpecEntityOperatorTopicOperatorResources;

  /**
   * The number of attempts at getting topic metadata.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#topicMetadataMaxAttempts
   */
  readonly topicMetadataMaxAttempts?: number;

  /**
   * Logging configuration.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#logging
   */
  readonly logging?: KafkaSpecEntityOperatorTopicOperatorLogging;

  /**
   * JVM Options for pods.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#jvmOptions
   */
  readonly jvmOptions?: KafkaSpecEntityOperatorTopicOperatorJvmOptions;

}

/**
 * Configuration of the User Operator.
 *
 * @schema KafkaSpecEntityOperatorUserOperator
 */
export interface KafkaSpecEntityOperatorUserOperator {
  /**
   * The namespace the User Operator should watch.
   *
   * @schema KafkaSpecEntityOperatorUserOperator#watchedNamespace
   */
  readonly watchedNamespace?: string;

  /**
   * The image to use for the User Operator.
   *
   * @schema KafkaSpecEntityOperatorUserOperator#image
   */
  readonly image?: string;

  /**
   * Interval between periodic reconciliations.
   *
   * @schema KafkaSpecEntityOperatorUserOperator#reconciliationIntervalSeconds
   */
  readonly reconciliationIntervalSeconds?: number;

  /**
   * Timeout for the ZooKeeper session.
   *
   * @schema KafkaSpecEntityOperatorUserOperator#zookeeperSessionTimeoutSeconds
   */
  readonly zookeeperSessionTimeoutSeconds?: number;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaSpecEntityOperatorUserOperator#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecEntityOperatorUserOperatorLivenessProbe;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaSpecEntityOperatorUserOperator#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecEntityOperatorUserOperatorReadinessProbe;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecEntityOperatorUserOperator#resources
   */
  readonly resources?: KafkaSpecEntityOperatorUserOperatorResources;

  /**
   * Logging configuration.
   *
   * @schema KafkaSpecEntityOperatorUserOperator#logging
   */
  readonly logging?: KafkaSpecEntityOperatorUserOperatorLogging;

  /**
   * JVM Options for pods.
   *
   * @schema KafkaSpecEntityOperatorUserOperator#jvmOptions
   */
  readonly jvmOptions?: KafkaSpecEntityOperatorUserOperatorJvmOptions;

}

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecEntityOperatorAffinity
 */
export interface KafkaSpecEntityOperatorAffinity {
  /**
   * @schema KafkaSpecEntityOperatorAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaSpecEntityOperatorAffinityNodeAffinity;

  /**
   * @schema KafkaSpecEntityOperatorAffinity#podAffinity
   */
  readonly podAffinity?: KafkaSpecEntityOperatorAffinityPodAffinity;

  /**
   * @schema KafkaSpecEntityOperatorAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaSpecEntityOperatorAffinityPodAntiAffinity;

}

/**
 * @schema KafkaSpecEntityOperatorTolerations
 */
export interface KafkaSpecEntityOperatorTolerations {
  /**
   * @schema KafkaSpecEntityOperatorTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaSpecEntityOperatorTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaSpecEntityOperatorTolerations#value
   */
  readonly value?: string;

}

/**
 * TLS sidecar configuration.
 *
 * @schema KafkaSpecEntityOperatorTlsSidecar
 */
export interface KafkaSpecEntityOperatorTlsSidecar {
  /**
   * The docker image for the container.
   *
   * @schema KafkaSpecEntityOperatorTlsSidecar#image
   */
  readonly image?: string;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaSpecEntityOperatorTlsSidecar#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecEntityOperatorTlsSidecarLivenessProbe;

  /**
   * The log level for the TLS sidecar. Default value is `notice`.
   *
   * @schema KafkaSpecEntityOperatorTlsSidecar#logLevel
   */
  readonly logLevel?: KafkaSpecEntityOperatorTlsSidecarLogLevel;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaSpecEntityOperatorTlsSidecar#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecEntityOperatorTlsSidecarReadinessProbe;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecEntityOperatorTlsSidecar#resources
   */
  readonly resources?: KafkaSpecEntityOperatorTlsSidecarResources;

}

/**
 * Template for Entity Operator resources. The template allows users to specify how is the `Deployment` and `Pods` generated.
 *
 * @schema KafkaSpecEntityOperatorTemplate
 */
export interface KafkaSpecEntityOperatorTemplate {
  /**
   * Template for Entity Operator `Deployment`.
   *
   * @schema KafkaSpecEntityOperatorTemplate#deployment
   */
  readonly deployment?: KafkaSpecEntityOperatorTemplateDeployment;

  /**
   * Template for Entity Operator `Pods`.
   *
   * @schema KafkaSpecEntityOperatorTemplate#pod
   */
  readonly pod?: KafkaSpecEntityOperatorTemplatePod;

  /**
   * Template for the Entity Operator TLS sidecar container.
   *
   * @schema KafkaSpecEntityOperatorTemplate#tlsSidecarContainer
   */
  readonly tlsSidecarContainer?: KafkaSpecEntityOperatorTemplateTlsSidecarContainer;

  /**
   * Template for the Entity Topic Operator container.
   *
   * @schema KafkaSpecEntityOperatorTemplate#topicOperatorContainer
   */
  readonly topicOperatorContainer?: KafkaSpecEntityOperatorTemplateTopicOperatorContainer;

  /**
   * Template for the Entity User Operator container.
   *
   * @schema KafkaSpecEntityOperatorTemplate#userOperatorContainer
   */
  readonly userOperatorContainer?: KafkaSpecEntityOperatorTemplateUserOperatorContainer;

}

/**
 * How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.
 *
 * @schema KafkaSpecClusterCaCertificateExpirationPolicy
 */
export enum KafkaSpecClusterCaCertificateExpirationPolicy {
  /** renew-certificate */
  RENEW_CERTIFICATE = "renew-certificate",
  /** replace-key */
  REPLACE_KEY = "replace-key",
}

/**
 * How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.
 *
 * @schema KafkaSpecClientsCaCertificateExpirationPolicy
 */
export enum KafkaSpecClientsCaCertificateExpirationPolicy {
  /** renew-certificate */
  RENEW_CERTIFICATE = "renew-certificate",
  /** replace-key */
  REPLACE_KEY = "replace-key",
}

/**
 * TLS sidecar configuration.
 *
 * @schema KafkaSpecCruiseControlTlsSidecar
 */
export interface KafkaSpecCruiseControlTlsSidecar {
  /**
   * The docker image for the container.
   *
   * @schema KafkaSpecCruiseControlTlsSidecar#image
   */
  readonly image?: string;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaSpecCruiseControlTlsSidecar#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecCruiseControlTlsSidecarLivenessProbe;

  /**
   * The log level for the TLS sidecar. Default value is `notice`.
   *
   * @schema KafkaSpecCruiseControlTlsSidecar#logLevel
   */
  readonly logLevel?: KafkaSpecCruiseControlTlsSidecarLogLevel;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaSpecCruiseControlTlsSidecar#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecCruiseControlTlsSidecarReadinessProbe;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecCruiseControlTlsSidecar#resources
   */
  readonly resources?: KafkaSpecCruiseControlTlsSidecarResources;

}

/**
 * CPU and memory resources to reserve for the Cruise Control container.
 *
 * @schema KafkaSpecCruiseControlResources
 */
export interface KafkaSpecCruiseControlResources {
  /**
   * @schema KafkaSpecCruiseControlResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecCruiseControlResources#requests
   */
  readonly requests?: any;

}

/**
 * Pod liveness checking for the Cruise Control container.
 *
 * @schema KafkaSpecCruiseControlLivenessProbe
 */
export interface KafkaSpecCruiseControlLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecCruiseControlLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecCruiseControlLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecCruiseControlLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecCruiseControlLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecCruiseControlLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Pod readiness checking for the Cruise Control container.
 *
 * @schema KafkaSpecCruiseControlReadinessProbe
 */
export interface KafkaSpecCruiseControlReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecCruiseControlReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecCruiseControlReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecCruiseControlReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecCruiseControlReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecCruiseControlReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * JVM Options for the Cruise Control container.
 *
 * @schema KafkaSpecCruiseControlJvmOptions
 */
export interface KafkaSpecCruiseControlJvmOptions {
  /**
   * A map of -XX options to the JVM.
   *
   * @schema KafkaSpecCruiseControlJvmOptions#-XX
   */
  readonly xx?: any;

  /**
   * -Xms option to to the JVM.
   *
   * @schema KafkaSpecCruiseControlJvmOptions#-Xms
   */
  readonly xms?: string;

  /**
   * -Xmx option to to the JVM.
   *
   * @schema KafkaSpecCruiseControlJvmOptions#-Xmx
   */
  readonly xmx?: string;

  /**
   * Specifies whether the Garbage Collection logging is enabled. The default is false.
   *
   * @schema KafkaSpecCruiseControlJvmOptions#gcLoggingEnabled
   */
  readonly gcLoggingEnabled?: boolean;

  /**
   * A map of additional system properties which will be passed using the `-D` option to the JVM.
   *
   * @schema KafkaSpecCruiseControlJvmOptions#javaSystemProperties
   */
  readonly javaSystemProperties?: KafkaSpecCruiseControlJvmOptionsJavaSystemProperties[];

}

/**
 * Logging configuration (log4j1) for Cruise Control.
 *
 * @schema KafkaSpecCruiseControlLogging
 */
export interface KafkaSpecCruiseControlLogging {
  /**
   * A Map from logger name to logger level.
   *
   * @schema KafkaSpecCruiseControlLogging#loggers
   */
  readonly loggers?: any;

  /**
   * The name of the `ConfigMap` from which to get the logging configuration.
   *
   * @schema KafkaSpecCruiseControlLogging#name
   */
  readonly name?: string;

  /**
   * Logging type, must be either 'inline' or 'external'.
   *
   * @schema KafkaSpecCruiseControlLogging#type
   */
  readonly type: KafkaSpecCruiseControlLoggingType;

}

/**
 * Template to specify how Cruise Control resources, `Deployments` and `Pods`, are generated.
 *
 * @schema KafkaSpecCruiseControlTemplate
 */
export interface KafkaSpecCruiseControlTemplate {
  /**
   * Template for Cruise Control `Deployment`.
   *
   * @schema KafkaSpecCruiseControlTemplate#deployment
   */
  readonly deployment?: KafkaSpecCruiseControlTemplateDeployment;

  /**
   * Template for Cruise Control `Pods`.
   *
   * @schema KafkaSpecCruiseControlTemplate#pod
   */
  readonly pod?: KafkaSpecCruiseControlTemplatePod;

  /**
   * Template for Cruise Control API `Service`.
   *
   * @schema KafkaSpecCruiseControlTemplate#apiService
   */
  readonly apiService?: KafkaSpecCruiseControlTemplateApiService;

  /**
   * Template for Cruise Control `PodDisruptionBudget`.
   *
   * @schema KafkaSpecCruiseControlTemplate#podDisruptionBudget
   */
  readonly podDisruptionBudget?: KafkaSpecCruiseControlTemplatePodDisruptionBudget;

  /**
   * Template for the Cruise Control container.
   *
   * @schema KafkaSpecCruiseControlTemplate#cruiseControlContainer
   */
  readonly cruiseControlContainer?: KafkaSpecCruiseControlTemplateCruiseControlContainer;

  /**
   * Template for the Cruise Control TLS sidecar container.
   *
   * @schema KafkaSpecCruiseControlTemplate#tlsSidecarContainer
   */
  readonly tlsSidecarContainer?: KafkaSpecCruiseControlTemplateTlsSidecarContainer;

}

/**
 * The Cruise Control `brokerCapacity` configuration.
 *
 * @schema KafkaSpecCruiseControlBrokerCapacity
 */
export interface KafkaSpecCruiseControlBrokerCapacity {
  /**
   * Broker capacity for disk in bytes, for example, 100Gi.
   *
   * @schema KafkaSpecCruiseControlBrokerCapacity#disk
   */
  readonly disk?: string;

  /**
   * Broker capacity for CPU resource utilization as a percentage (0 - 100).
   *
   * @schema KafkaSpecCruiseControlBrokerCapacity#cpuUtilization
   */
  readonly cpuUtilization?: number;

  /**
   * Broker capacity for inbound network throughput in bytes per second, for example, 10000KB/s.
   *
   * @schema KafkaSpecCruiseControlBrokerCapacity#inboundNetwork
   */
  readonly inboundNetwork?: string;

  /**
   * Broker capacity for outbound network throughput in bytes per second, for example 10000KB/s.
   *
   * @schema KafkaSpecCruiseControlBrokerCapacity#outboundNetwork
   */
  readonly outboundNetwork?: string;

}

/**
 * @schema KafkaSpecJmxTransOutputDefinitions
 */
export interface KafkaSpecJmxTransOutputDefinitions {
  /**
   * Template for setting the format of the data that will be pushed.For more information see https://github.com/jmxtrans/jmxtrans/wiki/OutputWriters[JmxTrans OutputWriters].
   *
   * @schema KafkaSpecJmxTransOutputDefinitions#outputType
   */
  readonly outputType: string;

  /**
   * The DNS/hostname of the remote host that the data is pushed to.
   *
   * @schema KafkaSpecJmxTransOutputDefinitions#host
   */
  readonly host?: string;

  /**
   * The port of the remote host that the data is pushed to.
   *
   * @schema KafkaSpecJmxTransOutputDefinitions#port
   */
  readonly port?: number;

  /**
   * How many seconds the JmxTrans waits before pushing a new set of data out.
   *
   * @schema KafkaSpecJmxTransOutputDefinitions#flushDelayInSeconds
   */
  readonly flushDelayInSeconds?: number;

  /**
   * Template for filtering data to be included in response to a wildcard query. For more information see https://github.com/jmxtrans/jmxtrans/wiki/Queries[JmxTrans queries].
   *
   * @schema KafkaSpecJmxTransOutputDefinitions#typeNames
   */
  readonly typeNames?: string[];

  /**
   * Template for setting the name of the output definition. This is used to identify where to send the results of queries should be sent.
   *
   * @schema KafkaSpecJmxTransOutputDefinitions#name
   */
  readonly name: string;

}

/**
 * @schema KafkaSpecJmxTransKafkaQueries
 */
export interface KafkaSpecJmxTransKafkaQueries {
  /**
   * If using wildcards instead of a specific MBean then the data is gathered from multiple MBeans. Otherwise if specifying an MBean then data is gathered from that specified MBean.
   *
   * @schema KafkaSpecJmxTransKafkaQueries#targetMBean
   */
  readonly targetMBean: string;

  /**
   * Determine which attributes of the targeted MBean should be included.
   *
   * @schema KafkaSpecJmxTransKafkaQueries#attributes
   */
  readonly attributes: string[];

  /**
   * List of the names of output definitions specified in the spec.kafka.jmxTrans.outputDefinitions that have defined where JMX metrics are pushed to, and in which data format.
   *
   * @schema KafkaSpecJmxTransKafkaQueries#outputs
   */
  readonly outputs: string[];

}

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecJmxTransResources
 */
export interface KafkaSpecJmxTransResources {
  /**
   * @schema KafkaSpecJmxTransResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecJmxTransResources#requests
   */
  readonly requests?: any;

}

/**
 * Template for JmxTrans resources.
 *
 * @schema KafkaSpecJmxTransTemplate
 */
export interface KafkaSpecJmxTransTemplate {
  /**
   * Template for JmxTrans `Deployment`.
   *
   * @schema KafkaSpecJmxTransTemplate#deployment
   */
  readonly deployment?: KafkaSpecJmxTransTemplateDeployment;

  /**
   * Template for JmxTrans `Pods`.
   *
   * @schema KafkaSpecJmxTransTemplate#pod
   */
  readonly pod?: KafkaSpecJmxTransTemplatePod;

  /**
   * Template for JmxTrans container.
   *
   * @schema KafkaSpecJmxTransTemplate#container
   */
  readonly container?: KafkaSpecJmxTransTemplateContainer;

}

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecKafkaExporterResources
 */
export interface KafkaSpecKafkaExporterResources {
  /**
   * @schema KafkaSpecKafkaExporterResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecKafkaExporterResources#requests
   */
  readonly requests?: any;

}

/**
 * Customization of deployment templates and pods.
 *
 * @schema KafkaSpecKafkaExporterTemplate
 */
export interface KafkaSpecKafkaExporterTemplate {
  /**
   * Template for Kafka Exporter `Deployment`.
   *
   * @schema KafkaSpecKafkaExporterTemplate#deployment
   */
  readonly deployment?: KafkaSpecKafkaExporterTemplateDeployment;

  /**
   * Template for Kafka Exporter `Pods`.
   *
   * @schema KafkaSpecKafkaExporterTemplate#pod
   */
  readonly pod?: KafkaSpecKafkaExporterTemplatePod;

  /**
   * Template for Kafka Exporter `Service`.
   *
   * @schema KafkaSpecKafkaExporterTemplate#service
   */
  readonly service?: KafkaSpecKafkaExporterTemplateService;

  /**
   * Template for the Kafka Exporter container.
   *
   * @schema KafkaSpecKafkaExporterTemplate#container
   */
  readonly container?: KafkaSpecKafkaExporterTemplateContainer;

}

/**
 * Pod liveness check.
 *
 * @schema KafkaSpecKafkaExporterLivenessProbe
 */
export interface KafkaSpecKafkaExporterLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecKafkaExporterLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecKafkaExporterLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecKafkaExporterLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecKafkaExporterLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecKafkaExporterLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Pod readiness check.
 *
 * @schema KafkaSpecKafkaExporterReadinessProbe
 */
export interface KafkaSpecKafkaExporterReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecKafkaExporterReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecKafkaExporterReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecKafkaExporterReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecKafkaExporterReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecKafkaExporterReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * @schema KafkaSpecKafkaStorageOverrides
 */
export interface KafkaSpecKafkaStorageOverrides {
  /**
   * The storage class to use for dynamic volume allocation for this broker.
   *
   * @schema KafkaSpecKafkaStorageOverrides#class
   */
  readonly class?: string;

  /**
   * Id of the kafka broker (broker identifier).
   *
   * @schema KafkaSpecKafkaStorageOverrides#broker
   */
  readonly broker?: number;

}

/**
 * Storage type, must be either 'ephemeral', 'persistent-claim', or 'jbod'.
 *
 * @schema KafkaSpecKafkaStorageType
 */
export enum KafkaSpecKafkaStorageType {
  /** ephemeral */
  EPHEMERAL = "ephemeral",
  /** persistent-claim */
  PERSISTENT_CLAIM = "persistent-claim",
  /** jbod */
  JBOD = "jbod",
}

/**
 * @schema KafkaSpecKafkaStorageVolumes
 */
export interface KafkaSpecKafkaStorageVolumes {
  /**
   * The storage class to use for dynamic volume allocation.
   *
   * @schema KafkaSpecKafkaStorageVolumes#class
   */
  readonly class?: string;

  /**
   * Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
   *
   * @schema KafkaSpecKafkaStorageVolumes#deleteClaim
   */
  readonly deleteClaim?: boolean;

  /**
   * Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
   *
   * @schema KafkaSpecKafkaStorageVolumes#id
   */
  readonly id?: number;

  /**
   * Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
   *
   * @schema KafkaSpecKafkaStorageVolumes#overrides
   */
  readonly overrides?: KafkaSpecKafkaStorageVolumesOverrides[];

  /**
   * Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
   *
   * @schema KafkaSpecKafkaStorageVolumes#selector
   */
  readonly selector?: any;

  /**
   * When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
   *
   * @schema KafkaSpecKafkaStorageVolumes#size
   */
  readonly size?: string;

  /**
   * When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
   *
   * @schema KafkaSpecKafkaStorageVolumes#sizeLimit
   */
  readonly sizeLimit?: string;

  /**
   * Storage type, must be either 'ephemeral' or 'persistent-claim'.
   *
   * @schema KafkaSpecKafkaStorageVolumes#type
   */
  readonly type: KafkaSpecKafkaStorageVolumesType;

}

/**
 * @schema KafkaSpecKafkaAuthorizationTlsTrustedCertificates
 */
export interface KafkaSpecKafkaAuthorizationTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaSpecKafkaAuthorizationTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaSpecKafkaAuthorizationTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * Authorization type. Currently, the supported types are `simple`, `keycloak`, and `opa`. `simple` authorization type uses Kafka's `kafka.security.authorizer.AclAuthorizer` class for authorization. `keycloak` authorization type uses Keycloak Authorization Services for authorization. `opa` authorization type uses Open Policy Agent based authorization.
 *
 * @schema KafkaSpecKafkaAuthorizationType
 */
export enum KafkaSpecKafkaAuthorizationType {
  /** simple */
  SIMPLE = "simple",
  /** opa */
  OPA = "opa",
  /** keycloak */
  KEYCLOAK = "keycloak",
}

/**
 * @schema KafkaSpecKafkaAffinityNodeAffinity
 */
export interface KafkaSpecKafkaAffinityNodeAffinity {
  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaSpecKafkaAffinityPodAffinity
 */
export interface KafkaSpecKafkaAffinityPodAffinity {
  /**
   * @schema KafkaSpecKafkaAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecKafkaAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecKafkaAffinityPodAntiAffinity
 */
export interface KafkaSpecKafkaAffinityPodAntiAffinity {
  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecKafkaJvmOptionsJavaSystemProperties
 */
export interface KafkaSpecKafkaJvmOptionsJavaSystemProperties {
  /**
   * The system property name.
   *
   * @schema KafkaSpecKafkaJvmOptionsJavaSystemProperties#name
   */
  readonly name?: string;

  /**
   * The system property value.
   *
   * @schema KafkaSpecKafkaJvmOptionsJavaSystemProperties#value
   */
  readonly value?: string;

}

/**
 * Authentication configuration for connecting to the Kafka JMX port.
 *
 * @schema KafkaSpecKafkaJmxOptionsAuthentication
 */
export interface KafkaSpecKafkaJmxOptionsAuthentication {
  /**
   * Authentication type. Currently the only supported types are `password`.`password` type creates a username and protected port with no TLS.
   *
   * @schema KafkaSpecKafkaJmxOptionsAuthentication#type
   */
  readonly type: KafkaSpecKafkaJmxOptionsAuthenticationType;

}

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaSpecKafkaLoggingType
 */
export enum KafkaSpecKafkaLoggingType {
  /** inline */
  INLINE = "inline",
  /** external */
  EXTERNAL = "external",
}

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecKafkaTlsSidecarLivenessProbe
 */
export interface KafkaSpecKafkaTlsSidecarLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecKafkaTlsSidecarLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecKafkaTlsSidecarLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecKafkaTlsSidecarLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecKafkaTlsSidecarLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecKafkaTlsSidecarLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * The log level for the TLS sidecar. Default value is `notice`.
 *
 * @schema KafkaSpecKafkaTlsSidecarLogLevel
 */
export enum KafkaSpecKafkaTlsSidecarLogLevel {
  /** emerg */
  EMERG = "emerg",
  /** alert */
  ALERT = "alert",
  /** crit */
  CRIT = "crit",
  /** err */
  ERR = "err",
  /** warning */
  WARNING = "warning",
  /** notice */
  NOTICE = "notice",
  /** info */
  INFO = "info",
  /** debug */
  DEBUG = "debug",
}

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecKafkaTlsSidecarReadinessProbe
 */
export interface KafkaSpecKafkaTlsSidecarReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecKafkaTlsSidecarReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecKafkaTlsSidecarReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecKafkaTlsSidecarReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecKafkaTlsSidecarReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecKafkaTlsSidecarReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecKafkaTlsSidecarResources
 */
export interface KafkaSpecKafkaTlsSidecarResources {
  /**
   * @schema KafkaSpecKafkaTlsSidecarResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecKafkaTlsSidecarResources#requests
   */
  readonly requests?: any;

}

/**
 * Template for Kafka `StatefulSet`.
 *
 * @schema KafkaSpecKafkaTemplateStatefulset
 */
export interface KafkaSpecKafkaTemplateStatefulset {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplateStatefulset#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplateStatefulsetMetadata;

  /**
   * PodManagementPolicy which will be used for this StatefulSet. Valid values are `Parallel` and `OrderedReady`. Defaults to `Parallel`.
   *
   * @default Parallel`.
   * @schema KafkaSpecKafkaTemplateStatefulset#podManagementPolicy
   */
  readonly podManagementPolicy?: KafkaSpecKafkaTemplateStatefulsetPodManagementPolicy;

}

/**
 * Template for Kafka `Pods`.
 *
 * @schema KafkaSpecKafkaTemplatePod
 */
export interface KafkaSpecKafkaTemplatePod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplatePod#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplatePodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaSpecKafkaTemplatePod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaSpecKafkaTemplatePodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaSpecKafkaTemplatePod#securityContext
   */
  readonly securityContext?: KafkaSpecKafkaTemplatePodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaSpecKafkaTemplatePod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaSpecKafkaTemplatePod#affinity
   */
  readonly affinity?: KafkaSpecKafkaTemplatePodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaSpecKafkaTemplatePod#tolerations
   */
  readonly tolerations?: KafkaSpecKafkaTemplatePodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaSpecKafkaTemplatePod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaSpecKafkaTemplatePod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
   *
   * @schema KafkaSpecKafkaTemplatePod#hostAliases
   */
  readonly hostAliases?: KafkaSpecKafkaTemplatePodHostAliases[];

}

/**
 * Template for Kafka bootstrap `Service`.
 *
 * @schema KafkaSpecKafkaTemplateBootstrapService
 */
export interface KafkaSpecKafkaTemplateBootstrapService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplateBootstrapService#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplateBootstrapServiceMetadata;

}

/**
 * Template for Kafka broker `Service`.
 *
 * @schema KafkaSpecKafkaTemplateBrokersService
 */
export interface KafkaSpecKafkaTemplateBrokersService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplateBrokersService#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplateBrokersServiceMetadata;

}

/**
 * Template for Kafka external bootstrap `Service`.
 *
 * @schema KafkaSpecKafkaTemplateExternalBootstrapService
 */
export interface KafkaSpecKafkaTemplateExternalBootstrapService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapService#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata;

  /**
   * Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. `Cluster` may cause a second hop to another node and obscures the client source IP. `Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). If unspecified, Kubernetes will use `Cluster` as the default.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapService#externalTrafficPolicy
   */
  readonly externalTrafficPolicy?: KafkaSpecKafkaTemplateExternalBootstrapServiceExternalTrafficPolicy;

  /**
   * A list of CIDR ranges (for example `10.0.0.0/8` or `130.211.204.1/32`) from which clients can connect to load balancer type listeners. If supported by the platform, traffic through the loadbalancer is restricted to the specified CIDR ranges. This field is applicable only for loadbalancer type services and is ignored if the cloud provider does not support the feature. For more information, see https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapService#loadBalancerSourceRanges
   */
  readonly loadBalancerSourceRanges?: string[];

}

/**
 * Template for Kafka per-pod `Services` used for access from outside of Kubernetes.
 *
 * @schema KafkaSpecKafkaTemplatePerPodService
 */
export interface KafkaSpecKafkaTemplatePerPodService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplatePerPodService#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplatePerPodServiceMetadata;

  /**
   * Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. `Cluster` may cause a second hop to another node and obscures the client source IP. `Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). If unspecified, Kubernetes will use `Cluster` as the default.
   *
   * @schema KafkaSpecKafkaTemplatePerPodService#externalTrafficPolicy
   */
  readonly externalTrafficPolicy?: KafkaSpecKafkaTemplatePerPodServiceExternalTrafficPolicy;

  /**
   * A list of CIDR ranges (for example `10.0.0.0/8` or `130.211.204.1/32`) from which clients can connect to load balancer type listeners. If supported by the platform, traffic through the loadbalancer is restricted to the specified CIDR ranges. This field is applicable only for loadbalancer type services and is ignored if the cloud provider does not support the feature. For more information, see https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/.
   *
   * @schema KafkaSpecKafkaTemplatePerPodService#loadBalancerSourceRanges
   */
  readonly loadBalancerSourceRanges?: string[];

}

/**
 * Template for Kafka external bootstrap `Route`.
 *
 * @schema KafkaSpecKafkaTemplateExternalBootstrapRoute
 */
export interface KafkaSpecKafkaTemplateExternalBootstrapRoute {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapRoute#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata;

}

/**
 * Template for Kafka per-pod `Routes` used for access from outside of OpenShift.
 *
 * @schema KafkaSpecKafkaTemplatePerPodRoute
 */
export interface KafkaSpecKafkaTemplatePerPodRoute {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplatePerPodRoute#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplatePerPodRouteMetadata;

}

/**
 * Template for Kafka external bootstrap `Ingress`.
 *
 * @schema KafkaSpecKafkaTemplateExternalBootstrapIngress
 */
export interface KafkaSpecKafkaTemplateExternalBootstrapIngress {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapIngress#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata;

}

/**
 * Template for Kafka per-pod `Ingress` used for access from outside of Kubernetes.
 *
 * @schema KafkaSpecKafkaTemplatePerPodIngress
 */
export interface KafkaSpecKafkaTemplatePerPodIngress {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplatePerPodIngress#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplatePerPodIngressMetadata;

}

/**
 * Template for all Kafka `PersistentVolumeClaims`.
 *
 * @schema KafkaSpecKafkaTemplatePersistentVolumeClaim
 */
export interface KafkaSpecKafkaTemplatePersistentVolumeClaim {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplatePersistentVolumeClaim#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata;

}

/**
 * Template for Kafka `PodDisruptionBudget`.
 *
 * @schema KafkaSpecKafkaTemplatePodDisruptionBudget
 */
export interface KafkaSpecKafkaTemplatePodDisruptionBudget {
  /**
   * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
   *
   * @schema KafkaSpecKafkaTemplatePodDisruptionBudget#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata;

  /**
   * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
   *
   * @default 1.
   * @schema KafkaSpecKafkaTemplatePodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: number;

}

/**
 * Template for the Kafka broker container.
 *
 * @schema KafkaSpecKafkaTemplateKafkaContainer
 */
export interface KafkaSpecKafkaTemplateKafkaContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecKafkaTemplateKafkaContainer#env
   */
  readonly env?: KafkaSpecKafkaTemplateKafkaContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecKafkaTemplateKafkaContainer#securityContext
   */
  readonly securityContext?: KafkaSpecKafkaTemplateKafkaContainerSecurityContext;

}

/**
 * Template for the Kafka broker TLS sidecar container.
 *
 * @schema KafkaSpecKafkaTemplateTlsSidecarContainer
 */
export interface KafkaSpecKafkaTemplateTlsSidecarContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainer#env
   */
  readonly env?: KafkaSpecKafkaTemplateTlsSidecarContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainer#securityContext
   */
  readonly securityContext?: KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext;

}

/**
 * Template for the Kafka init container.
 *
 * @schema KafkaSpecKafkaTemplateInitContainer
 */
export interface KafkaSpecKafkaTemplateInitContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecKafkaTemplateInitContainer#env
   */
  readonly env?: KafkaSpecKafkaTemplateInitContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecKafkaTemplateInitContainer#securityContext
   */
  readonly securityContext?: KafkaSpecKafkaTemplateInitContainerSecurityContext;

}

/**
 * @schema KafkaSpecZookeeperStorageOverrides
 */
export interface KafkaSpecZookeeperStorageOverrides {
  /**
   * The storage class to use for dynamic volume allocation for this broker.
   *
   * @schema KafkaSpecZookeeperStorageOverrides#class
   */
  readonly class?: string;

  /**
   * Id of the kafka broker (broker identifier).
   *
   * @schema KafkaSpecZookeeperStorageOverrides#broker
   */
  readonly broker?: number;

}

/**
 * Storage type, must be either 'ephemeral' or 'persistent-claim'.
 *
 * @schema KafkaSpecZookeeperStorageType
 */
export enum KafkaSpecZookeeperStorageType {
  /** ephemeral */
  EPHEMERAL = "ephemeral",
  /** persistent-claim */
  PERSISTENT_CLAIM = "persistent-claim",
}

/**
 * @schema KafkaSpecZookeeperAffinityNodeAffinity
 */
export interface KafkaSpecZookeeperAffinityNodeAffinity {
  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAffinity
 */
export interface KafkaSpecZookeeperAffinityPodAffinity {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAntiAffinity
 */
export interface KafkaSpecZookeeperAffinityPodAntiAffinity {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecZookeeperJvmOptionsJavaSystemProperties
 */
export interface KafkaSpecZookeeperJvmOptionsJavaSystemProperties {
  /**
   * The system property name.
   *
   * @schema KafkaSpecZookeeperJvmOptionsJavaSystemProperties#name
   */
  readonly name?: string;

  /**
   * The system property value.
   *
   * @schema KafkaSpecZookeeperJvmOptionsJavaSystemProperties#value
   */
  readonly value?: string;

}

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaSpecZookeeperLoggingType
 */
export enum KafkaSpecZookeeperLoggingType {
  /** inline */
  INLINE = "inline",
  /** external */
  EXTERNAL = "external",
}

/**
 * Template for ZooKeeper `StatefulSet`.
 *
 * @schema KafkaSpecZookeeperTemplateStatefulset
 */
export interface KafkaSpecZookeeperTemplateStatefulset {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecZookeeperTemplateStatefulset#metadata
   */
  readonly metadata?: KafkaSpecZookeeperTemplateStatefulsetMetadata;

  /**
   * PodManagementPolicy which will be used for this StatefulSet. Valid values are `Parallel` and `OrderedReady`. Defaults to `Parallel`.
   *
   * @default Parallel`.
   * @schema KafkaSpecZookeeperTemplateStatefulset#podManagementPolicy
   */
  readonly podManagementPolicy?: KafkaSpecZookeeperTemplateStatefulsetPodManagementPolicy;

}

/**
 * Template for ZooKeeper `Pods`.
 *
 * @schema KafkaSpecZookeeperTemplatePod
 */
export interface KafkaSpecZookeeperTemplatePod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecZookeeperTemplatePod#metadata
   */
  readonly metadata?: KafkaSpecZookeeperTemplatePodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaSpecZookeeperTemplatePod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaSpecZookeeperTemplatePodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaSpecZookeeperTemplatePod#securityContext
   */
  readonly securityContext?: KafkaSpecZookeeperTemplatePodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaSpecZookeeperTemplatePod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaSpecZookeeperTemplatePod#affinity
   */
  readonly affinity?: KafkaSpecZookeeperTemplatePodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaSpecZookeeperTemplatePod#tolerations
   */
  readonly tolerations?: KafkaSpecZookeeperTemplatePodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaSpecZookeeperTemplatePod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaSpecZookeeperTemplatePod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
   *
   * @schema KafkaSpecZookeeperTemplatePod#hostAliases
   */
  readonly hostAliases?: KafkaSpecZookeeperTemplatePodHostAliases[];

}

/**
 * Template for ZooKeeper client `Service`.
 *
 * @schema KafkaSpecZookeeperTemplateClientService
 */
export interface KafkaSpecZookeeperTemplateClientService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecZookeeperTemplateClientService#metadata
   */
  readonly metadata?: KafkaSpecZookeeperTemplateClientServiceMetadata;

}

/**
 * Template for ZooKeeper nodes `Service`.
 *
 * @schema KafkaSpecZookeeperTemplateNodesService
 */
export interface KafkaSpecZookeeperTemplateNodesService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecZookeeperTemplateNodesService#metadata
   */
  readonly metadata?: KafkaSpecZookeeperTemplateNodesServiceMetadata;

}

/**
 * Template for all ZooKeeper `PersistentVolumeClaims`.
 *
 * @schema KafkaSpecZookeeperTemplatePersistentVolumeClaim
 */
export interface KafkaSpecZookeeperTemplatePersistentVolumeClaim {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecZookeeperTemplatePersistentVolumeClaim#metadata
   */
  readonly metadata?: KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata;

}

/**
 * Template for ZooKeeper `PodDisruptionBudget`.
 *
 * @schema KafkaSpecZookeeperTemplatePodDisruptionBudget
 */
export interface KafkaSpecZookeeperTemplatePodDisruptionBudget {
  /**
   * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
   *
   * @schema KafkaSpecZookeeperTemplatePodDisruptionBudget#metadata
   */
  readonly metadata?: KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata;

  /**
   * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
   *
   * @default 1.
   * @schema KafkaSpecZookeeperTemplatePodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: number;

}

/**
 * Template for the ZooKeeper container.
 *
 * @schema KafkaSpecZookeeperTemplateZookeeperContainer
 */
export interface KafkaSpecZookeeperTemplateZookeeperContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecZookeeperTemplateZookeeperContainer#env
   */
  readonly env?: KafkaSpecZookeeperTemplateZookeeperContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecZookeeperTemplateZookeeperContainer#securityContext
   */
  readonly securityContext?: KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext;

}

/**
 * Template for the Zookeeper server TLS sidecar container. The TLS sidecar is not used anymore and this option will be ignored.
 *
 * @schema KafkaSpecZookeeperTemplateTlsSidecarContainer
 */
export interface KafkaSpecZookeeperTemplateTlsSidecarContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainer#env
   */
  readonly env?: KafkaSpecZookeeperTemplateTlsSidecarContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainer#securityContext
   */
  readonly securityContext?: KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext;

}

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecZookeeperTlsSidecarLivenessProbe
 */
export interface KafkaSpecZookeeperTlsSidecarLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecZookeeperTlsSidecarLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecZookeeperTlsSidecarLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecZookeeperTlsSidecarLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecZookeeperTlsSidecarLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecZookeeperTlsSidecarLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * The log level for the TLS sidecar. Default value is `notice`.
 *
 * @schema KafkaSpecZookeeperTlsSidecarLogLevel
 */
export enum KafkaSpecZookeeperTlsSidecarLogLevel {
  /** emerg */
  EMERG = "emerg",
  /** alert */
  ALERT = "alert",
  /** crit */
  CRIT = "crit",
  /** err */
  ERR = "err",
  /** warning */
  WARNING = "warning",
  /** notice */
  NOTICE = "notice",
  /** info */
  INFO = "info",
  /** debug */
  DEBUG = "debug",
}

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecZookeeperTlsSidecarReadinessProbe
 */
export interface KafkaSpecZookeeperTlsSidecarReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecZookeeperTlsSidecarReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecZookeeperTlsSidecarReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecZookeeperTlsSidecarReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecZookeeperTlsSidecarReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecZookeeperTlsSidecarReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecZookeeperTlsSidecarResources
 */
export interface KafkaSpecZookeeperTlsSidecarResources {
  /**
   * @schema KafkaSpecZookeeperTlsSidecarResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecZookeeperTlsSidecarResources#requests
   */
  readonly requests?: any;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityNodeAffinity
 */
export interface KafkaSpecTopicOperatorAffinityNodeAffinity {
  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAffinity
 */
export interface KafkaSpecTopicOperatorAffinityPodAffinity {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinity
 */
export interface KafkaSpecTopicOperatorAffinityPodAntiAffinity {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecTopicOperatorTlsSidecarLivenessProbe
 */
export interface KafkaSpecTopicOperatorTlsSidecarLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecTopicOperatorTlsSidecarLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecTopicOperatorTlsSidecarLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecTopicOperatorTlsSidecarLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecTopicOperatorTlsSidecarLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecTopicOperatorTlsSidecarLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * The log level for the TLS sidecar. Default value is `notice`.
 *
 * @schema KafkaSpecTopicOperatorTlsSidecarLogLevel
 */
export enum KafkaSpecTopicOperatorTlsSidecarLogLevel {
  /** emerg */
  EMERG = "emerg",
  /** alert */
  ALERT = "alert",
  /** crit */
  CRIT = "crit",
  /** err */
  ERR = "err",
  /** warning */
  WARNING = "warning",
  /** notice */
  NOTICE = "notice",
  /** info */
  INFO = "info",
  /** debug */
  DEBUG = "debug",
}

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecTopicOperatorTlsSidecarReadinessProbe
 */
export interface KafkaSpecTopicOperatorTlsSidecarReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecTopicOperatorTlsSidecarReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecTopicOperatorTlsSidecarReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecTopicOperatorTlsSidecarReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecTopicOperatorTlsSidecarReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecTopicOperatorTlsSidecarReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecTopicOperatorTlsSidecarResources
 */
export interface KafkaSpecTopicOperatorTlsSidecarResources {
  /**
   * @schema KafkaSpecTopicOperatorTlsSidecarResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecTopicOperatorTlsSidecarResources#requests
   */
  readonly requests?: any;

}

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaSpecTopicOperatorLoggingType
 */
export enum KafkaSpecTopicOperatorLoggingType {
  /** inline */
  INLINE = "inline",
  /** external */
  EXTERNAL = "external",
}

/**
 * @schema KafkaSpecTopicOperatorJvmOptionsJavaSystemProperties
 */
export interface KafkaSpecTopicOperatorJvmOptionsJavaSystemProperties {
  /**
   * The system property name.
   *
   * @schema KafkaSpecTopicOperatorJvmOptionsJavaSystemProperties#name
   */
  readonly name?: string;

  /**
   * The system property value.
   *
   * @schema KafkaSpecTopicOperatorJvmOptionsJavaSystemProperties#value
   */
  readonly value?: string;

}

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorLivenessProbe
 */
export interface KafkaSpecEntityOperatorTopicOperatorLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTopicOperatorLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTopicOperatorLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTopicOperatorLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorReadinessProbe
 */
export interface KafkaSpecEntityOperatorTopicOperatorReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTopicOperatorReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTopicOperatorReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTopicOperatorReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorResources
 */
export interface KafkaSpecEntityOperatorTopicOperatorResources {
  /**
   * @schema KafkaSpecEntityOperatorTopicOperatorResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecEntityOperatorTopicOperatorResources#requests
   */
  readonly requests?: any;

}

/**
 * Logging configuration.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorLogging
 */
export interface KafkaSpecEntityOperatorTopicOperatorLogging {
  /**
   * A Map from logger name to logger level.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorLogging#loggers
   */
  readonly loggers?: any;

  /**
   * The name of the `ConfigMap` from which to get the logging configuration.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorLogging#name
   */
  readonly name?: string;

  /**
   * Logging type, must be either 'inline' or 'external'.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorLogging#type
   */
  readonly type: KafkaSpecEntityOperatorTopicOperatorLoggingType;

}

/**
 * JVM Options for pods.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptions
 */
export interface KafkaSpecEntityOperatorTopicOperatorJvmOptions {
  /**
   * A map of -XX options to the JVM.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptions#-XX
   */
  readonly xx?: any;

  /**
   * -Xms option to to the JVM.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptions#-Xms
   */
  readonly xms?: string;

  /**
   * -Xmx option to to the JVM.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptions#-Xmx
   */
  readonly xmx?: string;

  /**
   * Specifies whether the Garbage Collection logging is enabled. The default is false.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptions#gcLoggingEnabled
   */
  readonly gcLoggingEnabled?: boolean;

  /**
   * A map of additional system properties which will be passed using the `-D` option to the JVM.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptions#javaSystemProperties
   */
  readonly javaSystemProperties?: KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties[];

}

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecEntityOperatorUserOperatorLivenessProbe
 */
export interface KafkaSpecEntityOperatorUserOperatorLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorUserOperatorLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorUserOperatorLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorUserOperatorLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecEntityOperatorUserOperatorReadinessProbe
 */
export interface KafkaSpecEntityOperatorUserOperatorReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorUserOperatorReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorUserOperatorReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorUserOperatorReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecEntityOperatorUserOperatorResources
 */
export interface KafkaSpecEntityOperatorUserOperatorResources {
  /**
   * @schema KafkaSpecEntityOperatorUserOperatorResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecEntityOperatorUserOperatorResources#requests
   */
  readonly requests?: any;

}

/**
 * Logging configuration.
 *
 * @schema KafkaSpecEntityOperatorUserOperatorLogging
 */
export interface KafkaSpecEntityOperatorUserOperatorLogging {
  /**
   * A Map from logger name to logger level.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorLogging#loggers
   */
  readonly loggers?: any;

  /**
   * The name of the `ConfigMap` from which to get the logging configuration.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorLogging#name
   */
  readonly name?: string;

  /**
   * Logging type, must be either 'inline' or 'external'.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorLogging#type
   */
  readonly type: KafkaSpecEntityOperatorUserOperatorLoggingType;

}

/**
 * JVM Options for pods.
 *
 * @schema KafkaSpecEntityOperatorUserOperatorJvmOptions
 */
export interface KafkaSpecEntityOperatorUserOperatorJvmOptions {
  /**
   * A map of -XX options to the JVM.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorJvmOptions#-XX
   */
  readonly xx?: any;

  /**
   * -Xms option to to the JVM.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorJvmOptions#-Xms
   */
  readonly xms?: string;

  /**
   * -Xmx option to to the JVM.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorJvmOptions#-Xmx
   */
  readonly xmx?: string;

  /**
   * Specifies whether the Garbage Collection logging is enabled. The default is false.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorJvmOptions#gcLoggingEnabled
   */
  readonly gcLoggingEnabled?: boolean;

  /**
   * A map of additional system properties which will be passed using the `-D` option to the JVM.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorJvmOptions#javaSystemProperties
   */
  readonly javaSystemProperties?: KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties[];

}

/**
 * @schema KafkaSpecEntityOperatorAffinityNodeAffinity
 */
export interface KafkaSpecEntityOperatorAffinityNodeAffinity {
  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAffinity
 */
export interface KafkaSpecEntityOperatorAffinityPodAffinity {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinity
 */
export interface KafkaSpecEntityOperatorAffinityPodAntiAffinity {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecEntityOperatorTlsSidecarLivenessProbe
 */
export interface KafkaSpecEntityOperatorTlsSidecarLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTlsSidecarLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecEntityOperatorTlsSidecarLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTlsSidecarLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTlsSidecarLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecEntityOperatorTlsSidecarLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * The log level for the TLS sidecar. Default value is `notice`.
 *
 * @schema KafkaSpecEntityOperatorTlsSidecarLogLevel
 */
export enum KafkaSpecEntityOperatorTlsSidecarLogLevel {
  /** emerg */
  EMERG = "emerg",
  /** alert */
  ALERT = "alert",
  /** crit */
  CRIT = "crit",
  /** err */
  ERR = "err",
  /** warning */
  WARNING = "warning",
  /** notice */
  NOTICE = "notice",
  /** info */
  INFO = "info",
  /** debug */
  DEBUG = "debug",
}

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecEntityOperatorTlsSidecarReadinessProbe
 */
export interface KafkaSpecEntityOperatorTlsSidecarReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTlsSidecarReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecEntityOperatorTlsSidecarReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTlsSidecarReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTlsSidecarReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecEntityOperatorTlsSidecarReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecEntityOperatorTlsSidecarResources
 */
export interface KafkaSpecEntityOperatorTlsSidecarResources {
  /**
   * @schema KafkaSpecEntityOperatorTlsSidecarResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecEntityOperatorTlsSidecarResources#requests
   */
  readonly requests?: any;

}

/**
 * Template for Entity Operator `Deployment`.
 *
 * @schema KafkaSpecEntityOperatorTemplateDeployment
 */
export interface KafkaSpecEntityOperatorTemplateDeployment {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecEntityOperatorTemplateDeployment#metadata
   */
  readonly metadata?: KafkaSpecEntityOperatorTemplateDeploymentMetadata;

}

/**
 * Template for Entity Operator `Pods`.
 *
 * @schema KafkaSpecEntityOperatorTemplatePod
 */
export interface KafkaSpecEntityOperatorTemplatePod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecEntityOperatorTemplatePod#metadata
   */
  readonly metadata?: KafkaSpecEntityOperatorTemplatePodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaSpecEntityOperatorTemplatePod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaSpecEntityOperatorTemplatePodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaSpecEntityOperatorTemplatePod#securityContext
   */
  readonly securityContext?: KafkaSpecEntityOperatorTemplatePodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaSpecEntityOperatorTemplatePod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaSpecEntityOperatorTemplatePod#affinity
   */
  readonly affinity?: KafkaSpecEntityOperatorTemplatePodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaSpecEntityOperatorTemplatePod#tolerations
   */
  readonly tolerations?: KafkaSpecEntityOperatorTemplatePodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaSpecEntityOperatorTemplatePod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaSpecEntityOperatorTemplatePod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
   *
   * @schema KafkaSpecEntityOperatorTemplatePod#hostAliases
   */
  readonly hostAliases?: KafkaSpecEntityOperatorTemplatePodHostAliases[];

}

/**
 * Template for the Entity Operator TLS sidecar container.
 *
 * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainer
 */
export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainer#env
   */
  readonly env?: KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainer#securityContext
   */
  readonly securityContext?: KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext;

}

/**
 * Template for the Entity Topic Operator container.
 *
 * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainer
 */
export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainer#env
   */
  readonly env?: KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainer#securityContext
   */
  readonly securityContext?: KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext;

}

/**
 * Template for the Entity User Operator container.
 *
 * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainer
 */
export interface KafkaSpecEntityOperatorTemplateUserOperatorContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainer#env
   */
  readonly env?: KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainer#securityContext
   */
  readonly securityContext?: KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext;

}

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecCruiseControlTlsSidecarLivenessProbe
 */
export interface KafkaSpecCruiseControlTlsSidecarLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecCruiseControlTlsSidecarLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecCruiseControlTlsSidecarLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecCruiseControlTlsSidecarLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecCruiseControlTlsSidecarLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecCruiseControlTlsSidecarLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * The log level for the TLS sidecar. Default value is `notice`.
 *
 * @schema KafkaSpecCruiseControlTlsSidecarLogLevel
 */
export enum KafkaSpecCruiseControlTlsSidecarLogLevel {
  /** emerg */
  EMERG = "emerg",
  /** alert */
  ALERT = "alert",
  /** crit */
  CRIT = "crit",
  /** err */
  ERR = "err",
  /** warning */
  WARNING = "warning",
  /** notice */
  NOTICE = "notice",
  /** info */
  INFO = "info",
  /** debug */
  DEBUG = "debug",
}

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecCruiseControlTlsSidecarReadinessProbe
 */
export interface KafkaSpecCruiseControlTlsSidecarReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecCruiseControlTlsSidecarReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecCruiseControlTlsSidecarReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecCruiseControlTlsSidecarReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecCruiseControlTlsSidecarReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecCruiseControlTlsSidecarReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecCruiseControlTlsSidecarResources
 */
export interface KafkaSpecCruiseControlTlsSidecarResources {
  /**
   * @schema KafkaSpecCruiseControlTlsSidecarResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecCruiseControlTlsSidecarResources#requests
   */
  readonly requests?: any;

}

/**
 * @schema KafkaSpecCruiseControlJvmOptionsJavaSystemProperties
 */
export interface KafkaSpecCruiseControlJvmOptionsJavaSystemProperties {
  /**
   * The system property name.
   *
   * @schema KafkaSpecCruiseControlJvmOptionsJavaSystemProperties#name
   */
  readonly name?: string;

  /**
   * The system property value.
   *
   * @schema KafkaSpecCruiseControlJvmOptionsJavaSystemProperties#value
   */
  readonly value?: string;

}

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaSpecCruiseControlLoggingType
 */
export enum KafkaSpecCruiseControlLoggingType {
  /** inline */
  INLINE = "inline",
  /** external */
  EXTERNAL = "external",
}

/**
 * Template for Cruise Control `Deployment`.
 *
 * @schema KafkaSpecCruiseControlTemplateDeployment
 */
export interface KafkaSpecCruiseControlTemplateDeployment {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecCruiseControlTemplateDeployment#metadata
   */
  readonly metadata?: KafkaSpecCruiseControlTemplateDeploymentMetadata;

}

/**
 * Template for Cruise Control `Pods`.
 *
 * @schema KafkaSpecCruiseControlTemplatePod
 */
export interface KafkaSpecCruiseControlTemplatePod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecCruiseControlTemplatePod#metadata
   */
  readonly metadata?: KafkaSpecCruiseControlTemplatePodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaSpecCruiseControlTemplatePod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaSpecCruiseControlTemplatePodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaSpecCruiseControlTemplatePod#securityContext
   */
  readonly securityContext?: KafkaSpecCruiseControlTemplatePodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaSpecCruiseControlTemplatePod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaSpecCruiseControlTemplatePod#affinity
   */
  readonly affinity?: KafkaSpecCruiseControlTemplatePodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaSpecCruiseControlTemplatePod#tolerations
   */
  readonly tolerations?: KafkaSpecCruiseControlTemplatePodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaSpecCruiseControlTemplatePod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaSpecCruiseControlTemplatePod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
   *
   * @schema KafkaSpecCruiseControlTemplatePod#hostAliases
   */
  readonly hostAliases?: KafkaSpecCruiseControlTemplatePodHostAliases[];

}

/**
 * Template for Cruise Control API `Service`.
 *
 * @schema KafkaSpecCruiseControlTemplateApiService
 */
export interface KafkaSpecCruiseControlTemplateApiService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecCruiseControlTemplateApiService#metadata
   */
  readonly metadata?: KafkaSpecCruiseControlTemplateApiServiceMetadata;

}

/**
 * Template for Cruise Control `PodDisruptionBudget`.
 *
 * @schema KafkaSpecCruiseControlTemplatePodDisruptionBudget
 */
export interface KafkaSpecCruiseControlTemplatePodDisruptionBudget {
  /**
   * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
   *
   * @schema KafkaSpecCruiseControlTemplatePodDisruptionBudget#metadata
   */
  readonly metadata?: KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata;

  /**
   * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
   *
   * @default 1.
   * @schema KafkaSpecCruiseControlTemplatePodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: number;

}

/**
 * Template for the Cruise Control container.
 *
 * @schema KafkaSpecCruiseControlTemplateCruiseControlContainer
 */
export interface KafkaSpecCruiseControlTemplateCruiseControlContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainer#env
   */
  readonly env?: KafkaSpecCruiseControlTemplateCruiseControlContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainer#securityContext
   */
  readonly securityContext?: KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext;

}

/**
 * Template for the Cruise Control TLS sidecar container.
 *
 * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainer
 */
export interface KafkaSpecCruiseControlTemplateTlsSidecarContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainer#env
   */
  readonly env?: KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainer#securityContext
   */
  readonly securityContext?: KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext;

}

/**
 * Template for JmxTrans `Deployment`.
 *
 * @schema KafkaSpecJmxTransTemplateDeployment
 */
export interface KafkaSpecJmxTransTemplateDeployment {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecJmxTransTemplateDeployment#metadata
   */
  readonly metadata?: KafkaSpecJmxTransTemplateDeploymentMetadata;

}

/**
 * Template for JmxTrans `Pods`.
 *
 * @schema KafkaSpecJmxTransTemplatePod
 */
export interface KafkaSpecJmxTransTemplatePod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecJmxTransTemplatePod#metadata
   */
  readonly metadata?: KafkaSpecJmxTransTemplatePodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaSpecJmxTransTemplatePod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaSpecJmxTransTemplatePodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaSpecJmxTransTemplatePod#securityContext
   */
  readonly securityContext?: KafkaSpecJmxTransTemplatePodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaSpecJmxTransTemplatePod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaSpecJmxTransTemplatePod#affinity
   */
  readonly affinity?: KafkaSpecJmxTransTemplatePodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaSpecJmxTransTemplatePod#tolerations
   */
  readonly tolerations?: KafkaSpecJmxTransTemplatePodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaSpecJmxTransTemplatePod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaSpecJmxTransTemplatePod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
   *
   * @schema KafkaSpecJmxTransTemplatePod#hostAliases
   */
  readonly hostAliases?: KafkaSpecJmxTransTemplatePodHostAliases[];

}

/**
 * Template for JmxTrans container.
 *
 * @schema KafkaSpecJmxTransTemplateContainer
 */
export interface KafkaSpecJmxTransTemplateContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecJmxTransTemplateContainer#env
   */
  readonly env?: KafkaSpecJmxTransTemplateContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecJmxTransTemplateContainer#securityContext
   */
  readonly securityContext?: KafkaSpecJmxTransTemplateContainerSecurityContext;

}

/**
 * Template for Kafka Exporter `Deployment`.
 *
 * @schema KafkaSpecKafkaExporterTemplateDeployment
 */
export interface KafkaSpecKafkaExporterTemplateDeployment {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaExporterTemplateDeployment#metadata
   */
  readonly metadata?: KafkaSpecKafkaExporterTemplateDeploymentMetadata;

}

/**
 * Template for Kafka Exporter `Pods`.
 *
 * @schema KafkaSpecKafkaExporterTemplatePod
 */
export interface KafkaSpecKafkaExporterTemplatePod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaExporterTemplatePod#metadata
   */
  readonly metadata?: KafkaSpecKafkaExporterTemplatePodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaSpecKafkaExporterTemplatePod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaSpecKafkaExporterTemplatePodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaSpecKafkaExporterTemplatePod#securityContext
   */
  readonly securityContext?: KafkaSpecKafkaExporterTemplatePodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaSpecKafkaExporterTemplatePod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaSpecKafkaExporterTemplatePod#affinity
   */
  readonly affinity?: KafkaSpecKafkaExporterTemplatePodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaSpecKafkaExporterTemplatePod#tolerations
   */
  readonly tolerations?: KafkaSpecKafkaExporterTemplatePodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaSpecKafkaExporterTemplatePod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaSpecKafkaExporterTemplatePod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
   *
   * @schema KafkaSpecKafkaExporterTemplatePod#hostAliases
   */
  readonly hostAliases?: KafkaSpecKafkaExporterTemplatePodHostAliases[];

}

/**
 * Template for Kafka Exporter `Service`.
 *
 * @schema KafkaSpecKafkaExporterTemplateService
 */
export interface KafkaSpecKafkaExporterTemplateService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaExporterTemplateService#metadata
   */
  readonly metadata?: KafkaSpecKafkaExporterTemplateServiceMetadata;

}

/**
 * Template for the Kafka Exporter container.
 *
 * @schema KafkaSpecKafkaExporterTemplateContainer
 */
export interface KafkaSpecKafkaExporterTemplateContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecKafkaExporterTemplateContainer#env
   */
  readonly env?: KafkaSpecKafkaExporterTemplateContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecKafkaExporterTemplateContainer#securityContext
   */
  readonly securityContext?: KafkaSpecKafkaExporterTemplateContainerSecurityContext;

}

/**
 * @schema KafkaSpecKafkaStorageVolumesOverrides
 */
export interface KafkaSpecKafkaStorageVolumesOverrides {
  /**
   * The storage class to use for dynamic volume allocation for this broker.
   *
   * @schema KafkaSpecKafkaStorageVolumesOverrides#class
   */
  readonly class?: string;

  /**
   * Id of the kafka broker (broker identifier).
   *
   * @schema KafkaSpecKafkaStorageVolumesOverrides#broker
   */
  readonly broker?: number;

}

/**
 * Storage type, must be either 'ephemeral' or 'persistent-claim'.
 *
 * @schema KafkaSpecKafkaStorageVolumesType
 */
export enum KafkaSpecKafkaStorageVolumesType {
  /** ephemeral */
  EPHEMERAL = "ephemeral",
  /** persistent-claim */
  PERSISTENT_CLAIM = "persistent-claim",
}

/**
 * @schema KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Authentication type. Currently the only supported types are `password`.`password` type creates a username and protected port with no TLS.
 *
 * @schema KafkaSpecKafkaJmxOptionsAuthenticationType
 */
export enum KafkaSpecKafkaJmxOptionsAuthenticationType {
  /** password */
  PASSWORD = "password",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateStatefulsetMetadata
 */
export interface KafkaSpecKafkaTemplateStatefulsetMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateStatefulsetMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateStatefulsetMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * PodManagementPolicy which will be used for this StatefulSet. Valid values are `Parallel` and `OrderedReady`. Defaults to `Parallel`.
 *
 * @default Parallel`.
 * @schema KafkaSpecKafkaTemplateStatefulsetPodManagementPolicy
 */
export enum KafkaSpecKafkaTemplateStatefulsetPodManagementPolicy {
  /** OrderedReady */
  ORDERED_READY = "OrderedReady",
  /** Parallel */
  PARALLEL = "Parallel",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplatePodMetadata
 */
export interface KafkaSpecKafkaTemplatePodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaSpecKafkaTemplatePodImagePullSecrets
 */
export interface KafkaSpecKafkaTemplatePodImagePullSecrets {
  /**
   * @schema KafkaSpecKafkaTemplatePodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaSpecKafkaTemplatePodSecurityContext
 */
export interface KafkaSpecKafkaTemplatePodSecurityContext {
  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaSpecKafkaTemplatePodSecurityContextSysctls[];

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions;

}

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecKafkaTemplatePodAffinity
 */
export interface KafkaSpecKafkaTemplatePodAffinity {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaSpecKafkaTemplatePodAffinityNodeAffinity;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaSpecKafkaTemplatePodAffinityPodAffinity;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity;

}

/**
 * @schema KafkaSpecKafkaTemplatePodTolerations
 */
export interface KafkaSpecKafkaTemplatePodTolerations {
  /**
   * @schema KafkaSpecKafkaTemplatePodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaSpecKafkaTemplatePodTolerations#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaSpecKafkaTemplatePodHostAliases
 */
export interface KafkaSpecKafkaTemplatePodHostAliases {
  /**
   * @schema KafkaSpecKafkaTemplatePodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaSpecKafkaTemplatePodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateBootstrapServiceMetadata
 */
export interface KafkaSpecKafkaTemplateBootstrapServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateBootstrapServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateBootstrapServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateBrokersServiceMetadata
 */
export interface KafkaSpecKafkaTemplateBrokersServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateBrokersServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateBrokersServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata
 */
export interface KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. `Cluster` may cause a second hop to another node and obscures the client source IP. `Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). If unspecified, Kubernetes will use `Cluster` as the default.
 *
 * @schema KafkaSpecKafkaTemplateExternalBootstrapServiceExternalTrafficPolicy
 */
export enum KafkaSpecKafkaTemplateExternalBootstrapServiceExternalTrafficPolicy {
  /** Local */
  LOCAL = "Local",
  /** Cluster */
  CLUSTER = "Cluster",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplatePerPodServiceMetadata
 */
export interface KafkaSpecKafkaTemplatePerPodServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePerPodServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePerPodServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. `Cluster` may cause a second hop to another node and obscures the client source IP. `Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). If unspecified, Kubernetes will use `Cluster` as the default.
 *
 * @schema KafkaSpecKafkaTemplatePerPodServiceExternalTrafficPolicy
 */
export enum KafkaSpecKafkaTemplatePerPodServiceExternalTrafficPolicy {
  /** Local */
  LOCAL = "Local",
  /** Cluster */
  CLUSTER = "Cluster",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata
 */
export interface KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplatePerPodRouteMetadata
 */
export interface KafkaSpecKafkaTemplatePerPodRouteMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePerPodRouteMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePerPodRouteMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata
 */
export interface KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplatePerPodIngressMetadata
 */
export interface KafkaSpecKafkaTemplatePerPodIngressMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePerPodIngressMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePerPodIngressMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata
 */
export interface KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
 *
 * @schema KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata
 */
export interface KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaSpecKafkaTemplateKafkaContainerEnv
 */
export interface KafkaSpecKafkaTemplateKafkaContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecKafkaTemplateKafkaContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecKafkaTemplateKafkaContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext
 */
export interface KafkaSpecKafkaTemplateKafkaContainerSecurityContext {
  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions;

}

/**
 * @schema KafkaSpecKafkaTemplateTlsSidecarContainerEnv
 */
export interface KafkaSpecKafkaTemplateTlsSidecarContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext
 */
export interface KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext {
  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextWindowsOptions;

}

/**
 * @schema KafkaSpecKafkaTemplateInitContainerEnv
 */
export interface KafkaSpecKafkaTemplateInitContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecKafkaTemplateInitContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecKafkaTemplateInitContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext
 */
export interface KafkaSpecKafkaTemplateInitContainerSecurityContext {
  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions;

}

/**
 * @schema KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecZookeeperTemplateStatefulsetMetadata
 */
export interface KafkaSpecZookeeperTemplateStatefulsetMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplateStatefulsetMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplateStatefulsetMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * PodManagementPolicy which will be used for this StatefulSet. Valid values are `Parallel` and `OrderedReady`. Defaults to `Parallel`.
 *
 * @default Parallel`.
 * @schema KafkaSpecZookeeperTemplateStatefulsetPodManagementPolicy
 */
export enum KafkaSpecZookeeperTemplateStatefulsetPodManagementPolicy {
  /** OrderedReady */
  ORDERED_READY = "OrderedReady",
  /** Parallel */
  PARALLEL = "Parallel",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecZookeeperTemplatePodMetadata
 */
export interface KafkaSpecZookeeperTemplatePodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplatePodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplatePodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodImagePullSecrets
 */
export interface KafkaSpecZookeeperTemplatePodImagePullSecrets {
  /**
   * @schema KafkaSpecZookeeperTemplatePodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaSpecZookeeperTemplatePodSecurityContext
 */
export interface KafkaSpecZookeeperTemplatePodSecurityContext {
  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaSpecZookeeperTemplatePodSecurityContextSysctls[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions;

}

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecZookeeperTemplatePodAffinity
 */
export interface KafkaSpecZookeeperTemplatePodAffinity {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinity;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaSpecZookeeperTemplatePodAffinityPodAffinity;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodTolerations
 */
export interface KafkaSpecZookeeperTemplatePodTolerations {
  /**
   * @schema KafkaSpecZookeeperTemplatePodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaSpecZookeeperTemplatePodTolerations#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodHostAliases
 */
export interface KafkaSpecZookeeperTemplatePodHostAliases {
  /**
   * @schema KafkaSpecZookeeperTemplatePodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecZookeeperTemplateClientServiceMetadata
 */
export interface KafkaSpecZookeeperTemplateClientServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplateClientServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplateClientServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecZookeeperTemplateNodesServiceMetadata
 */
export interface KafkaSpecZookeeperTemplateNodesServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplateNodesServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplateNodesServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata
 */
export interface KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
 *
 * @schema KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata
 */
export interface KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaSpecZookeeperTemplateZookeeperContainerEnv
 */
export interface KafkaSpecZookeeperTemplateZookeeperContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext
 */
export interface KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext {
  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions;

}

/**
 * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerEnv
 */
export interface KafkaSpecZookeeperTemplateTlsSidecarContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext
 */
export interface KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext {
  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextWindowsOptions;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorLoggingType
 */
export enum KafkaSpecEntityOperatorTopicOperatorLoggingType {
  /** inline */
  INLINE = "inline",
  /** external */
  EXTERNAL = "external",
}

/**
 * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties
 */
export interface KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties {
  /**
   * The system property name.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties#name
   */
  readonly name?: string;

  /**
   * The system property value.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties#value
   */
  readonly value?: string;

}

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaSpecEntityOperatorUserOperatorLoggingType
 */
export enum KafkaSpecEntityOperatorUserOperatorLoggingType {
  /** inline */
  INLINE = "inline",
  /** external */
  EXTERNAL = "external",
}

/**
 * @schema KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties
 */
export interface KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties {
  /**
   * The system property name.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties#name
   */
  readonly name?: string;

  /**
   * The system property value.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecEntityOperatorTemplateDeploymentMetadata
 */
export interface KafkaSpecEntityOperatorTemplateDeploymentMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecEntityOperatorTemplateDeploymentMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecEntityOperatorTemplateDeploymentMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecEntityOperatorTemplatePodMetadata
 */
export interface KafkaSpecEntityOperatorTemplatePodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecEntityOperatorTemplatePodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecEntityOperatorTemplatePodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodImagePullSecrets
 */
export interface KafkaSpecEntityOperatorTemplatePodImagePullSecrets {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext
 */
export interface KafkaSpecEntityOperatorTemplatePodSecurityContext {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions;

}

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecEntityOperatorTemplatePodAffinity
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinity {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodTolerations
 */
export interface KafkaSpecEntityOperatorTemplatePodTolerations {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodTolerations#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodHostAliases
 */
export interface KafkaSpecEntityOperatorTemplatePodHostAliases {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv
 */
export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext
 */
export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext {
  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions;

}

/**
 * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv
 */
export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext
 */
export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext {
  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions;

}

/**
 * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv
 */
export interface KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext
 */
export interface KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext {
  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecCruiseControlTemplateDeploymentMetadata
 */
export interface KafkaSpecCruiseControlTemplateDeploymentMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecCruiseControlTemplateDeploymentMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecCruiseControlTemplateDeploymentMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecCruiseControlTemplatePodMetadata
 */
export interface KafkaSpecCruiseControlTemplatePodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecCruiseControlTemplatePodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecCruiseControlTemplatePodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodImagePullSecrets
 */
export interface KafkaSpecCruiseControlTemplatePodImagePullSecrets {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaSpecCruiseControlTemplatePodSecurityContext
 */
export interface KafkaSpecCruiseControlTemplatePodSecurityContext {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaSpecCruiseControlTemplatePodSecurityContextSysctls[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions;

}

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecCruiseControlTemplatePodAffinity
 */
export interface KafkaSpecCruiseControlTemplatePodAffinity {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinity;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodTolerations
 */
export interface KafkaSpecCruiseControlTemplatePodTolerations {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodTolerations#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodHostAliases
 */
export interface KafkaSpecCruiseControlTemplatePodHostAliases {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecCruiseControlTemplateApiServiceMetadata
 */
export interface KafkaSpecCruiseControlTemplateApiServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecCruiseControlTemplateApiServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecCruiseControlTemplateApiServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
 *
 * @schema KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata
 */
export interface KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerEnv
 */
export interface KafkaSpecCruiseControlTemplateCruiseControlContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext
 */
export interface KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext {
  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions;

}

/**
 * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv
 */
export interface KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext
 */
export interface KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext {
  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecJmxTransTemplateDeploymentMetadata
 */
export interface KafkaSpecJmxTransTemplateDeploymentMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecJmxTransTemplateDeploymentMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecJmxTransTemplateDeploymentMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecJmxTransTemplatePodMetadata
 */
export interface KafkaSpecJmxTransTemplatePodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecJmxTransTemplatePodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecJmxTransTemplatePodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodImagePullSecrets
 */
export interface KafkaSpecJmxTransTemplatePodImagePullSecrets {
  /**
   * @schema KafkaSpecJmxTransTemplatePodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaSpecJmxTransTemplatePodSecurityContext
 */
export interface KafkaSpecJmxTransTemplatePodSecurityContext {
  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaSpecJmxTransTemplatePodSecurityContextSysctls[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions;

}

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecJmxTransTemplatePodAffinity
 */
export interface KafkaSpecJmxTransTemplatePodAffinity {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinity;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaSpecJmxTransTemplatePodAffinityPodAffinity;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodTolerations
 */
export interface KafkaSpecJmxTransTemplatePodTolerations {
  /**
   * @schema KafkaSpecJmxTransTemplatePodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaSpecJmxTransTemplatePodTolerations#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodHostAliases
 */
export interface KafkaSpecJmxTransTemplatePodHostAliases {
  /**
   * @schema KafkaSpecJmxTransTemplatePodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * @schema KafkaSpecJmxTransTemplateContainerEnv
 */
export interface KafkaSpecJmxTransTemplateContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecJmxTransTemplateContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecJmxTransTemplateContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaSpecJmxTransTemplateContainerSecurityContext
 */
export interface KafkaSpecJmxTransTemplateContainerSecurityContext {
  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaExporterTemplateDeploymentMetadata
 */
export interface KafkaSpecKafkaExporterTemplateDeploymentMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaExporterTemplateDeploymentMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaExporterTemplateDeploymentMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaExporterTemplatePodMetadata
 */
export interface KafkaSpecKafkaExporterTemplatePodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaExporterTemplatePodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaExporterTemplatePodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodImagePullSecrets
 */
export interface KafkaSpecKafkaExporterTemplatePodImagePullSecrets {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext
 */
export interface KafkaSpecKafkaExporterTemplatePodSecurityContext {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions;

}

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecKafkaExporterTemplatePodAffinity
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinity {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodTolerations
 */
export interface KafkaSpecKafkaExporterTemplatePodTolerations {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodTolerations#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodHostAliases
 */
export interface KafkaSpecKafkaExporterTemplatePodHostAliases {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaExporterTemplateServiceMetadata
 */
export interface KafkaSpecKafkaExporterTemplateServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaExporterTemplateServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaExporterTemplateServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaSpecKafkaExporterTemplateContainerEnv
 */
export interface KafkaSpecKafkaExporterTemplateContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecKafkaExporterTemplateContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecKafkaExporterTemplateContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext
 */
export interface KafkaSpecKafkaExporterTemplateContainerSecurityContext {
  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions;

}

/**
 * @schema KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecKafkaTemplatePodSecurityContextSysctls
 */
export interface KafkaSpecKafkaTemplatePodSecurityContextSysctls {
  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinity
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinity {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinity
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinity {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities
 */
export interface KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextCapabilities
 */
export interface KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities
 */
export interface KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodSecurityContextSysctls
 */
export interface KafkaSpecZookeeperTemplatePodSecurityContextSysctls {
  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinity
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinity {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinity
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinity {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities
 */
export interface KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextCapabilities
 */
export interface KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls
 */
export interface KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities
 */
export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities
 */
export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities
 */
export interface KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSysctls
 */
export interface KafkaSpecCruiseControlTemplatePodSecurityContextSysctls {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinity
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinity {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities
 */
export interface KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities
 */
export interface KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodSecurityContextSysctls
 */
export interface KafkaSpecJmxTransTemplatePodSecurityContextSysctls {
  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinity
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinity {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinity
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinity {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities
 */
export interface KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls
 */
export interface KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities
 */
export interface KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

