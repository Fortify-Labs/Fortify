// generated by cdk8s
import { ApiObject } from 'cdk8s';
import { Construct } from 'constructs';

/**
 * 
 *
 * @schema Redis
 */
export class Redis extends ApiObject {
  /**
   * Defines a "Redis" API object
   * @param scope the scope in which to define this object
   * @param name a scope-local name for the object
   * @param options configuration options
   */
  public constructor(scope: Construct, name: string, options: RedisOptions = {}) {
    super(scope, name, {
      ...options,
      kind: 'Redis',
      apiVersion: 'kubedb.com/v1alpha1',
    });
  }
}

/**
 * @schema Redis
 */
export interface RedisOptions {
  /**
   * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
   *
   * @schema Redis#metadata
   */
  readonly metadata?: RedisMetadata;

  /**
   * @schema Redis#spec
   */
  readonly spec?: RedisSpec;

}

/**
 * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
 *
 * @schema RedisMetadata
 */
export interface RedisMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema RedisMetadata#annotations
   */
  readonly annotations?: any;

  /**
   * The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
   *
   * @schema RedisMetadata#clusterName
   */
  readonly clusterName?: string;

  /**
   * Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
   *
   * @schema RedisMetadata#creationTimestamp
   */
  readonly creationTimestamp?: Date;

  /**
   * Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
   *
   * @schema RedisMetadata#deletionGracePeriodSeconds
   */
  readonly deletionGracePeriodSeconds?: number;

  /**
   * Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
   *
   * @schema RedisMetadata#deletionTimestamp
   */
  readonly deletionTimestamp?: Date;

  /**
   * Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
   *
   * @schema RedisMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.

If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).

Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#idempotency
   *
   * @schema RedisMetadata#generateName
   */
  readonly generateName?: string;

  /**
   * A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.
   *
   * @schema RedisMetadata#generation
   */
  readonly generation?: number;

  /**
   * Initializers tracks the progress of initialization.
   *
   * @schema RedisMetadata#initializers
   */
  readonly initializers?: RedisMetadataInitializers;

  /**
   * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
   *
   * @schema RedisMetadata#labels
   */
  readonly labels?: any;

  /**
   * ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like "ci-cd". The set of fields is always in the version that the workflow used when modifying the object.

This field is alpha and can be changed or removed without notice.
   *
   * @schema RedisMetadata#managedFields
   */
  readonly managedFields?: RedisMetadataManagedFields[];

  /**
   * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
   *
   * @schema RedisMetadata#name
   */
  readonly name?: string;

  /**
   * Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.

Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
   *
   * @schema RedisMetadata#namespace
   */
  readonly namespace?: string;

  /**
   * List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.
   *
   * @schema RedisMetadata#ownerReferences
   */
  readonly ownerReferences?: RedisMetadataOwnerReferences[];

  /**
   * An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.

Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
   *
   * @schema RedisMetadata#resourceVersion
   */
  readonly resourceVersion?: string;

  /**
   * SelfLink is a URL representing this object. Populated by the system. Read-only.
   *
   * @schema RedisMetadata#selfLink
   */
  readonly selfLink?: string;

  /**
   * UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.

Populated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids
   *
   * @schema RedisMetadata#uid
   */
  readonly uid?: string;

}

/**
 * @schema RedisSpec
 */
export interface RedisSpec {
  /**
   * @schema RedisSpec#cluster
   */
  readonly cluster?: RedisSpecCluster;

  /**
   * Represents the source of a volume to mount. Only one of its members may be specified.
   *
   * @schema RedisSpec#configSource
   */
  readonly configSource?: RedisSpecConfigSource;

  /**
   * Default is "Standalone". If set to "Cluster", ClusterSpec is required and redis servers will start in cluster mode
   *
   * @default Standalone". If set to "Cluster", ClusterSpec is required and redis servers will start in cluster mode
   * @schema RedisSpec#mode
   */
  readonly mode?: string;

  /**
   * @schema RedisSpec#monitor
   */
  readonly monitor?: RedisSpecMonitor;

  /**
   * PodTemplateSpec describes the data a pod should have when created from a template
   *
   * @schema RedisSpec#podTemplate
   */
  readonly podTemplate?: RedisSpecPodTemplate;

  /**
   * Number of instances to deploy for a MySQL database.
   *
   * @schema RedisSpec#replicas
   */
  readonly replicas?: number;

  /**
   * ServiceTemplateSpec describes the data a service should have when created from a template
   *
   * @schema RedisSpec#serviceTemplate
   */
  readonly serviceTemplate?: RedisSpecServiceTemplate;

  /**
   * PersistentVolumeClaimSpec describes the common attributes of storage devices and allows a Source for provider-specific attributes
   *
   * @schema RedisSpec#storage
   */
  readonly storage?: RedisSpecStorage;

  /**
   * StorageType can be durable (default) or ephemeral
   *
   * @schema RedisSpec#storageType
   */
  readonly storageType?: string;

  /**
   * TerminationPolicy controls the delete operation for database
   *
   * @schema RedisSpec#terminationPolicy
   */
  readonly terminationPolicy?: string;

  /**
   * StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to perform updates. It includes any additional parameters necessary to perform the update for the indicated strategy.
   *
   * @schema RedisSpec#updateStrategy
   */
  readonly updateStrategy?: RedisSpecUpdateStrategy;

  /**
   * Version of Redis to be deployed.
   *
   * @schema RedisSpec#version
   */
  readonly version: string;

}

/**
 * Initializers tracks the progress of initialization.
 *
 * @schema RedisMetadataInitializers
 */
export interface RedisMetadataInitializers {
  /**
   * Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
   *
   * @schema RedisMetadataInitializers#pending
   */
  readonly pending: RedisMetadataInitializersPending[];

  /**
   * Status is a return value for calls that don't return other objects.
   *
   * @schema RedisMetadataInitializers#result
   */
  readonly result?: RedisMetadataInitializersResult;

}

/**
 * ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to.
 *
 * @schema RedisMetadataManagedFields
 */
export interface RedisMetadataManagedFields {
  /**
   * APIVersion defines the version of this resource that this field set applies to. The format is "group/version" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted.
   *
   * @schema RedisMetadataManagedFields#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Fields stores a set of fields in a data structure like a Trie. To understand how this is used, see: https://github.com/kubernetes-sigs/structured-merge-diff
   *
   * @schema RedisMetadataManagedFields#fields
   */
  readonly fields?: any;

  /**
   * Manager is an identifier of the workflow managing these fields.
   *
   * @schema RedisMetadataManagedFields#manager
   */
  readonly manager?: string;

  /**
   * Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'.
   *
   * @schema RedisMetadataManagedFields#operation
   */
  readonly operation?: string;

  /**
   * Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
   *
   * @schema RedisMetadataManagedFields#time
   */
  readonly time?: Date;

}

/**
 * OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.
 *
 * @schema RedisMetadataOwnerReferences
 */
export interface RedisMetadataOwnerReferences {
  /**
   * API version of the referent.
   *
   * @schema RedisMetadataOwnerReferences#apiVersion
   */
  readonly apiVersion: string;

  /**
   * If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.
   *
   * @default false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.
   * @schema RedisMetadataOwnerReferences#blockOwnerDeletion
   */
  readonly blockOwnerDeletion?: boolean;

  /**
   * If true, this reference points to the managing controller.
   *
   * @schema RedisMetadataOwnerReferences#controller
   */
  readonly controller?: boolean;

  /**
   * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
   *
   * @schema RedisMetadataOwnerReferences#kind
   */
  readonly kind: string;

  /**
   * Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names
   *
   * @schema RedisMetadataOwnerReferences#name
   */
  readonly name: string;

  /**
   * UID of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#uids
   *
   * @schema RedisMetadataOwnerReferences#uid
   */
  readonly uid: string;

}

/**
 * @schema RedisSpecCluster
 */
export interface RedisSpecCluster {
  /**
   * Number of master nodes. It must be >= 3. If not specified, defaults to 3.
   *
   * @schema RedisSpecCluster#master
   */
  readonly master?: number;

  /**
   * Number of replica(s) per master node. If not specified, defaults to 1.
   *
   * @schema RedisSpecCluster#replicas
   */
  readonly replicas?: number;

}

/**
 * Represents the source of a volume to mount. Only one of its members may be specified.
 *
 * @schema RedisSpecConfigSource
 */
export interface RedisSpecConfigSource {
  /**
   * Represents a Persistent Disk resource in AWS.

An AWS EBS disk must exist before mounting to a container. The disk must also be in the same AWS zone as the kubelet. An AWS EBS disk can only be mounted as read/write once. AWS EBS volumes support ownership management and SELinux relabeling.
   *
   * @schema RedisSpecConfigSource#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: RedisSpecConfigSourceAwsElasticBlockStore;

  /**
   * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   *
   * @schema RedisSpecConfigSource#azureDisk
   */
  readonly azureDisk?: RedisSpecConfigSourceAzureDisk;

  /**
   * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
   *
   * @schema RedisSpecConfigSource#azureFile
   */
  readonly azureFile?: RedisSpecConfigSourceAzureFile;

  /**
   * Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not support ownership management or SELinux relabeling.
   *
   * @schema RedisSpecConfigSource#cephfs
   */
  readonly cephfs?: RedisSpecConfigSourceCephfs;

  /**
   * Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting to a container. The volume must also be in the same region as the kubelet. Cinder volumes support ownership management and SELinux relabeling.
   *
   * @schema RedisSpecConfigSource#cinder
   */
  readonly cinder?: RedisSpecConfigSourceCinder;

  /**
   * Adapts a ConfigMap into a volume.

The contents of the target ConfigMap's Data field will be presented in a volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. ConfigMap volumes support ownership management and SELinux relabeling.
   *
   * @schema RedisSpecConfigSource#configMap
   */
  readonly configMap?: RedisSpecConfigSourceConfigMap;

  /**
   * Represents a source location of a volume to mount, managed by an external CSI driver
   *
   * @schema RedisSpecConfigSource#csi
   */
  readonly csi?: RedisSpecConfigSourceCsi;

  /**
   * DownwardAPIVolumeSource represents a volume containing downward API info. Downward API volumes support ownership management and SELinux relabeling.
   *
   * @schema RedisSpecConfigSource#downwardAPI
   */
  readonly downwardAPI?: RedisSpecConfigSourceDownwardApi;

  /**
   * Represents an empty directory for a pod. Empty directory volumes support ownership management and SELinux relabeling.
   *
   * @schema RedisSpecConfigSource#emptyDir
   */
  readonly emptyDir?: RedisSpecConfigSourceEmptyDir;

  /**
   * Represents a Fibre Channel volume. Fibre Channel volumes can only be mounted as read/write once. Fibre Channel volumes support ownership management and SELinux relabeling.
   *
   * @schema RedisSpecConfigSource#fc
   */
  readonly fc?: RedisSpecConfigSourceFc;

  /**
   * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
   *
   * @schema RedisSpecConfigSource#flexVolume
   */
  readonly flexVolume?: RedisSpecConfigSourceFlexVolume;

  /**
   * Represents a Flocker volume mounted by the Flocker agent. One and only one of datasetName and datasetUUID should be set. Flocker volumes do not support ownership management or SELinux relabeling.
   *
   * @schema RedisSpecConfigSource#flocker
   */
  readonly flocker?: RedisSpecConfigSourceFlocker;

  /**
   * Represents a Persistent Disk resource in Google Compute Engine.

A GCE PD must exist before mounting to a container. The disk must also be in the same GCE project and zone as the kubelet. A GCE PD can only be mounted as read/write once or read-only many times. GCE PDs support ownership management and SELinux relabeling.
   *
   * @schema RedisSpecConfigSource#gcePersistentDisk
   */
  readonly gcePersistentDisk?: RedisSpecConfigSourceGcePersistentDisk;

  /**
   * Represents a volume that is populated with the contents of a git repository. Git repo volumes do not support ownership management. Git repo volumes support SELinux relabeling.

DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
   *
   * @schema RedisSpecConfigSource#gitRepo
   */
  readonly gitRepo?: RedisSpecConfigSourceGitRepo;

  /**
   * Represents a Glusterfs mount that lasts the lifetime of a pod. Glusterfs volumes do not support ownership management or SELinux relabeling.
   *
   * @schema RedisSpecConfigSource#glusterfs
   */
  readonly glusterfs?: RedisSpecConfigSourceGlusterfs;

  /**
   * Represents a host path mapped into a pod. Host path volumes do not support ownership management or SELinux relabeling.
   *
   * @schema RedisSpecConfigSource#hostPath
   */
  readonly hostPath?: RedisSpecConfigSourceHostPath;

  /**
   * Represents an ISCSI disk. ISCSI volumes can only be mounted as read/write once. ISCSI volumes support ownership management and SELinux relabeling.
   *
   * @schema RedisSpecConfigSource#iscsi
   */
  readonly iscsi?: RedisSpecConfigSourceIscsi;

  /**
   * Represents an NFS mount that lasts the lifetime of a pod. NFS volumes do not support ownership management or SELinux relabeling.
   *
   * @schema RedisSpecConfigSource#nfs
   */
  readonly nfs?: RedisSpecConfigSourceNfs;

  /**
   * PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace. This volume finds the bound PV and mounts that volume for the pod. A PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another type of volume that is owned by someone else (the system).
   *
   * @schema RedisSpecConfigSource#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: RedisSpecConfigSourcePersistentVolumeClaim;

  /**
   * Represents a Photon Controller persistent disk resource.
   *
   * @schema RedisSpecConfigSource#photonPersistentDisk
   */
  readonly photonPersistentDisk?: RedisSpecConfigSourcePhotonPersistentDisk;

  /**
   * PortworxVolumeSource represents a Portworx volume resource.
   *
   * @schema RedisSpecConfigSource#portworxVolume
   */
  readonly portworxVolume?: RedisSpecConfigSourcePortworxVolume;

  /**
   * Represents a projected volume source
   *
   * @schema RedisSpecConfigSource#projected
   */
  readonly projected?: RedisSpecConfigSourceProjected;

  /**
   * Represents a Quobyte mount that lasts the lifetime of a pod. Quobyte volumes do not support ownership management or SELinux relabeling.
   *
   * @schema RedisSpecConfigSource#quobyte
   */
  readonly quobyte?: RedisSpecConfigSourceQuobyte;

  /**
   * Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support ownership management and SELinux relabeling.
   *
   * @schema RedisSpecConfigSource#rbd
   */
  readonly rbd?: RedisSpecConfigSourceRbd;

  /**
   * ScaleIOVolumeSource represents a persistent ScaleIO volume
   *
   * @schema RedisSpecConfigSource#scaleIO
   */
  readonly scaleIO?: RedisSpecConfigSourceScaleIo;

  /**
   * Adapts a Secret into a volume.

The contents of the target Secret's Data field will be presented in a volume as files using the keys in the Data field as the file names. Secret volumes support ownership management and SELinux relabeling.
   *
   * @schema RedisSpecConfigSource#secret
   */
  readonly secret?: RedisSpecConfigSourceSecret;

  /**
   * Represents a StorageOS persistent volume resource.
   *
   * @schema RedisSpecConfigSource#storageos
   */
  readonly storageos?: RedisSpecConfigSourceStorageos;

  /**
   * Represents a vSphere volume resource.
   *
   * @schema RedisSpecConfigSource#vsphereVolume
   */
  readonly vsphereVolume?: RedisSpecConfigSourceVsphereVolume;

}

/**
 * @schema RedisSpecMonitor
 */
export interface RedisSpecMonitor {
  /**
   * @schema RedisSpecMonitor#agent
   */
  readonly agent?: string;

  /**
   * Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RedisSpecMonitor#args
   */
  readonly args?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema RedisSpecMonitor#env
   */
  readonly env?: RedisSpecMonitorEnv[];

  /**
   * @schema RedisSpecMonitor#prometheus
   */
  readonly prometheus?: RedisSpecMonitorPrometheus;

  /**
   * ResourceRequirements describes the compute resource requirements.
   *
   * @schema RedisSpecMonitor#resources
   */
  readonly resources?: RedisSpecMonitorResources;

  /**
   * SecurityContext holds security configuration that will be applied to a container. Some fields are present in both SecurityContext and PodSecurityContext.  When both are set, the values in SecurityContext take precedence.
   *
   * @schema RedisSpecMonitor#securityContext
   */
  readonly securityContext?: RedisSpecMonitorSecurityContext;

}

/**
 * PodTemplateSpec describes the data a pod should have when created from a template
 *
 * @schema RedisSpecPodTemplate
 */
export interface RedisSpecPodTemplate {
  /**
   * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
   *
   * @schema RedisSpecPodTemplate#controller
   */
  readonly controller?: RedisSpecPodTemplateController;

  /**
   * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
   *
   * @schema RedisSpecPodTemplate#metadata
   */
  readonly metadata?: RedisSpecPodTemplateMetadata;

  /**
   * @schema RedisSpecPodTemplate#spec
   */
  readonly spec?: RedisSpecPodTemplateSpec;

}

/**
 * ServiceTemplateSpec describes the data a service should have when created from a template
 *
 * @schema RedisSpecServiceTemplate
 */
export interface RedisSpecServiceTemplate {
  /**
   * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
   *
   * @schema RedisSpecServiceTemplate#metadata
   */
  readonly metadata?: RedisSpecServiceTemplateMetadata;

  /**
   * ServiceSpec describes the attributes that a user creates on a service.
   *
   * @schema RedisSpecServiceTemplate#spec
   */
  readonly spec?: RedisSpecServiceTemplateSpec;

}

/**
 * PersistentVolumeClaimSpec describes the common attributes of storage devices and allows a Source for provider-specific attributes
 *
 * @schema RedisSpecStorage
 */
export interface RedisSpecStorage {
  /**
   * AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema RedisSpecStorage#accessModes
   */
  readonly accessModes?: string[];

  /**
   * TypedLocalObjectReference contains enough information to let you locate the typed referenced object inside the same namespace.
   *
   * @schema RedisSpecStorage#dataSource
   */
  readonly dataSource?: RedisSpecStorageDataSource;

  /**
   * ResourceRequirements describes the compute resource requirements.
   *
   * @schema RedisSpecStorage#resources
   */
  readonly resources?: RedisSpecStorageResources;

  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
   *
   * @schema RedisSpecStorage#selector
   */
  readonly selector?: RedisSpecStorageSelector;

  /**
   * Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema RedisSpecStorage#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec. This is a beta feature.
   *
   * @schema RedisSpecStorage#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * VolumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema RedisSpecStorage#volumeName
   */
  readonly volumeName?: string;

}

/**
 * StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to perform updates. It includes any additional parameters necessary to perform the update for the indicated strategy.
 *
 * @schema RedisSpecUpdateStrategy
 */
export interface RedisSpecUpdateStrategy {
  /**
   * RollingUpdateStatefulSetStrategy is used to communicate parameter for RollingUpdateStatefulSetStrategyType.
   *
   * @schema RedisSpecUpdateStrategy#rollingUpdate
   */
  readonly rollingUpdate?: RedisSpecUpdateStrategyRollingUpdate;

  /**
   * Type indicates the type of the StatefulSetUpdateStrategy. Default is RollingUpdate.
   *
   * @default RollingUpdate.
   * @schema RedisSpecUpdateStrategy#type
   */
  readonly type?: string;

}

/**
 * Initializer is information about an initializer that has not yet completed.
 *
 * @schema RedisMetadataInitializersPending
 */
export interface RedisMetadataInitializersPending {
  /**
   * name of the process that is responsible for initializing this object.
   *
   * @schema RedisMetadataInitializersPending#name
   */
  readonly name: string;

}

/**
 * Status is a return value for calls that don't return other objects.
 *
 * @schema RedisMetadataInitializersResult
 */
export interface RedisMetadataInitializersResult {
  /**
   * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
   *
   * @schema RedisMetadataInitializersResult#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Suggested HTTP return code for this status, 0 if not set.
   *
   * @schema RedisMetadataInitializersResult#code
   */
  readonly code?: number;

  /**
   * StatusDetails is a set of additional properties that MAY be set by the server to provide additional information about a response. The Reason field of a Status object defines what attributes will be set. Clients must ignore fields that do not match the defined type of each attribute, and should assume that any attribute may be empty, invalid, or under defined.
   *
   * @schema RedisMetadataInitializersResult#details
   */
  readonly details?: RedisMetadataInitializersResultDetails;

  /**
   * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
   *
   * @schema RedisMetadataInitializersResult#kind
   */
  readonly kind?: string;

  /**
   * A human-readable description of the status of this operation.
   *
   * @schema RedisMetadataInitializersResult#message
   */
  readonly message?: string;

  /**
   * ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
   *
   * @schema RedisMetadataInitializersResult#metadata
   */
  readonly metadata?: RedisMetadataInitializersResultMetadata;

  /**
   * A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
   *
   * @schema RedisMetadataInitializersResult#reason
   */
  readonly reason?: string;

  /**
   * Status of the operation. One of: "Success" or "Failure". More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
   *
   * @schema RedisMetadataInitializersResult#status
   */
  readonly status?: string;

}

/**
 * Represents a Persistent Disk resource in AWS.

An AWS EBS disk must exist before mounting to a container. The disk must also be in the same AWS zone as the kubelet. An AWS EBS disk can only be mounted as read/write once. AWS EBS volumes support ownership management and SELinux relabeling.
 *
 * @schema RedisSpecConfigSourceAwsElasticBlockStore
 */
export interface RedisSpecConfigSourceAwsElasticBlockStore {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema RedisSpecConfigSourceAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema RedisSpecConfigSourceAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * Specify "true" to force and set the ReadOnly property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema RedisSpecConfigSourceAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema RedisSpecConfigSourceAwsElasticBlockStore#volumeID
   */
  readonly volumeID: string;

}

/**
 * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 *
 * @schema RedisSpecConfigSourceAzureDisk
 */
export interface RedisSpecConfigSourceAzureDisk {
  /**
   * Host Caching mode: None, Read Only, Read Write.
   *
   * @schema RedisSpecConfigSourceAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * The Name of the data disk in the blob storage
   *
   * @schema RedisSpecConfigSourceAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * The URI the data disk in the blob storage
   *
   * @schema RedisSpecConfigSourceAzureDisk#diskURI
   */
  readonly diskURI: string;

  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema RedisSpecConfigSourceAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * Expected values Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema RedisSpecConfigSourceAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RedisSpecConfigSourceAzureDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @schema RedisSpecConfigSourceAzureFile
 */
export interface RedisSpecConfigSourceAzureFile {
  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RedisSpecConfigSourceAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * the name of secret that contains Azure Storage Account Name and Key
   *
   * @schema RedisSpecConfigSourceAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * Share Name
   *
   * @schema RedisSpecConfigSourceAzureFile#shareName
   */
  readonly shareName: string;

}

/**
 * Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not support ownership management or SELinux relabeling.
 *
 * @schema RedisSpecConfigSourceCephfs
 */
export interface RedisSpecConfigSourceCephfs {
  /**
   * Required: Monitors is a collection of Ceph monitors More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema RedisSpecConfigSourceCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema RedisSpecConfigSourceCephfs#path
   */
  readonly path?: string;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
   * @schema RedisSpecConfigSourceCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema RedisSpecConfigSourceCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
   *
   * @schema RedisSpecConfigSourceCephfs#secretRef
   */
  readonly secretRef?: RedisSpecConfigSourceCephfsSecretRef;

  /**
   * Optional: User is the rados user name, default is admin More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema RedisSpecConfigSourceCephfs#user
   */
  readonly user?: string;

}

/**
 * Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting to a container. The volume must also be in the same region as the kubelet. Cinder volumes support ownership management and SELinux relabeling.
 *
 * @schema RedisSpecConfigSourceCinder
 */
export interface RedisSpecConfigSourceCinder {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
   *
   * @schema RedisSpecConfigSourceCinder#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
   * @schema RedisSpecConfigSourceCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
   *
   * @schema RedisSpecConfigSourceCinder#secretRef
   */
  readonly secretRef?: RedisSpecConfigSourceCinderSecretRef;

  /**
   * volume id used to identify the volume in cinder More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
   *
   * @schema RedisSpecConfigSourceCinder#volumeID
   */
  readonly volumeID: string;

}

/**
 * Adapts a ConfigMap into a volume.

The contents of the target ConfigMap's Data field will be presented in a volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. ConfigMap volumes support ownership management and SELinux relabeling.
 *
 * @schema RedisSpecConfigSourceConfigMap
 */
export interface RedisSpecConfigSourceConfigMap {
  /**
   * Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema RedisSpecConfigSourceConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema RedisSpecConfigSourceConfigMap#items
   */
  readonly items?: RedisSpecConfigSourceConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema RedisSpecConfigSourceConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or it's keys must be defined
   *
   * @schema RedisSpecConfigSourceConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Represents a source location of a volume to mount, managed by an external CSI driver
 *
 * @schema RedisSpecConfigSourceCsi
 */
export interface RedisSpecConfigSourceCsi {
  /**
   * Driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema RedisSpecConfigSourceCsi#driver
   */
  readonly driver: string;

  /**
   * Filesystem type to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty value is passed to the associated CSI driver which will determine the default filesystem to apply.
   *
   * @schema RedisSpecConfigSourceCsi#fsType
   */
  readonly fsType?: string;

  /**
   * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
   *
   * @schema RedisSpecConfigSourceCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: RedisSpecConfigSourceCsiNodePublishSecretRef;

  /**
   * Specifies a read-only configuration for the volume. Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema RedisSpecConfigSourceCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * VolumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values.
   *
   * @schema RedisSpecConfigSourceCsi#volumeAttributes
   */
  readonly volumeAttributes?: any;

}

/**
 * DownwardAPIVolumeSource represents a volume containing downward API info. Downward API volumes support ownership management and SELinux relabeling.
 *
 * @schema RedisSpecConfigSourceDownwardApi
 */
export interface RedisSpecConfigSourceDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema RedisSpecConfigSourceDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema RedisSpecConfigSourceDownwardApi#items
   */
  readonly items?: RedisSpecConfigSourceDownwardApiItems[];

}

/**
 * Represents an empty directory for a pod. Empty directory volumes support ownership management and SELinux relabeling.
 *
 * @schema RedisSpecConfigSourceEmptyDir
 */
export interface RedisSpecConfigSourceEmptyDir {
  /**
   * What type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema RedisSpecConfigSourceEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and Int64() accessors.

The serialization format is:

<quantity>        ::= <signedNumber><suffix>
  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
<digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
<decimalSI>       ::= m | "" | k | M | G | T | P | E
  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
<decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>

No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:
  a. No precision is lost
  b. No fractional digits will be emitted
  c. The exponent (or suffix) is as large as possible.
The sign will be omitted unless the number is negative.

Examples:
  1.5 will be serialized as "1500m"
  1.5Gi will be serialized as "1536Mi"

Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.
   *
   * @schema RedisSpecConfigSourceEmptyDir#sizeLimit
   */
  readonly sizeLimit?: string;

}

/**
 * Represents a Fibre Channel volume. Fibre Channel volumes can only be mounted as read/write once. Fibre Channel volumes support ownership management and SELinux relabeling.
 *
 * @schema RedisSpecConfigSourceFc
 */
export interface RedisSpecConfigSourceFc {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema RedisSpecConfigSourceFc#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: FC target lun number
   *
   * @schema RedisSpecConfigSourceFc#lun
   */
  readonly lun?: number;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RedisSpecConfigSourceFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: FC target worldwide names (WWNs)
   *
   * @schema RedisSpecConfigSourceFc#targetWWNs
   */
  readonly targetWWNs?: string[];

  /**
   * Optional: FC volume world wide identifiers (wwids) Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema RedisSpecConfigSourceFc#wwids
   */
  readonly wwids?: string[];

}

/**
 * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
 *
 * @schema RedisSpecConfigSourceFlexVolume
 */
export interface RedisSpecConfigSourceFlexVolume {
  /**
   * Driver is the name of the driver to use for this volume.
   *
   * @schema RedisSpecConfigSourceFlexVolume#driver
   */
  readonly driver: string;

  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema RedisSpecConfigSourceFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: Extra command options if any.
   *
   * @schema RedisSpecConfigSourceFlexVolume#options
   */
  readonly options?: any;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RedisSpecConfigSourceFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
   *
   * @schema RedisSpecConfigSourceFlexVolume#secretRef
   */
  readonly secretRef?: RedisSpecConfigSourceFlexVolumeSecretRef;

}

/**
 * Represents a Flocker volume mounted by the Flocker agent. One and only one of datasetName and datasetUUID should be set. Flocker volumes do not support ownership management or SELinux relabeling.
 *
 * @schema RedisSpecConfigSourceFlocker
 */
export interface RedisSpecConfigSourceFlocker {
  /**
   * Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated
   *
   * @schema RedisSpecConfigSourceFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema RedisSpecConfigSourceFlocker#datasetUUID
   */
  readonly datasetUUID?: string;

}

/**
 * Represents a Persistent Disk resource in Google Compute Engine.

A GCE PD must exist before mounting to a container. The disk must also be in the same GCE project and zone as the kubelet. A GCE PD can only be mounted as read/write once or read-only many times. GCE PDs support ownership management and SELinux relabeling.
 *
 * @schema RedisSpecConfigSourceGcePersistentDisk
 */
export interface RedisSpecConfigSourceGcePersistentDisk {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema RedisSpecConfigSourceGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema RedisSpecConfigSourceGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema RedisSpecConfigSourceGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * @schema RedisSpecConfigSourceGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Represents a volume that is populated with the contents of a git repository. Git repo volumes do not support ownership management. Git repo volumes support SELinux relabeling.

DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
 *
 * @schema RedisSpecConfigSourceGitRepo
 */
export interface RedisSpecConfigSourceGitRepo {
  /**
   * Target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
   *
   * @schema RedisSpecConfigSourceGitRepo#directory
   */
  readonly directory?: string;

  /**
   * Repository URL
   *
   * @schema RedisSpecConfigSourceGitRepo#repository
   */
  readonly repository: string;

  /**
   * Commit hash for the specified revision.
   *
   * @schema RedisSpecConfigSourceGitRepo#revision
   */
  readonly revision?: string;

}

/**
 * Represents a Glusterfs mount that lasts the lifetime of a pod. Glusterfs volumes do not support ownership management or SELinux relabeling.
 *
 * @schema RedisSpecConfigSourceGlusterfs
 */
export interface RedisSpecConfigSourceGlusterfs {
  /**
   * EndpointsName is the endpoint name that details Glusterfs topology. More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema RedisSpecConfigSourceGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * Path is the Glusterfs volume path. More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema RedisSpecConfigSourceGlusterfs#path
   */
  readonly path: string;

  /**
   * ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false. More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod
   * @schema RedisSpecConfigSourceGlusterfs#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Represents a host path mapped into a pod. Host path volumes do not support ownership management or SELinux relabeling.
 *
 * @schema RedisSpecConfigSourceHostPath
 */
export interface RedisSpecConfigSourceHostPath {
  /**
   * Path of the directory on the host. If the path is a symlink, it will follow the link to the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema RedisSpecConfigSourceHostPath#path
   */
  readonly path: string;

  /**
   * Type for HostPath Volume Defaults to "" More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema RedisSpecConfigSourceHostPath#type
   */
  readonly type?: string;

}

/**
 * Represents an ISCSI disk. ISCSI volumes can only be mounted as read/write once. ISCSI volumes support ownership management and SELinux relabeling.
 *
 * @schema RedisSpecConfigSourceIscsi
 */
export interface RedisSpecConfigSourceIscsi {
  /**
   * whether support iSCSI Discovery CHAP authentication
   *
   * @schema RedisSpecConfigSourceIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * whether support iSCSI Session CHAP authentication
   *
   * @schema RedisSpecConfigSourceIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
   *
   * @schema RedisSpecConfigSourceIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the connection.
   *
   * @schema RedisSpecConfigSourceIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * Target iSCSI Qualified Name.
   *
   * @schema RedisSpecConfigSourceIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema RedisSpecConfigSourceIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * iSCSI Target Lun number.
   *
   * @schema RedisSpecConfigSourceIscsi#lun
   */
  readonly lun: number;

  /**
   * iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema RedisSpecConfigSourceIscsi#portals
   */
  readonly portals?: string[];

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
   *
   * @default false.
   * @schema RedisSpecConfigSourceIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
   *
   * @schema RedisSpecConfigSourceIscsi#secretRef
   */
  readonly secretRef?: RedisSpecConfigSourceIscsiSecretRef;

  /**
   * iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema RedisSpecConfigSourceIscsi#targetPortal
   */
  readonly targetPortal: string;

}

/**
 * Represents an NFS mount that lasts the lifetime of a pod. NFS volumes do not support ownership management or SELinux relabeling.
 *
 * @schema RedisSpecConfigSourceNfs
 */
export interface RedisSpecConfigSourceNfs {
  /**
   * Path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema RedisSpecConfigSourceNfs#path
   */
  readonly path: string;

  /**
   * ReadOnly here will force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * @schema RedisSpecConfigSourceNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema RedisSpecConfigSourceNfs#server
   */
  readonly server: string;

}

/**
 * PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace. This volume finds the bound PV and mounts that volume for the pod. A PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another type of volume that is owned by someone else (the system).
 *
 * @schema RedisSpecConfigSourcePersistentVolumeClaim
 */
export interface RedisSpecConfigSourcePersistentVolumeClaim {
  /**
   * ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema RedisSpecConfigSourcePersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * Will force the ReadOnly setting in VolumeMounts. Default false.
   *
   * @schema RedisSpecConfigSourcePersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Represents a Photon Controller persistent disk resource.
 *
 * @schema RedisSpecConfigSourcePhotonPersistentDisk
 */
export interface RedisSpecConfigSourcePhotonPersistentDisk {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema RedisSpecConfigSourcePhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * ID that identifies Photon Controller persistent disk
   *
   * @schema RedisSpecConfigSourcePhotonPersistentDisk#pdID
   */
  readonly pdID: string;

}

/**
 * PortworxVolumeSource represents a Portworx volume resource.
 *
 * @schema RedisSpecConfigSourcePortworxVolume
 */
export interface RedisSpecConfigSourcePortworxVolume {
  /**
   * FSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema RedisSpecConfigSourcePortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RedisSpecConfigSourcePortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * VolumeID uniquely identifies a Portworx volume
   *
   * @schema RedisSpecConfigSourcePortworxVolume#volumeID
   */
  readonly volumeID: string;

}

/**
 * Represents a projected volume source
 *
 * @schema RedisSpecConfigSourceProjected
 */
export interface RedisSpecConfigSourceProjected {
  /**
   * Mode bits to use on created files by default. Must be a value between 0 and 0777. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RedisSpecConfigSourceProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * list of volume projections
   *
   * @schema RedisSpecConfigSourceProjected#sources
   */
  readonly sources: RedisSpecConfigSourceProjectedSources[];

}

/**
 * Represents a Quobyte mount that lasts the lifetime of a pod. Quobyte volumes do not support ownership management or SELinux relabeling.
 *
 * @schema RedisSpecConfigSourceQuobyte
 */
export interface RedisSpecConfigSourceQuobyte {
  /**
   * Group to map volume access to Default is no group
   *
   * @default no group
   * @schema RedisSpecConfigSourceQuobyte#group
   */
  readonly group?: string;

  /**
   * ReadOnly here will force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
   *
   * @default false.
   * @schema RedisSpecConfigSourceQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
   *
   * @schema RedisSpecConfigSourceQuobyte#registry
   */
  readonly registry: string;

  /**
   * Tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema RedisSpecConfigSourceQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * User to map volume access to Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema RedisSpecConfigSourceQuobyte#user
   */
  readonly user?: string;

  /**
   * Volume is a string that references an already created Quobyte volume by name.
   *
   * @schema RedisSpecConfigSourceQuobyte#volume
   */
  readonly volume: string;

}

/**
 * Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support ownership management and SELinux relabeling.
 *
 * @schema RedisSpecConfigSourceRbd
 */
export interface RedisSpecConfigSourceRbd {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
   *
   * @schema RedisSpecConfigSourceRbd#fsType
   */
  readonly fsType?: string;

  /**
   * The rados image name. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   *
   * @schema RedisSpecConfigSourceRbd#image
   */
  readonly image: string;

  /**
   * Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   * @schema RedisSpecConfigSourceRbd#keyring
   */
  readonly keyring?: string;

  /**
   * A collection of Ceph monitors. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   *
   * @schema RedisSpecConfigSourceRbd#monitors
   */
  readonly monitors: string[];

  /**
   * The rados pool name. Default is rbd. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   * @schema RedisSpecConfigSourceRbd#pool
   */
  readonly pool?: string;

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   *
   * @default false. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   * @schema RedisSpecConfigSourceRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
   *
   * @schema RedisSpecConfigSourceRbd#secretRef
   */
  readonly secretRef?: RedisSpecConfigSourceRbdSecretRef;

  /**
   * The rados user name. Default is admin. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   * @schema RedisSpecConfigSourceRbd#user
   */
  readonly user?: string;

}

/**
 * ScaleIOVolumeSource represents a persistent ScaleIO volume
 *
 * @schema RedisSpecConfigSourceScaleIo
 */
export interface RedisSpecConfigSourceScaleIo {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
   *
   * @default xfs".
   * @schema RedisSpecConfigSourceScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * The host address of the ScaleIO API Gateway.
   *
   * @schema RedisSpecConfigSourceScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * The name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema RedisSpecConfigSourceScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RedisSpecConfigSourceScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
   *
   * @schema RedisSpecConfigSourceScaleIo#secretRef
   */
  readonly secretRef: RedisSpecConfigSourceScaleIoSecretRef;

  /**
   * Flag to enable/disable SSL communication with Gateway, default false
   *
   * @schema RedisSpecConfigSourceScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned. Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema RedisSpecConfigSourceScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * The ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema RedisSpecConfigSourceScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * The name of the storage system as configured in ScaleIO.
   *
   * @schema RedisSpecConfigSourceScaleIo#system
   */
  readonly system: string;

  /**
   * The name of a volume already created in the ScaleIO system that is associated with this volume source.
   *
   * @schema RedisSpecConfigSourceScaleIo#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Adapts a Secret into a volume.

The contents of the target Secret's Data field will be presented in a volume as files using the keys in the Data field as the file names. Secret volumes support ownership management and SELinux relabeling.
 *
 * @schema RedisSpecConfigSourceSecret
 */
export interface RedisSpecConfigSourceSecret {
  /**
   * Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema RedisSpecConfigSourceSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema RedisSpecConfigSourceSecret#items
   */
  readonly items?: RedisSpecConfigSourceSecretItems[];

  /**
   * Specify whether the Secret or it's keys must be defined
   *
   * @schema RedisSpecConfigSourceSecret#optional
   */
  readonly optional?: boolean;

  /**
   * Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema RedisSpecConfigSourceSecret#secretName
   */
  readonly secretName?: string;

}

/**
 * Represents a StorageOS persistent volume resource.
 *
 * @schema RedisSpecConfigSourceStorageos
 */
export interface RedisSpecConfigSourceStorageos {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema RedisSpecConfigSourceStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema RedisSpecConfigSourceStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
   *
   * @schema RedisSpecConfigSourceStorageos#secretRef
   */
  readonly secretRef?: RedisSpecConfigSourceStorageosSecretRef;

  /**
   * VolumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.
   *
   * @schema RedisSpecConfigSourceStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * VolumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to override the default behaviour. Set to "default" if you are not using namespaces within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema RedisSpecConfigSourceStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;

}

/**
 * Represents a vSphere volume resource.
 *
 * @schema RedisSpecConfigSourceVsphereVolume
 */
export interface RedisSpecConfigSourceVsphereVolume {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema RedisSpecConfigSourceVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema RedisSpecConfigSourceVsphereVolume#storagePolicyID
   */
  readonly storagePolicyID?: string;

  /**
   * Storage Policy Based Management (SPBM) profile name.
   *
   * @schema RedisSpecConfigSourceVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * Path that identifies vSphere volume vmdk
   *
   * @schema RedisSpecConfigSourceVsphereVolume#volumePath
   */
  readonly volumePath: string;

}

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema RedisSpecMonitorEnv
 */
export interface RedisSpecMonitorEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema RedisSpecMonitorEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema RedisSpecMonitorEnv#value
   */
  readonly value?: string;

  /**
   * EnvVarSource represents a source for the value of an EnvVar.
   *
   * @schema RedisSpecMonitorEnv#valueFrom
   */
  readonly valueFrom?: RedisSpecMonitorEnvValueFrom;

}

/**
 * @schema RedisSpecMonitorPrometheus
 */
export interface RedisSpecMonitorPrometheus {
  /**
   * Interval at which metrics should be scraped
   *
   * @schema RedisSpecMonitorPrometheus#interval
   */
  readonly interval?: string;

  /**
   * Labels are key value pairs that is used to select Prometheus instance via ServiceMonitor labels.
   *
   * @schema RedisSpecMonitorPrometheus#labels
   */
  readonly labels?: any;

  /**
   * Namespace of Prometheus. Service monitors will be created in this namespace.
   *
   * @schema RedisSpecMonitorPrometheus#namespace
   */
  readonly namespace?: string;

  /**
   * Port number for the exporter side car.
   *
   * @schema RedisSpecMonitorPrometheus#port
   */
  readonly port?: number;

}

/**
 * ResourceRequirements describes the compute resource requirements.
 *
 * @schema RedisSpecMonitorResources
 */
export interface RedisSpecMonitorResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   *
   * @schema RedisSpecMonitorResources#limits
   */
  readonly limits?: any;

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   *
   * @schema RedisSpecMonitorResources#requests
   */
  readonly requests?: any;

}

/**
 * SecurityContext holds security configuration that will be applied to a container. Some fields are present in both SecurityContext and PodSecurityContext.  When both are set, the values in SecurityContext take precedence.
 *
 * @schema RedisSpecMonitorSecurityContext
 */
export interface RedisSpecMonitorSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN
   *
   * @schema RedisSpecMonitorSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * Adds and removes POSIX capabilities from running containers.
   *
   * @schema RedisSpecMonitorSecurityContext#capabilities
   */
  readonly capabilities?: RedisSpecMonitorSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false.
   *
   * @default false.
   * @schema RedisSpecMonitorSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled.
   *
   * @schema RedisSpecMonitorSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false.
   *
   * @default false.
   * @schema RedisSpecMonitorSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema RedisSpecMonitorSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema RedisSpecMonitorSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema RedisSpecMonitorSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * SELinuxOptions are the labels to be applied to the container
   *
   * @schema RedisSpecMonitorSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: RedisSpecMonitorSecurityContextSeLinuxOptions;

}

/**
 * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
 *
 * @schema RedisSpecPodTemplateController
 */
export interface RedisSpecPodTemplateController {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema RedisSpecPodTemplateController#annotations
   */
  readonly annotations?: any;

}

/**
 * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
 *
 * @schema RedisSpecPodTemplateMetadata
 */
export interface RedisSpecPodTemplateMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema RedisSpecPodTemplateMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema RedisSpecPodTemplateSpec
 */
export interface RedisSpecPodTemplateSpec {
  /**
   * Affinity is a group of affinity scheduling rules.
   *
   * @schema RedisSpecPodTemplateSpec#affinity
   */
  readonly affinity?: RedisSpecPodTemplateSpecAffinity;

  /**
   * Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RedisSpecPodTemplateSpec#args
   */
  readonly args?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema RedisSpecPodTemplateSpec#env
   */
  readonly env?: RedisSpecPodTemplateSpecEnv[];

  /**
   * ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use.
   *
   * @schema RedisSpecPodTemplateSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: RedisSpecPodTemplateSpecImagePullSecrets[];

  /**
   * List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, or Liveness probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema RedisSpecPodTemplateSpec#initContainers
   */
  readonly initContainers?: RedisSpecPodTemplateSpecInitContainers[];

  /**
   * Lifecycle describes actions that the management system should take in response to container lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the container blocks until the action is complete, unless the container process fails, in which case the handler is aborted.
   *
   * @schema RedisSpecPodTemplateSpec#lifecycle
   */
  readonly lifecycle?: RedisSpecPodTemplateSpecLifecycle;

  /**
   * Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
   *
   * @schema RedisSpecPodTemplateSpec#livenessProbe
   */
  readonly livenessProbe?: RedisSpecPodTemplateSpecLivenessProbe;

  /**
   * NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   *
   * @schema RedisSpecPodTemplateSpec#nodeSelector
   */
  readonly nodeSelector?: any;

  /**
   * The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.
   *
   * @schema RedisSpecPodTemplateSpec#priority
   */
  readonly priority?: number;

  /**
   * If specified, indicates the pod's priority. "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.
   *
   * @schema RedisSpecPodTemplateSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
   *
   * @schema RedisSpecPodTemplateSpec#readinessProbe
   */
  readonly readinessProbe?: RedisSpecPodTemplateSpecReadinessProbe;

  /**
   * ResourceRequirements describes the compute resource requirements.
   *
   * @schema RedisSpecPodTemplateSpec#resources
   */
  readonly resources?: RedisSpecPodTemplateSpecResources;

  /**
   * If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.
   *
   * @schema RedisSpecPodTemplateSpec#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * PodSecurityContext holds pod-level security attributes and common container settings. Some fields are also present in container.securityContext.  Field values of container.securityContext take precedence over field values of PodSecurityContext.
   *
   * @schema RedisSpecPodTemplateSpec#securityContext
   */
  readonly securityContext?: RedisSpecPodTemplateSpecSecurityContext;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
   *
   * @schema RedisSpecPodTemplateSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * If specified, the pod's tolerations.
   *
   * @schema RedisSpecPodTemplateSpec#tolerations
   */
  readonly tolerations?: RedisSpecPodTemplateSpecTolerations[];

}

/**
 * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
 *
 * @schema RedisSpecServiceTemplateMetadata
 */
export interface RedisSpecServiceTemplateMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema RedisSpecServiceTemplateMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * ServiceSpec describes the attributes that a user creates on a service.
 *
 * @schema RedisSpecServiceTemplateSpec
 */
export interface RedisSpecServiceTemplateSpec {
  /**
   * clusterIP is the IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are "None", empty string (""), or a valid IP address. "None" can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   *
   * @schema RedisSpecServiceTemplateSpec#clusterIP
   */
  readonly clusterIP?: string;

  /**
   * externalIPs is a list of IP addresses for which nodes in the cluster will also accept traffic for this service.  These IPs are not managed by Kubernetes.  The user is responsible for ensuring that traffic arrives at a node with this IP.  A common example is external load-balancers that are not part of the Kubernetes system.
   *
   * @schema RedisSpecServiceTemplateSpec#externalIPs
   */
  readonly externalIPs?: string[];

  /**
   * externalTrafficPolicy denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints. "Local" preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading. "Cluster" obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading.
   *
   * @schema RedisSpecServiceTemplateSpec#externalTrafficPolicy
   */
  readonly externalTrafficPolicy?: string;

  /**
   * healthCheckNodePort specifies the healthcheck nodePort for the service. If not specified, HealthCheckNodePort is created by the service api backend with the allocated nodePort. Will use user-specified nodePort value if specified by the client. Only effects when Type is set to LoadBalancer and ExternalTrafficPolicy is set to Local.
   *
   * @schema RedisSpecServiceTemplateSpec#healthCheckNodePort
   */
  readonly healthCheckNodePort?: number;

  /**
   * Only applies to Service Type: LoadBalancer LoadBalancer will get created with the IP specified in this field. This feature depends on whether the underlying cloud-provider supports specifying the loadBalancerIP when a load balancer is created. This field will be ignored if the cloud-provider does not support the feature.
   *
   * @schema RedisSpecServiceTemplateSpec#loadBalancerIP
   */
  readonly loadBalancerIP?: string;

  /**
   * If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature." More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/
   *
   * @schema RedisSpecServiceTemplateSpec#loadBalancerSourceRanges
   */
  readonly loadBalancerSourceRanges?: string[];

  /**
   * The list of ports that are exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   *
   * @schema RedisSpecServiceTemplateSpec#ports
   */
  readonly ports?: RedisSpecServiceTemplateSpecPorts[];

  /**
   * type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. "ExternalName" maps to the specified externalName. "ClusterIP" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a stable IP. "NodePort" builds on ClusterIP and allocates a port on every node which routes to the clusterIP. "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the clusterIP. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types
   *
   * @default ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. "ExternalName" maps to the specified externalName. "ClusterIP" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a stable IP. "NodePort" builds on ClusterIP and allocates a port on every node which routes to the clusterIP. "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the clusterIP. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types
   * @schema RedisSpecServiceTemplateSpec#type
   */
  readonly type?: string;

}

/**
 * TypedLocalObjectReference contains enough information to let you locate the typed referenced object inside the same namespace.
 *
 * @schema RedisSpecStorageDataSource
 */
export interface RedisSpecStorageDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema RedisSpecStorageDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema RedisSpecStorageDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema RedisSpecStorageDataSource#name
   */
  readonly name: string;

}

/**
 * ResourceRequirements describes the compute resource requirements.
 *
 * @schema RedisSpecStorageResources
 */
export interface RedisSpecStorageResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   *
   * @schema RedisSpecStorageResources#limits
   */
  readonly limits?: any;

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   *
   * @schema RedisSpecStorageResources#requests
   */
  readonly requests?: any;

}

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema RedisSpecStorageSelector
 */
export interface RedisSpecStorageSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RedisSpecStorageSelector#matchExpressions
   */
  readonly matchExpressions?: RedisSpecStorageSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RedisSpecStorageSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * RollingUpdateStatefulSetStrategy is used to communicate parameter for RollingUpdateStatefulSetStrategyType.
 *
 * @schema RedisSpecUpdateStrategyRollingUpdate
 */
export interface RedisSpecUpdateStrategyRollingUpdate {
  /**
   * Partition indicates the ordinal at which the StatefulSet should be partitioned. Default value is 0.
   *
   * @schema RedisSpecUpdateStrategyRollingUpdate#partition
   */
  readonly partition?: number;

}

/**
 * StatusDetails is a set of additional properties that MAY be set by the server to provide additional information about a response. The Reason field of a Status object defines what attributes will be set. Clients must ignore fields that do not match the defined type of each attribute, and should assume that any attribute may be empty, invalid, or under defined.
 *
 * @schema RedisMetadataInitializersResultDetails
 */
export interface RedisMetadataInitializersResultDetails {
  /**
   * The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
   *
   * @schema RedisMetadataInitializersResultDetails#causes
   */
  readonly causes?: RedisMetadataInitializersResultDetailsCauses[];

  /**
   * The group attribute of the resource associated with the status StatusReason.
   *
   * @schema RedisMetadataInitializersResultDetails#group
   */
  readonly group?: string;

  /**
   * The kind attribute of the resource associated with the status StatusReason. On some operations may differ from the requested resource Kind. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
   *
   * @schema RedisMetadataInitializersResultDetails#kind
   */
  readonly kind?: string;

  /**
   * The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
   *
   * @schema RedisMetadataInitializersResultDetails#name
   */
  readonly name?: string;

  /**
   * If specified, the time in seconds before the operation should be retried. Some errors may indicate the client must take an alternate action - for those errors this field may indicate how long to wait before taking the alternate action.
   *
   * @schema RedisMetadataInitializersResultDetails#retryAfterSeconds
   */
  readonly retryAfterSeconds?: number;

  /**
   * UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
   *
   * @schema RedisMetadataInitializersResultDetails#uid
   */
  readonly uid?: string;

}

/**
 * ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
 *
 * @schema RedisMetadataInitializersResultMetadata
 */
export interface RedisMetadataInitializersResultMetadata {
  /**
   * continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message.
   *
   * @schema RedisMetadataInitializersResultMetadata#continue
   */
  readonly continue?: string;

  /**
   * String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
   *
   * @schema RedisMetadataInitializersResultMetadata#resourceVersion
   */
  readonly resourceVersion?: string;

  /**
   * selfLink is a URL representing this object. Populated by the system. Read-only.
   *
   * @schema RedisMetadataInitializersResultMetadata#selfLink
   */
  readonly selfLink?: string;

}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema RedisSpecConfigSourceCephfsSecretRef
 */
export interface RedisSpecConfigSourceCephfsSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema RedisSpecConfigSourceCephfsSecretRef#name
   */
  readonly name?: string;

}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema RedisSpecConfigSourceCinderSecretRef
 */
export interface RedisSpecConfigSourceCinderSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema RedisSpecConfigSourceCinderSecretRef#name
   */
  readonly name?: string;

}

/**
 * Maps a string key to a path within a volume.
 *
 * @schema RedisSpecConfigSourceConfigMapItems
 */
export interface RedisSpecConfigSourceConfigMapItems {
  /**
   * The key to project.
   *
   * @schema RedisSpecConfigSourceConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RedisSpecConfigSourceConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema RedisSpecConfigSourceConfigMapItems#path
   */
  readonly path: string;

}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema RedisSpecConfigSourceCsiNodePublishSecretRef
 */
export interface RedisSpecConfigSourceCsiNodePublishSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema RedisSpecConfigSourceCsiNodePublishSecretRef#name
   */
  readonly name?: string;

}

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema RedisSpecConfigSourceDownwardApiItems
 */
export interface RedisSpecConfigSourceDownwardApiItems {
  /**
   * ObjectFieldSelector selects an APIVersioned field of an object.
   *
   * @schema RedisSpecConfigSourceDownwardApiItems#fieldRef
   */
  readonly fieldRef?: RedisSpecConfigSourceDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RedisSpecConfigSourceDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema RedisSpecConfigSourceDownwardApiItems#path
   */
  readonly path: string;

  /**
   * ResourceFieldSelector represents container resources (cpu, memory) and their output format
   *
   * @schema RedisSpecConfigSourceDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: RedisSpecConfigSourceDownwardApiItemsResourceFieldRef;

}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema RedisSpecConfigSourceFlexVolumeSecretRef
 */
export interface RedisSpecConfigSourceFlexVolumeSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema RedisSpecConfigSourceFlexVolumeSecretRef#name
   */
  readonly name?: string;

}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema RedisSpecConfigSourceIscsiSecretRef
 */
export interface RedisSpecConfigSourceIscsiSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema RedisSpecConfigSourceIscsiSecretRef#name
   */
  readonly name?: string;

}

/**
 * Projection that may be projected along with other supported volume types
 *
 * @schema RedisSpecConfigSourceProjectedSources
 */
export interface RedisSpecConfigSourceProjectedSources {
  /**
   * Adapts a ConfigMap into a projected volume.

The contents of the target ConfigMap's Data field will be presented in a projected volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. Note that this is identical to a configmap volume source without the default mode.
   *
   * @schema RedisSpecConfigSourceProjectedSources#configMap
   */
  readonly configMap?: RedisSpecConfigSourceProjectedSourcesConfigMap;

  /**
   * Represents downward API info for projecting into a projected volume. Note that this is identical to a downwardAPI volume source without the default mode.
   *
   * @schema RedisSpecConfigSourceProjectedSources#downwardAPI
   */
  readonly downwardAPI?: RedisSpecConfigSourceProjectedSourcesDownwardApi;

  /**
   * Adapts a secret into a projected volume.

The contents of the target Secret's Data field will be presented in a projected volume as files using the keys in the Data field as the file names. Note that this is identical to a secret volume source without the default mode.
   *
   * @schema RedisSpecConfigSourceProjectedSources#secret
   */
  readonly secret?: RedisSpecConfigSourceProjectedSourcesSecret;

  /**
   * ServiceAccountTokenProjection represents a projected service account token volume. This projection can be used to insert a service account token into the pods runtime filesystem for use against APIs (Kubernetes API Server or otherwise).
   *
   * @schema RedisSpecConfigSourceProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: RedisSpecConfigSourceProjectedSourcesServiceAccountToken;

}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema RedisSpecConfigSourceRbdSecretRef
 */
export interface RedisSpecConfigSourceRbdSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema RedisSpecConfigSourceRbdSecretRef#name
   */
  readonly name?: string;

}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema RedisSpecConfigSourceScaleIoSecretRef
 */
export interface RedisSpecConfigSourceScaleIoSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema RedisSpecConfigSourceScaleIoSecretRef#name
   */
  readonly name?: string;

}

/**
 * Maps a string key to a path within a volume.
 *
 * @schema RedisSpecConfigSourceSecretItems
 */
export interface RedisSpecConfigSourceSecretItems {
  /**
   * The key to project.
   *
   * @schema RedisSpecConfigSourceSecretItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RedisSpecConfigSourceSecretItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema RedisSpecConfigSourceSecretItems#path
   */
  readonly path: string;

}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema RedisSpecConfigSourceStorageosSecretRef
 */
export interface RedisSpecConfigSourceStorageosSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema RedisSpecConfigSourceStorageosSecretRef#name
   */
  readonly name?: string;

}

/**
 * EnvVarSource represents a source for the value of an EnvVar.
 *
 * @schema RedisSpecMonitorEnvValueFrom
 */
export interface RedisSpecMonitorEnvValueFrom {
  /**
   * Selects a key from a ConfigMap.
   *
   * @schema RedisSpecMonitorEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: RedisSpecMonitorEnvValueFromConfigMapKeyRef;

  /**
   * ObjectFieldSelector selects an APIVersioned field of an object.
   *
   * @schema RedisSpecMonitorEnvValueFrom#fieldRef
   */
  readonly fieldRef?: RedisSpecMonitorEnvValueFromFieldRef;

  /**
   * ResourceFieldSelector represents container resources (cpu, memory) and their output format
   *
   * @schema RedisSpecMonitorEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: RedisSpecMonitorEnvValueFromResourceFieldRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema RedisSpecMonitorEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: RedisSpecMonitorEnvValueFromSecretKeyRef;

}

/**
 * Adds and removes POSIX capabilities from running containers.
 *
 * @schema RedisSpecMonitorSecurityContextCapabilities
 */
export interface RedisSpecMonitorSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema RedisSpecMonitorSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema RedisSpecMonitorSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * SELinuxOptions are the labels to be applied to the container
 *
 * @schema RedisSpecMonitorSecurityContextSeLinuxOptions
 */
export interface RedisSpecMonitorSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema RedisSpecMonitorSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema RedisSpecMonitorSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema RedisSpecMonitorSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema RedisSpecMonitorSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Affinity is a group of affinity scheduling rules.
 *
 * @schema RedisSpecPodTemplateSpecAffinity
 */
export interface RedisSpecPodTemplateSpecAffinity {
  /**
   * Node affinity is a group of node affinity scheduling rules.
   *
   * @schema RedisSpecPodTemplateSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: RedisSpecPodTemplateSpecAffinityNodeAffinity;

  /**
   * Pod affinity is a group of inter pod affinity scheduling rules.
   *
   * @schema RedisSpecPodTemplateSpecAffinity#podAffinity
   */
  readonly podAffinity?: RedisSpecPodTemplateSpecAffinityPodAffinity;

  /**
   * Pod anti affinity is a group of inter pod anti affinity scheduling rules.
   *
   * @schema RedisSpecPodTemplateSpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: RedisSpecPodTemplateSpecAffinityPodAntiAffinity;

}

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema RedisSpecPodTemplateSpecEnv
 */
export interface RedisSpecPodTemplateSpecEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema RedisSpecPodTemplateSpecEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema RedisSpecPodTemplateSpecEnv#value
   */
  readonly value?: string;

  /**
   * EnvVarSource represents a source for the value of an EnvVar.
   *
   * @schema RedisSpecPodTemplateSpecEnv#valueFrom
   */
  readonly valueFrom?: RedisSpecPodTemplateSpecEnvValueFrom;

}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema RedisSpecPodTemplateSpecImagePullSecrets
 */
export interface RedisSpecPodTemplateSpecImagePullSecrets {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema RedisSpecPodTemplateSpecImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * A single application container that you want to run within a pod.
 *
 * @schema RedisSpecPodTemplateSpecInitContainers
 */
export interface RedisSpecPodTemplateSpecInitContainers {
  /**
   * Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RedisSpecPodTemplateSpecInitContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema RedisSpecPodTemplateSpecInitContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema RedisSpecPodTemplateSpecInitContainers#env
   */
  readonly env?: RedisSpecPodTemplateSpecInitContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema RedisSpecPodTemplateSpecInitContainers#envFrom
   */
  readonly envFrom?: RedisSpecPodTemplateSpecInitContainersEnvFrom[];

  /**
   * Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema RedisSpecPodTemplateSpecInitContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema RedisSpecPodTemplateSpecInitContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Lifecycle describes actions that the management system should take in response to container lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the container blocks until the action is complete, unless the container process fails, in which case the handler is aborted.
   *
   * @schema RedisSpecPodTemplateSpecInitContainers#lifecycle
   */
  readonly lifecycle?: RedisSpecPodTemplateSpecInitContainersLifecycle;

  /**
   * Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
   *
   * @schema RedisSpecPodTemplateSpecInitContainers#livenessProbe
   */
  readonly livenessProbe?: RedisSpecPodTemplateSpecInitContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
   *
   * @schema RedisSpecPodTemplateSpecInitContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
   *
   * @schema RedisSpecPodTemplateSpecInitContainers#ports
   */
  readonly ports?: RedisSpecPodTemplateSpecInitContainersPorts[];

  /**
   * Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
   *
   * @schema RedisSpecPodTemplateSpecInitContainers#readinessProbe
   */
  readonly readinessProbe?: RedisSpecPodTemplateSpecInitContainersReadinessProbe;

  /**
   * ResourceRequirements describes the compute resource requirements.
   *
   * @schema RedisSpecPodTemplateSpecInitContainers#resources
   */
  readonly resources?: RedisSpecPodTemplateSpecInitContainersResources;

  /**
   * SecurityContext holds security configuration that will be applied to a container. Some fields are present in both SecurityContext and PodSecurityContext.  When both are set, the values in SecurityContext take precedence.
   *
   * @schema RedisSpecPodTemplateSpecInitContainers#securityContext
   */
  readonly securityContext?: RedisSpecPodTemplateSpecInitContainersSecurityContext;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema RedisSpecPodTemplateSpecInitContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema RedisSpecPodTemplateSpecInitContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema RedisSpecPodTemplateSpecInitContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema RedisSpecPodTemplateSpecInitContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema RedisSpecPodTemplateSpecInitContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container. This is a beta feature.
   *
   * @schema RedisSpecPodTemplateSpecInitContainers#volumeDevices
   */
  readonly volumeDevices?: RedisSpecPodTemplateSpecInitContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Cannot be updated.
   *
   * @schema RedisSpecPodTemplateSpecInitContainers#volumeMounts
   */
  readonly volumeMounts?: RedisSpecPodTemplateSpecInitContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema RedisSpecPodTemplateSpecInitContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Lifecycle describes actions that the management system should take in response to container lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the container blocks until the action is complete, unless the container process fails, in which case the handler is aborted.
 *
 * @schema RedisSpecPodTemplateSpecLifecycle
 */
export interface RedisSpecPodTemplateSpecLifecycle {
  /**
   * Handler defines a specific action that should be taken
   *
   * @schema RedisSpecPodTemplateSpecLifecycle#postStart
   */
  readonly postStart?: RedisSpecPodTemplateSpecLifecyclePostStart;

  /**
   * Handler defines a specific action that should be taken
   *
   * @schema RedisSpecPodTemplateSpecLifecycle#preStop
   */
  readonly preStop?: RedisSpecPodTemplateSpecLifecyclePreStop;

}

/**
 * Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
 *
 * @schema RedisSpecPodTemplateSpecLivenessProbe
 */
export interface RedisSpecPodTemplateSpecLivenessProbe {
  /**
   * ExecAction describes a "run in container" action.
   *
   * @schema RedisSpecPodTemplateSpecLivenessProbe#exec
   */
  readonly exec?: RedisSpecPodTemplateSpecLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RedisSpecPodTemplateSpecLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * HTTPGetAction describes an action based on HTTP Get requests.
   *
   * @schema RedisSpecPodTemplateSpecLivenessProbe#httpGet
   */
  readonly httpGet?: RedisSpecPodTemplateSpecLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RedisSpecPodTemplateSpecLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RedisSpecPodTemplateSpecLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema RedisSpecPodTemplateSpecLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocketAction describes an action based on opening a socket
   *
   * @schema RedisSpecPodTemplateSpecLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: RedisSpecPodTemplateSpecLivenessProbeTcpSocket;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RedisSpecPodTemplateSpecLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
 *
 * @schema RedisSpecPodTemplateSpecReadinessProbe
 */
export interface RedisSpecPodTemplateSpecReadinessProbe {
  /**
   * ExecAction describes a "run in container" action.
   *
   * @schema RedisSpecPodTemplateSpecReadinessProbe#exec
   */
  readonly exec?: RedisSpecPodTemplateSpecReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RedisSpecPodTemplateSpecReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * HTTPGetAction describes an action based on HTTP Get requests.
   *
   * @schema RedisSpecPodTemplateSpecReadinessProbe#httpGet
   */
  readonly httpGet?: RedisSpecPodTemplateSpecReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RedisSpecPodTemplateSpecReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RedisSpecPodTemplateSpecReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema RedisSpecPodTemplateSpecReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocketAction describes an action based on opening a socket
   *
   * @schema RedisSpecPodTemplateSpecReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: RedisSpecPodTemplateSpecReadinessProbeTcpSocket;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RedisSpecPodTemplateSpecReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * ResourceRequirements describes the compute resource requirements.
 *
 * @schema RedisSpecPodTemplateSpecResources
 */
export interface RedisSpecPodTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   *
   * @schema RedisSpecPodTemplateSpecResources#limits
   */
  readonly limits?: any;

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   *
   * @schema RedisSpecPodTemplateSpecResources#requests
   */
  readonly requests?: any;

}

/**
 * PodSecurityContext holds pod-level security attributes and common container settings. Some fields are also present in container.securityContext.  Field values of container.securityContext take precedence over field values of PodSecurityContext.
 *
 * @schema RedisSpecPodTemplateSpecSecurityContext
 */
export interface RedisSpecPodTemplateSpecSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:

1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----

If unset, the Kubelet will not modify the ownership and permissions of any volume.
   *
   * @schema RedisSpecPodTemplateSpecSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
   *
   * @schema RedisSpecPodTemplateSpecSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema RedisSpecPodTemplateSpecSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
   *
   * @default user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
   * @schema RedisSpecPodTemplateSpecSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * SELinuxOptions are the labels to be applied to the container
   *
   * @schema RedisSpecPodTemplateSpecSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: RedisSpecPodTemplateSpecSecurityContextSeLinuxOptions;

  /**
   * A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container.
   *
   * @schema RedisSpecPodTemplateSpecSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch.
   *
   * @schema RedisSpecPodTemplateSpecSecurityContext#sysctls
   */
  readonly sysctls?: RedisSpecPodTemplateSpecSecurityContextSysctls[];

}

/**
 * The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema RedisSpecPodTemplateSpecTolerations
 */
export interface RedisSpecPodTemplateSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema RedisSpecPodTemplateSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema RedisSpecPodTemplateSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   *
   * @default Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   * @schema RedisSpecPodTemplateSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema RedisSpecPodTemplateSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema RedisSpecPodTemplateSpecTolerations#value
   */
  readonly value?: string;

}

/**
 * ServicePort contains information on service's port.
 *
 * @schema RedisSpecServiceTemplateSpecPorts
 */
export interface RedisSpecServiceTemplateSpecPorts {
  /**
   * The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the 'Name' field in EndpointPort objects. Optional if only one ServicePort is defined on this service.
   *
   * @schema RedisSpecServiceTemplateSpecPorts#name
   */
  readonly name?: string;

  /**
   * The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
   *
   * @default to auto-allocate a port if the ServiceType of this Service requires one. More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
   * @schema RedisSpecServiceTemplateSpecPorts#nodePort
   */
  readonly nodePort?: number;

  /**
   * The port that will be exposed by this service.
   *
   * @schema RedisSpecServiceTemplateSpecPorts#port
   */
  readonly port: number;

}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RedisSpecStorageSelectorMatchExpressions
 */
export interface RedisSpecStorageSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RedisSpecStorageSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RedisSpecStorageSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RedisSpecStorageSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * StatusCause provides more information about an api.Status failure, including cases when multiple errors are encountered.
 *
 * @schema RedisMetadataInitializersResultDetailsCauses
 */
export interface RedisMetadataInitializersResultDetailsCauses {
  /**
   * The field of the resource that has caused this error, as named by its JSON serialization. May include dot and postfix notation for nested attributes. Arrays are zero-indexed.  Fields may appear more than once in an array of causes due to fields having multiple errors. Optional.

Examples:
  "name" - the field "name" on the current resource
  "items[0].name" - the field "name" on the first array entry in "items"
   *
   * @schema RedisMetadataInitializersResultDetailsCauses#field
   */
  readonly field?: string;

  /**
   * A human-readable description of the cause of the error.  This field may be presented as-is to a reader.
   *
   * @schema RedisMetadataInitializersResultDetailsCauses#message
   */
  readonly message?: string;

  /**
   * A machine-readable description of the cause of the error. If this value is empty there is no information available.
   *
   * @schema RedisMetadataInitializersResultDetailsCauses#reason
   */
  readonly reason?: string;

}

/**
 * ObjectFieldSelector selects an APIVersioned field of an object.
 *
 * @schema RedisSpecConfigSourceDownwardApiItemsFieldRef
 */
export interface RedisSpecConfigSourceDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RedisSpecConfigSourceDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RedisSpecConfigSourceDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * ResourceFieldSelector represents container resources (cpu, memory) and their output format
 *
 * @schema RedisSpecConfigSourceDownwardApiItemsResourceFieldRef
 */
export interface RedisSpecConfigSourceDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RedisSpecConfigSourceDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and Int64() accessors.

The serialization format is:

<quantity>        ::= <signedNumber><suffix>
  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
<digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
<decimalSI>       ::= m | "" | k | M | G | T | P | E
  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
<decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>

No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:
  a. No precision is lost
  b. No fractional digits will be emitted
  c. The exponent (or suffix) is as large as possible.
The sign will be omitted unless the number is negative.

Examples:
  1.5 will be serialized as "1500m"
  1.5Gi will be serialized as "1536Mi"

Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.
   *
   * @schema RedisSpecConfigSourceDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: string;

  /**
   * Required: resource to select
   *
   * @schema RedisSpecConfigSourceDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Adapts a ConfigMap into a projected volume.

The contents of the target ConfigMap's Data field will be presented in a projected volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. Note that this is identical to a configmap volume source without the default mode.
 *
 * @schema RedisSpecConfigSourceProjectedSourcesConfigMap
 */
export interface RedisSpecConfigSourceProjectedSourcesConfigMap {
  /**
   * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema RedisSpecConfigSourceProjectedSourcesConfigMap#items
   */
  readonly items?: RedisSpecConfigSourceProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema RedisSpecConfigSourceProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or it's keys must be defined
   *
   * @schema RedisSpecConfigSourceProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Represents downward API info for projecting into a projected volume. Note that this is identical to a downwardAPI volume source without the default mode.
 *
 * @schema RedisSpecConfigSourceProjectedSourcesDownwardApi
 */
export interface RedisSpecConfigSourceProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema RedisSpecConfigSourceProjectedSourcesDownwardApi#items
   */
  readonly items?: RedisSpecConfigSourceProjectedSourcesDownwardApiItems[];

}

/**
 * Adapts a secret into a projected volume.

The contents of the target Secret's Data field will be presented in a projected volume as files using the keys in the Data field as the file names. Note that this is identical to a secret volume source without the default mode.
 *
 * @schema RedisSpecConfigSourceProjectedSourcesSecret
 */
export interface RedisSpecConfigSourceProjectedSourcesSecret {
  /**
   * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema RedisSpecConfigSourceProjectedSourcesSecret#items
   */
  readonly items?: RedisSpecConfigSourceProjectedSourcesSecretItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema RedisSpecConfigSourceProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema RedisSpecConfigSourceProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * ServiceAccountTokenProjection represents a projected service account token volume. This projection can be used to insert a service account token into the pods runtime filesystem for use against APIs (Kubernetes API Server or otherwise).
 *
 * @schema RedisSpecConfigSourceProjectedSourcesServiceAccountToken
 */
export interface RedisSpecConfigSourceProjectedSourcesServiceAccountToken {
  /**
   * Audience is the intended audience of the token. A recipient of a token must identify itself with an identifier specified in the audience of the token, and otherwise should reject the token. The audience defaults to the identifier of the apiserver.
   *
   * @schema RedisSpecConfigSourceProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * ExpirationSeconds is the requested duration of validity of the service account token. As the token approaches expiration, the kubelet volume plugin will proactively rotate the service account token. The kubelet will start trying to rotate the token if the token is older than 80 percent of its time to live or if the token is older than 24 hours.Defaults to 1 hour and must be at least 10 minutes.
   *
   * @default 1 hour and must be at least 10 minutes.
   * @schema RedisSpecConfigSourceProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * Path is the path relative to the mount point of the file to project the token into.
   *
   * @schema RedisSpecConfigSourceProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;

}

/**
 * Selects a key from a ConfigMap.
 *
 * @schema RedisSpecMonitorEnvValueFromConfigMapKeyRef
 */
export interface RedisSpecMonitorEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema RedisSpecMonitorEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema RedisSpecMonitorEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or it's key must be defined
   *
   * @schema RedisSpecMonitorEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * ObjectFieldSelector selects an APIVersioned field of an object.
 *
 * @schema RedisSpecMonitorEnvValueFromFieldRef
 */
export interface RedisSpecMonitorEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RedisSpecMonitorEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RedisSpecMonitorEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * ResourceFieldSelector represents container resources (cpu, memory) and their output format
 *
 * @schema RedisSpecMonitorEnvValueFromResourceFieldRef
 */
export interface RedisSpecMonitorEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RedisSpecMonitorEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and Int64() accessors.

The serialization format is:

<quantity>        ::= <signedNumber><suffix>
  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
<digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
<decimalSI>       ::= m | "" | k | M | G | T | P | E
  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
<decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>

No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:
  a. No precision is lost
  b. No fractional digits will be emitted
  c. The exponent (or suffix) is as large as possible.
The sign will be omitted unless the number is negative.

Examples:
  1.5 will be serialized as "1500m"
  1.5Gi will be serialized as "1536Mi"

Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.
   *
   * @schema RedisSpecMonitorEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: string;

  /**
   * Required: resource to select
   *
   * @schema RedisSpecMonitorEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema RedisSpecMonitorEnvValueFromSecretKeyRef
 */
export interface RedisSpecMonitorEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RedisSpecMonitorEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema RedisSpecMonitorEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or it's key must be defined
   *
   * @schema RedisSpecMonitorEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Node affinity is a group of node affinity scheduling rules.
 *
 * @schema RedisSpecPodTemplateSpecAffinityNodeAffinity
 */
export interface RedisSpecPodTemplateSpecAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
   *
   * @schema RedisSpecPodTemplateSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: RedisSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * A node selector represents the union of the results of one or more label queries over a set of nodes; that is, it represents the OR of the selectors represented by the node selector terms.
   *
   * @schema RedisSpecPodTemplateSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: RedisSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Pod affinity is a group of inter pod affinity scheduling rules.
 *
 * @schema RedisSpecPodTemplateSpecAffinityPodAffinity
 */
export interface RedisSpecPodTemplateSpecAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: RedisSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: RedisSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Pod anti affinity is a group of inter pod anti affinity scheduling rules.
 *
 * @schema RedisSpecPodTemplateSpecAffinityPodAntiAffinity
 */
export interface RedisSpecPodTemplateSpecAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: RedisSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: RedisSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * EnvVarSource represents a source for the value of an EnvVar.
 *
 * @schema RedisSpecPodTemplateSpecEnvValueFrom
 */
export interface RedisSpecPodTemplateSpecEnvValueFrom {
  /**
   * Selects a key from a ConfigMap.
   *
   * @schema RedisSpecPodTemplateSpecEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: RedisSpecPodTemplateSpecEnvValueFromConfigMapKeyRef;

  /**
   * ObjectFieldSelector selects an APIVersioned field of an object.
   *
   * @schema RedisSpecPodTemplateSpecEnvValueFrom#fieldRef
   */
  readonly fieldRef?: RedisSpecPodTemplateSpecEnvValueFromFieldRef;

  /**
   * ResourceFieldSelector represents container resources (cpu, memory) and their output format
   *
   * @schema RedisSpecPodTemplateSpecEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: RedisSpecPodTemplateSpecEnvValueFromResourceFieldRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema RedisSpecPodTemplateSpecEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: RedisSpecPodTemplateSpecEnvValueFromSecretKeyRef;

}

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema RedisSpecPodTemplateSpecInitContainersEnv
 */
export interface RedisSpecPodTemplateSpecInitContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema RedisSpecPodTemplateSpecInitContainersEnv#value
   */
  readonly value?: string;

  /**
   * EnvVarSource represents a source for the value of an EnvVar.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersEnv#valueFrom
   */
  readonly valueFrom?: RedisSpecPodTemplateSpecInitContainersEnvValueFrom;

}

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema RedisSpecPodTemplateSpecInitContainersEnvFrom
 */
export interface RedisSpecPodTemplateSpecInitContainersEnvFrom {
  /**
   * ConfigMapEnvSource selects a ConfigMap to populate the environment variables with.

The contents of the target ConfigMap's Data field will represent the key-value pairs as environment variables.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: RedisSpecPodTemplateSpecInitContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * SecretEnvSource selects a Secret to populate the environment variables with.

The contents of the target Secret's Data field will represent the key-value pairs as environment variables.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersEnvFrom#secretRef
   */
  readonly secretRef?: RedisSpecPodTemplateSpecInitContainersEnvFromSecretRef;

}

/**
 * Lifecycle describes actions that the management system should take in response to container lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the container blocks until the action is complete, unless the container process fails, in which case the handler is aborted.
 *
 * @schema RedisSpecPodTemplateSpecInitContainersLifecycle
 */
export interface RedisSpecPodTemplateSpecInitContainersLifecycle {
  /**
   * Handler defines a specific action that should be taken
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLifecycle#postStart
   */
  readonly postStart?: RedisSpecPodTemplateSpecInitContainersLifecyclePostStart;

  /**
   * Handler defines a specific action that should be taken
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLifecycle#preStop
   */
  readonly preStop?: RedisSpecPodTemplateSpecInitContainersLifecyclePreStop;

}

/**
 * Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
 *
 * @schema RedisSpecPodTemplateSpecInitContainersLivenessProbe
 */
export interface RedisSpecPodTemplateSpecInitContainersLivenessProbe {
  /**
   * ExecAction describes a "run in container" action.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLivenessProbe#exec
   */
  readonly exec?: RedisSpecPodTemplateSpecInitContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RedisSpecPodTemplateSpecInitContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * HTTPGetAction describes an action based on HTTP Get requests.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLivenessProbe#httpGet
   */
  readonly httpGet?: RedisSpecPodTemplateSpecInitContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RedisSpecPodTemplateSpecInitContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema RedisSpecPodTemplateSpecInitContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocketAction describes an action based on opening a socket
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: RedisSpecPodTemplateSpecInitContainersLivenessProbeTcpSocket;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RedisSpecPodTemplateSpecInitContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema RedisSpecPodTemplateSpecInitContainersPorts
 */
export interface RedisSpecPodTemplateSpecInitContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersPorts#hostIP
   */
  readonly hostIP?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema RedisSpecPodTemplateSpecInitContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
 *
 * @schema RedisSpecPodTemplateSpecInitContainersReadinessProbe
 */
export interface RedisSpecPodTemplateSpecInitContainersReadinessProbe {
  /**
   * ExecAction describes a "run in container" action.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersReadinessProbe#exec
   */
  readonly exec?: RedisSpecPodTemplateSpecInitContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema RedisSpecPodTemplateSpecInitContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * HTTPGetAction describes an action based on HTTP Get requests.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersReadinessProbe#httpGet
   */
  readonly httpGet?: RedisSpecPodTemplateSpecInitContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema RedisSpecPodTemplateSpecInitContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema RedisSpecPodTemplateSpecInitContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema RedisSpecPodTemplateSpecInitContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocketAction describes an action based on opening a socket
   *
   * @schema RedisSpecPodTemplateSpecInitContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: RedisSpecPodTemplateSpecInitContainersReadinessProbeTcpSocket;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema RedisSpecPodTemplateSpecInitContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * ResourceRequirements describes the compute resource requirements.
 *
 * @schema RedisSpecPodTemplateSpecInitContainersResources
 */
export interface RedisSpecPodTemplateSpecInitContainersResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   *
   * @schema RedisSpecPodTemplateSpecInitContainersResources#limits
   */
  readonly limits?: any;

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   *
   * @schema RedisSpecPodTemplateSpecInitContainersResources#requests
   */
  readonly requests?: any;

}

/**
 * SecurityContext holds security configuration that will be applied to a container. Some fields are present in both SecurityContext and PodSecurityContext.  When both are set, the values in SecurityContext take precedence.
 *
 * @schema RedisSpecPodTemplateSpecInitContainersSecurityContext
 */
export interface RedisSpecPodTemplateSpecInitContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN
   *
   * @schema RedisSpecPodTemplateSpecInitContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * Adds and removes POSIX capabilities from running containers.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersSecurityContext#capabilities
   */
  readonly capabilities?: RedisSpecPodTemplateSpecInitContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false.
   *
   * @default false.
   * @schema RedisSpecPodTemplateSpecInitContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false.
   *
   * @default false.
   * @schema RedisSpecPodTemplateSpecInitContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema RedisSpecPodTemplateSpecInitContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * SELinuxOptions are the labels to be applied to the container
   *
   * @schema RedisSpecPodTemplateSpecInitContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: RedisSpecPodTemplateSpecInitContainersSecurityContextSeLinuxOptions;

}

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema RedisSpecPodTemplateSpecInitContainersVolumeDevices
 */
export interface RedisSpecPodTemplateSpecInitContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema RedisSpecPodTemplateSpecInitContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema RedisSpecPodTemplateSpecInitContainersVolumeMounts
 */
export interface RedisSpecPodTemplateSpecInitContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema RedisSpecPodTemplateSpecInitContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema RedisSpecPodTemplateSpecInitContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive. This field is alpha in 1.14.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive. This field is alpha in 1.14.
   * @schema RedisSpecPodTemplateSpecInitContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Handler defines a specific action that should be taken
 *
 * @schema RedisSpecPodTemplateSpecLifecyclePostStart
 */
export interface RedisSpecPodTemplateSpecLifecyclePostStart {
  /**
   * ExecAction describes a "run in container" action.
   *
   * @schema RedisSpecPodTemplateSpecLifecyclePostStart#exec
   */
  readonly exec?: RedisSpecPodTemplateSpecLifecyclePostStartExec;

  /**
   * HTTPGetAction describes an action based on HTTP Get requests.
   *
   * @schema RedisSpecPodTemplateSpecLifecyclePostStart#httpGet
   */
  readonly httpGet?: RedisSpecPodTemplateSpecLifecyclePostStartHttpGet;

  /**
   * TCPSocketAction describes an action based on opening a socket
   *
   * @schema RedisSpecPodTemplateSpecLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: RedisSpecPodTemplateSpecLifecyclePostStartTcpSocket;

}

/**
 * Handler defines a specific action that should be taken
 *
 * @schema RedisSpecPodTemplateSpecLifecyclePreStop
 */
export interface RedisSpecPodTemplateSpecLifecyclePreStop {
  /**
   * ExecAction describes a "run in container" action.
   *
   * @schema RedisSpecPodTemplateSpecLifecyclePreStop#exec
   */
  readonly exec?: RedisSpecPodTemplateSpecLifecyclePreStopExec;

  /**
   * HTTPGetAction describes an action based on HTTP Get requests.
   *
   * @schema RedisSpecPodTemplateSpecLifecyclePreStop#httpGet
   */
  readonly httpGet?: RedisSpecPodTemplateSpecLifecyclePreStopHttpGet;

  /**
   * TCPSocketAction describes an action based on opening a socket
   *
   * @schema RedisSpecPodTemplateSpecLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: RedisSpecPodTemplateSpecLifecyclePreStopTcpSocket;

}

/**
 * ExecAction describes a "run in container" action.
 *
 * @schema RedisSpecPodTemplateSpecLivenessProbeExec
 */
export interface RedisSpecPodTemplateSpecLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RedisSpecPodTemplateSpecLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 *
 * @schema RedisSpecPodTemplateSpecLivenessProbeHttpGet
 */
export interface RedisSpecPodTemplateSpecLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RedisSpecPodTemplateSpecLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RedisSpecPodTemplateSpecLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RedisSpecPodTemplateSpecLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RedisSpecPodTemplateSpecLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * @schema RedisSpecPodTemplateSpecLivenessProbeHttpGet#port
   */
  readonly port: RedisSpecPodTemplateSpecLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RedisSpecPodTemplateSpecLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * TCPSocketAction describes an action based on opening a socket
 *
 * @schema RedisSpecPodTemplateSpecLivenessProbeTcpSocket
 */
export interface RedisSpecPodTemplateSpecLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RedisSpecPodTemplateSpecLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema RedisSpecPodTemplateSpecLivenessProbeTcpSocket#port
   */
  readonly port: RedisSpecPodTemplateSpecLivenessProbeTcpSocketPort;

}

/**
 * ExecAction describes a "run in container" action.
 *
 * @schema RedisSpecPodTemplateSpecReadinessProbeExec
 */
export interface RedisSpecPodTemplateSpecReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RedisSpecPodTemplateSpecReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 *
 * @schema RedisSpecPodTemplateSpecReadinessProbeHttpGet
 */
export interface RedisSpecPodTemplateSpecReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RedisSpecPodTemplateSpecReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RedisSpecPodTemplateSpecReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RedisSpecPodTemplateSpecReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RedisSpecPodTemplateSpecReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * @schema RedisSpecPodTemplateSpecReadinessProbeHttpGet#port
   */
  readonly port: RedisSpecPodTemplateSpecReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RedisSpecPodTemplateSpecReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * TCPSocketAction describes an action based on opening a socket
 *
 * @schema RedisSpecPodTemplateSpecReadinessProbeTcpSocket
 */
export interface RedisSpecPodTemplateSpecReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RedisSpecPodTemplateSpecReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema RedisSpecPodTemplateSpecReadinessProbeTcpSocket#port
   */
  readonly port: RedisSpecPodTemplateSpecReadinessProbeTcpSocketPort;

}

/**
 * SELinuxOptions are the labels to be applied to the container
 *
 * @schema RedisSpecPodTemplateSpecSecurityContextSeLinuxOptions
 */
export interface RedisSpecPodTemplateSpecSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema RedisSpecPodTemplateSpecSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema RedisSpecPodTemplateSpecSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema RedisSpecPodTemplateSpecSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema RedisSpecPodTemplateSpecSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema RedisSpecPodTemplateSpecSecurityContextSysctls
 */
export interface RedisSpecPodTemplateSpecSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema RedisSpecPodTemplateSpecSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema RedisSpecPodTemplateSpecSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Maps a string key to a path within a volume.
 *
 * @schema RedisSpecConfigSourceProjectedSourcesConfigMapItems
 */
export interface RedisSpecConfigSourceProjectedSourcesConfigMapItems {
  /**
   * The key to project.
   *
   * @schema RedisSpecConfigSourceProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RedisSpecConfigSourceProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema RedisSpecConfigSourceProjectedSourcesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema RedisSpecConfigSourceProjectedSourcesDownwardApiItems
 */
export interface RedisSpecConfigSourceProjectedSourcesDownwardApiItems {
  /**
   * ObjectFieldSelector selects an APIVersioned field of an object.
   *
   * @schema RedisSpecConfigSourceProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: RedisSpecConfigSourceProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RedisSpecConfigSourceProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema RedisSpecConfigSourceProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * ResourceFieldSelector represents container resources (cpu, memory) and their output format
   *
   * @schema RedisSpecConfigSourceProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: RedisSpecConfigSourceProjectedSourcesDownwardApiItemsResourceFieldRef;

}

/**
 * Maps a string key to a path within a volume.
 *
 * @schema RedisSpecConfigSourceProjectedSourcesSecretItems
 */
export interface RedisSpecConfigSourceProjectedSourcesSecretItems {
  /**
   * The key to project.
   *
   * @schema RedisSpecConfigSourceProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema RedisSpecConfigSourceProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema RedisSpecConfigSourceProjectedSourcesSecretItems#path
   */
  readonly path: string;

}

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema RedisSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface RedisSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
   *
   * @schema RedisSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: RedisSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema RedisSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * A node selector represents the union of the results of one or more label queries over a set of nodes; that is, it represents the OR of the selectors represented by the node selector terms.
 *
 * @schema RedisSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface RedisSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema RedisSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: RedisSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema RedisSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface RedisSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: RedisSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema RedisSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface RedisSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: RedisSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema RedisSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface RedisSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: RedisSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema RedisSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface RedisSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: RedisSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Selects a key from a ConfigMap.
 *
 * @schema RedisSpecPodTemplateSpecEnvValueFromConfigMapKeyRef
 */
export interface RedisSpecPodTemplateSpecEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema RedisSpecPodTemplateSpecEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema RedisSpecPodTemplateSpecEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or it's key must be defined
   *
   * @schema RedisSpecPodTemplateSpecEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * ObjectFieldSelector selects an APIVersioned field of an object.
 *
 * @schema RedisSpecPodTemplateSpecEnvValueFromFieldRef
 */
export interface RedisSpecPodTemplateSpecEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RedisSpecPodTemplateSpecEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RedisSpecPodTemplateSpecEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * ResourceFieldSelector represents container resources (cpu, memory) and their output format
 *
 * @schema RedisSpecPodTemplateSpecEnvValueFromResourceFieldRef
 */
export interface RedisSpecPodTemplateSpecEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RedisSpecPodTemplateSpecEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and Int64() accessors.

The serialization format is:

<quantity>        ::= <signedNumber><suffix>
  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
<digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
<decimalSI>       ::= m | "" | k | M | G | T | P | E
  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
<decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>

No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:
  a. No precision is lost
  b. No fractional digits will be emitted
  c. The exponent (or suffix) is as large as possible.
The sign will be omitted unless the number is negative.

Examples:
  1.5 will be serialized as "1500m"
  1.5Gi will be serialized as "1536Mi"

Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.
   *
   * @schema RedisSpecPodTemplateSpecEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: string;

  /**
   * Required: resource to select
   *
   * @schema RedisSpecPodTemplateSpecEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema RedisSpecPodTemplateSpecEnvValueFromSecretKeyRef
 */
export interface RedisSpecPodTemplateSpecEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RedisSpecPodTemplateSpecEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema RedisSpecPodTemplateSpecEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or it's key must be defined
   *
   * @schema RedisSpecPodTemplateSpecEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * EnvVarSource represents a source for the value of an EnvVar.
 *
 * @schema RedisSpecPodTemplateSpecInitContainersEnvValueFrom
 */
export interface RedisSpecPodTemplateSpecInitContainersEnvValueFrom {
  /**
   * Selects a key from a ConfigMap.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: RedisSpecPodTemplateSpecInitContainersEnvValueFromConfigMapKeyRef;

  /**
   * ObjectFieldSelector selects an APIVersioned field of an object.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: RedisSpecPodTemplateSpecInitContainersEnvValueFromFieldRef;

  /**
   * ResourceFieldSelector represents container resources (cpu, memory) and their output format
   *
   * @schema RedisSpecPodTemplateSpecInitContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: RedisSpecPodTemplateSpecInitContainersEnvValueFromResourceFieldRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: RedisSpecPodTemplateSpecInitContainersEnvValueFromSecretKeyRef;

}

/**
 * ConfigMapEnvSource selects a ConfigMap to populate the environment variables with.

The contents of the target ConfigMap's Data field will represent the key-value pairs as environment variables.
 *
 * @schema RedisSpecPodTemplateSpecInitContainersEnvFromConfigMapRef
 */
export interface RedisSpecPodTemplateSpecInitContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema RedisSpecPodTemplateSpecInitContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema RedisSpecPodTemplateSpecInitContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * SecretEnvSource selects a Secret to populate the environment variables with.

The contents of the target Secret's Data field will represent the key-value pairs as environment variables.
 *
 * @schema RedisSpecPodTemplateSpecInitContainersEnvFromSecretRef
 */
export interface RedisSpecPodTemplateSpecInitContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema RedisSpecPodTemplateSpecInitContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema RedisSpecPodTemplateSpecInitContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Handler defines a specific action that should be taken
 *
 * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePostStart
 */
export interface RedisSpecPodTemplateSpecInitContainersLifecyclePostStart {
  /**
   * ExecAction describes a "run in container" action.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePostStart#exec
   */
  readonly exec?: RedisSpecPodTemplateSpecInitContainersLifecyclePostStartExec;

  /**
   * HTTPGetAction describes an action based on HTTP Get requests.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: RedisSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGet;

  /**
   * TCPSocketAction describes an action based on opening a socket
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: RedisSpecPodTemplateSpecInitContainersLifecyclePostStartTcpSocket;

}

/**
 * Handler defines a specific action that should be taken
 *
 * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePreStop
 */
export interface RedisSpecPodTemplateSpecInitContainersLifecyclePreStop {
  /**
   * ExecAction describes a "run in container" action.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePreStop#exec
   */
  readonly exec?: RedisSpecPodTemplateSpecInitContainersLifecyclePreStopExec;

  /**
   * HTTPGetAction describes an action based on HTTP Get requests.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: RedisSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGet;

  /**
   * TCPSocketAction describes an action based on opening a socket
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: RedisSpecPodTemplateSpecInitContainersLifecyclePreStopTcpSocket;

}

/**
 * ExecAction describes a "run in container" action.
 *
 * @schema RedisSpecPodTemplateSpecInitContainersLivenessProbeExec
 */
export interface RedisSpecPodTemplateSpecInitContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 *
 * @schema RedisSpecPodTemplateSpecInitContainersLivenessProbeHttpGet
 */
export interface RedisSpecPodTemplateSpecInitContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RedisSpecPodTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * @schema RedisSpecPodTemplateSpecInitContainersLivenessProbeHttpGet#port
   */
  readonly port: RedisSpecPodTemplateSpecInitContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RedisSpecPodTemplateSpecInitContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * TCPSocketAction describes an action based on opening a socket
 *
 * @schema RedisSpecPodTemplateSpecInitContainersLivenessProbeTcpSocket
 */
export interface RedisSpecPodTemplateSpecInitContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema RedisSpecPodTemplateSpecInitContainersLivenessProbeTcpSocket#port
   */
  readonly port: RedisSpecPodTemplateSpecInitContainersLivenessProbeTcpSocketPort;

}

/**
 * ExecAction describes a "run in container" action.
 *
 * @schema RedisSpecPodTemplateSpecInitContainersReadinessProbeExec
 */
export interface RedisSpecPodTemplateSpecInitContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 *
 * @schema RedisSpecPodTemplateSpecInitContainersReadinessProbeHttpGet
 */
export interface RedisSpecPodTemplateSpecInitContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: RedisSpecPodTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * @schema RedisSpecPodTemplateSpecInitContainersReadinessProbeHttpGet#port
   */
  readonly port: RedisSpecPodTemplateSpecInitContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RedisSpecPodTemplateSpecInitContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * TCPSocketAction describes an action based on opening a socket
 *
 * @schema RedisSpecPodTemplateSpecInitContainersReadinessProbeTcpSocket
 */
export interface RedisSpecPodTemplateSpecInitContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema RedisSpecPodTemplateSpecInitContainersReadinessProbeTcpSocket#port
   */
  readonly port: RedisSpecPodTemplateSpecInitContainersReadinessProbeTcpSocketPort;

}

/**
 * Adds and removes POSIX capabilities from running containers.
 *
 * @schema RedisSpecPodTemplateSpecInitContainersSecurityContextCapabilities
 */
export interface RedisSpecPodTemplateSpecInitContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema RedisSpecPodTemplateSpecInitContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema RedisSpecPodTemplateSpecInitContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * SELinuxOptions are the labels to be applied to the container
 *
 * @schema RedisSpecPodTemplateSpecInitContainersSecurityContextSeLinuxOptions
 */
export interface RedisSpecPodTemplateSpecInitContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * ExecAction describes a "run in container" action.
 *
 * @schema RedisSpecPodTemplateSpecLifecyclePostStartExec
 */
export interface RedisSpecPodTemplateSpecLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RedisSpecPodTemplateSpecLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 *
 * @schema RedisSpecPodTemplateSpecLifecyclePostStartHttpGet
 */
export interface RedisSpecPodTemplateSpecLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RedisSpecPodTemplateSpecLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RedisSpecPodTemplateSpecLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: RedisSpecPodTemplateSpecLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RedisSpecPodTemplateSpecLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * @schema RedisSpecPodTemplateSpecLifecyclePostStartHttpGet#port
   */
  readonly port: RedisSpecPodTemplateSpecLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RedisSpecPodTemplateSpecLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * TCPSocketAction describes an action based on opening a socket
 *
 * @schema RedisSpecPodTemplateSpecLifecyclePostStartTcpSocket
 */
export interface RedisSpecPodTemplateSpecLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RedisSpecPodTemplateSpecLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema RedisSpecPodTemplateSpecLifecyclePostStartTcpSocket#port
   */
  readonly port: RedisSpecPodTemplateSpecLifecyclePostStartTcpSocketPort;

}

/**
 * ExecAction describes a "run in container" action.
 *
 * @schema RedisSpecPodTemplateSpecLifecyclePreStopExec
 */
export interface RedisSpecPodTemplateSpecLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RedisSpecPodTemplateSpecLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 *
 * @schema RedisSpecPodTemplateSpecLifecyclePreStopHttpGet
 */
export interface RedisSpecPodTemplateSpecLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RedisSpecPodTemplateSpecLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RedisSpecPodTemplateSpecLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: RedisSpecPodTemplateSpecLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RedisSpecPodTemplateSpecLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * @schema RedisSpecPodTemplateSpecLifecyclePreStopHttpGet#port
   */
  readonly port: RedisSpecPodTemplateSpecLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RedisSpecPodTemplateSpecLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * TCPSocketAction describes an action based on opening a socket
 *
 * @schema RedisSpecPodTemplateSpecLifecyclePreStopTcpSocket
 */
export interface RedisSpecPodTemplateSpecLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RedisSpecPodTemplateSpecLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema RedisSpecPodTemplateSpecLifecyclePreStopTcpSocket#port
   */
  readonly port: RedisSpecPodTemplateSpecLifecyclePreStopTcpSocketPort;

}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RedisSpecPodTemplateSpecLivenessProbeHttpGetHttpHeaders
 */
export interface RedisSpecPodTemplateSpecLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RedisSpecPodTemplateSpecLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RedisSpecPodTemplateSpecLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * @schema RedisSpecPodTemplateSpecLivenessProbeHttpGetPort
 */
export class RedisSpecPodTemplateSpecLivenessProbeHttpGetPort {
  public static fromString(value: string): RedisSpecPodTemplateSpecLivenessProbeHttpGetPort {
    return new RedisSpecPodTemplateSpecLivenessProbeHttpGetPort(value);
  }
  public static fromNumber(value: number): RedisSpecPodTemplateSpecLivenessProbeHttpGetPort {
    return new RedisSpecPodTemplateSpecLivenessProbeHttpGetPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * @schema RedisSpecPodTemplateSpecLivenessProbeTcpSocketPort
 */
export class RedisSpecPodTemplateSpecLivenessProbeTcpSocketPort {
  public static fromString(value: string): RedisSpecPodTemplateSpecLivenessProbeTcpSocketPort {
    return new RedisSpecPodTemplateSpecLivenessProbeTcpSocketPort(value);
  }
  public static fromNumber(value: number): RedisSpecPodTemplateSpecLivenessProbeTcpSocketPort {
    return new RedisSpecPodTemplateSpecLivenessProbeTcpSocketPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RedisSpecPodTemplateSpecReadinessProbeHttpGetHttpHeaders
 */
export interface RedisSpecPodTemplateSpecReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RedisSpecPodTemplateSpecReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RedisSpecPodTemplateSpecReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * @schema RedisSpecPodTemplateSpecReadinessProbeHttpGetPort
 */
export class RedisSpecPodTemplateSpecReadinessProbeHttpGetPort {
  public static fromString(value: string): RedisSpecPodTemplateSpecReadinessProbeHttpGetPort {
    return new RedisSpecPodTemplateSpecReadinessProbeHttpGetPort(value);
  }
  public static fromNumber(value: number): RedisSpecPodTemplateSpecReadinessProbeHttpGetPort {
    return new RedisSpecPodTemplateSpecReadinessProbeHttpGetPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * @schema RedisSpecPodTemplateSpecReadinessProbeTcpSocketPort
 */
export class RedisSpecPodTemplateSpecReadinessProbeTcpSocketPort {
  public static fromString(value: string): RedisSpecPodTemplateSpecReadinessProbeTcpSocketPort {
    return new RedisSpecPodTemplateSpecReadinessProbeTcpSocketPort(value);
  }
  public static fromNumber(value: number): RedisSpecPodTemplateSpecReadinessProbeTcpSocketPort {
    return new RedisSpecPodTemplateSpecReadinessProbeTcpSocketPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * ObjectFieldSelector selects an APIVersioned field of an object.
 *
 * @schema RedisSpecConfigSourceProjectedSourcesDownwardApiItemsFieldRef
 */
export interface RedisSpecConfigSourceProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RedisSpecConfigSourceProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RedisSpecConfigSourceProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * ResourceFieldSelector represents container resources (cpu, memory) and their output format
 *
 * @schema RedisSpecConfigSourceProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface RedisSpecConfigSourceProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RedisSpecConfigSourceProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and Int64() accessors.

The serialization format is:

<quantity>        ::= <signedNumber><suffix>
  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
<digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
<decimalSI>       ::= m | "" | k | M | G | T | P | E
  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
<decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>

No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:
  a. No precision is lost
  b. No fractional digits will be emitted
  c. The exponent (or suffix) is as large as possible.
The sign will be omitted unless the number is negative.

Examples:
  1.5 will be serialized as "1500m"
  1.5Gi will be serialized as "1536Mi"

Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.
   *
   * @schema RedisSpecConfigSourceProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: string;

  /**
   * Required: resource to select
   *
   * @schema RedisSpecConfigSourceProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema RedisSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface RedisSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema RedisSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: RedisSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema RedisSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: RedisSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema RedisSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface RedisSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema RedisSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: RedisSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema RedisSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: RedisSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema RedisSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface RedisSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: RedisSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema RedisSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface RedisSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: RedisSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema RedisSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface RedisSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: RedisSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema RedisSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface RedisSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: RedisSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Selects a key from a ConfigMap.
 *
 * @schema RedisSpecPodTemplateSpecInitContainersEnvValueFromConfigMapKeyRef
 */
export interface RedisSpecPodTemplateSpecInitContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema RedisSpecPodTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or it's key must be defined
   *
   * @schema RedisSpecPodTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * ObjectFieldSelector selects an APIVersioned field of an object.
 *
 * @schema RedisSpecPodTemplateSpecInitContainersEnvValueFromFieldRef
 */
export interface RedisSpecPodTemplateSpecInitContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema RedisSpecPodTemplateSpecInitContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * ResourceFieldSelector represents container resources (cpu, memory) and their output format
 *
 * @schema RedisSpecPodTemplateSpecInitContainersEnvValueFromResourceFieldRef
 */
export interface RedisSpecPodTemplateSpecInitContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema RedisSpecPodTemplateSpecInitContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and Int64() accessors.

The serialization format is:

<quantity>        ::= <signedNumber><suffix>
  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
<digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
<decimalSI>       ::= m | "" | k | M | G | T | P | E
  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
<decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>

No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:
  a. No precision is lost
  b. No fractional digits will be emitted
  c. The exponent (or suffix) is as large as possible.
The sign will be omitted unless the number is negative.

Examples:
  1.5 will be serialized as "1500m"
  1.5Gi will be serialized as "1536Mi"

Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: string;

  /**
   * Required: resource to select
   *
   * @schema RedisSpecPodTemplateSpecInitContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema RedisSpecPodTemplateSpecInitContainersEnvValueFromSecretKeyRef
 */
export interface RedisSpecPodTemplateSpecInitContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema RedisSpecPodTemplateSpecInitContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or it's key must be defined
   *
   * @schema RedisSpecPodTemplateSpecInitContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * ExecAction describes a "run in container" action.
 *
 * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePostStartExec
 */
export interface RedisSpecPodTemplateSpecInitContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 *
 * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGet
 */
export interface RedisSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: RedisSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGet#port
   */
  readonly port: RedisSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * TCPSocketAction describes an action based on opening a socket
 *
 * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePostStartTcpSocket
 */
export interface RedisSpecPodTemplateSpecInitContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: RedisSpecPodTemplateSpecInitContainersLifecyclePostStartTcpSocketPort;

}

/**
 * ExecAction describes a "run in container" action.
 *
 * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePreStopExec
 */
export interface RedisSpecPodTemplateSpecInitContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 *
 * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGet
 */
export interface RedisSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: RedisSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGet#port
   */
  readonly port: RedisSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * TCPSocketAction describes an action based on opening a socket
 *
 * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePreStopTcpSocket
 */
export interface RedisSpecPodTemplateSpecInitContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: RedisSpecPodTemplateSpecInitContainersLifecyclePreStopTcpSocketPort;

}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RedisSpecPodTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders
 */
export interface RedisSpecPodTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * @schema RedisSpecPodTemplateSpecInitContainersLivenessProbeHttpGetPort
 */
export class RedisSpecPodTemplateSpecInitContainersLivenessProbeHttpGetPort {
  public static fromString(value: string): RedisSpecPodTemplateSpecInitContainersLivenessProbeHttpGetPort {
    return new RedisSpecPodTemplateSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  public static fromNumber(value: number): RedisSpecPodTemplateSpecInitContainersLivenessProbeHttpGetPort {
    return new RedisSpecPodTemplateSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * @schema RedisSpecPodTemplateSpecInitContainersLivenessProbeTcpSocketPort
 */
export class RedisSpecPodTemplateSpecInitContainersLivenessProbeTcpSocketPort {
  public static fromString(value: string): RedisSpecPodTemplateSpecInitContainersLivenessProbeTcpSocketPort {
    return new RedisSpecPodTemplateSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromNumber(value: number): RedisSpecPodTemplateSpecInitContainersLivenessProbeTcpSocketPort {
    return new RedisSpecPodTemplateSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RedisSpecPodTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders
 */
export interface RedisSpecPodTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RedisSpecPodTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RedisSpecPodTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * @schema RedisSpecPodTemplateSpecInitContainersReadinessProbeHttpGetPort
 */
export class RedisSpecPodTemplateSpecInitContainersReadinessProbeHttpGetPort {
  public static fromString(value: string): RedisSpecPodTemplateSpecInitContainersReadinessProbeHttpGetPort {
    return new RedisSpecPodTemplateSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  public static fromNumber(value: number): RedisSpecPodTemplateSpecInitContainersReadinessProbeHttpGetPort {
    return new RedisSpecPodTemplateSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * @schema RedisSpecPodTemplateSpecInitContainersReadinessProbeTcpSocketPort
 */
export class RedisSpecPodTemplateSpecInitContainersReadinessProbeTcpSocketPort {
  public static fromString(value: string): RedisSpecPodTemplateSpecInitContainersReadinessProbeTcpSocketPort {
    return new RedisSpecPodTemplateSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromNumber(value: number): RedisSpecPodTemplateSpecInitContainersReadinessProbeTcpSocketPort {
    return new RedisSpecPodTemplateSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RedisSpecPodTemplateSpecLifecyclePostStartHttpGetHttpHeaders
 */
export interface RedisSpecPodTemplateSpecLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RedisSpecPodTemplateSpecLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RedisSpecPodTemplateSpecLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * @schema RedisSpecPodTemplateSpecLifecyclePostStartHttpGetPort
 */
export class RedisSpecPodTemplateSpecLifecyclePostStartHttpGetPort {
  public static fromString(value: string): RedisSpecPodTemplateSpecLifecyclePostStartHttpGetPort {
    return new RedisSpecPodTemplateSpecLifecyclePostStartHttpGetPort(value);
  }
  public static fromNumber(value: number): RedisSpecPodTemplateSpecLifecyclePostStartHttpGetPort {
    return new RedisSpecPodTemplateSpecLifecyclePostStartHttpGetPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * @schema RedisSpecPodTemplateSpecLifecyclePostStartTcpSocketPort
 */
export class RedisSpecPodTemplateSpecLifecyclePostStartTcpSocketPort {
  public static fromString(value: string): RedisSpecPodTemplateSpecLifecyclePostStartTcpSocketPort {
    return new RedisSpecPodTemplateSpecLifecyclePostStartTcpSocketPort(value);
  }
  public static fromNumber(value: number): RedisSpecPodTemplateSpecLifecyclePostStartTcpSocketPort {
    return new RedisSpecPodTemplateSpecLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RedisSpecPodTemplateSpecLifecyclePreStopHttpGetHttpHeaders
 */
export interface RedisSpecPodTemplateSpecLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RedisSpecPodTemplateSpecLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RedisSpecPodTemplateSpecLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * @schema RedisSpecPodTemplateSpecLifecyclePreStopHttpGetPort
 */
export class RedisSpecPodTemplateSpecLifecyclePreStopHttpGetPort {
  public static fromString(value: string): RedisSpecPodTemplateSpecLifecyclePreStopHttpGetPort {
    return new RedisSpecPodTemplateSpecLifecyclePreStopHttpGetPort(value);
  }
  public static fromNumber(value: number): RedisSpecPodTemplateSpecLifecyclePreStopHttpGetPort {
    return new RedisSpecPodTemplateSpecLifecyclePreStopHttpGetPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * @schema RedisSpecPodTemplateSpecLifecyclePreStopTcpSocketPort
 */
export class RedisSpecPodTemplateSpecLifecyclePreStopTcpSocketPort {
  public static fromString(value: string): RedisSpecPodTemplateSpecLifecyclePreStopTcpSocketPort {
    return new RedisSpecPodTemplateSpecLifecyclePreStopTcpSocketPort(value);
  }
  public static fromNumber(value: number): RedisSpecPodTemplateSpecLifecyclePreStopTcpSocketPort {
    return new RedisSpecPodTemplateSpecLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RedisSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface RedisSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema RedisSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema RedisSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema RedisSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RedisSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface RedisSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema RedisSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema RedisSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema RedisSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RedisSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface RedisSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema RedisSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema RedisSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema RedisSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RedisSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface RedisSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema RedisSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema RedisSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema RedisSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema RedisSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface RedisSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: RedisSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RedisSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface RedisSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema RedisSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface RedisSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: RedisSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RedisSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface RedisSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface RedisSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGetPort
 */
export class RedisSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
  public static fromString(value: string): RedisSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
    return new RedisSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromNumber(value: number): RedisSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
    return new RedisSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePostStartTcpSocketPort
 */
export class RedisSpecPodTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
  public static fromString(value: string): RedisSpecPodTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new RedisSpecPodTemplateSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromNumber(value: number): RedisSpecPodTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new RedisSpecPodTemplateSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface RedisSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGetPort
 */
export class RedisSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
  public static fromString(value: string): RedisSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
    return new RedisSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromNumber(value: number): RedisSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
    return new RedisSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * @schema RedisSpecPodTemplateSpecInitContainersLifecyclePreStopTcpSocketPort
 */
export class RedisSpecPodTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
  public static fromString(value: string): RedisSpecPodTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new RedisSpecPodTemplateSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromNumber(value: number): RedisSpecPodTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new RedisSpecPodTemplateSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RedisSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface RedisSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema RedisSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface RedisSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema RedisSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

