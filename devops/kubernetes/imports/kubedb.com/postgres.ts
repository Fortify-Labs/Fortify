// generated by cdk8s
import { ApiObject } from 'cdk8s';
import { Construct } from 'constructs';

/**
 * 
 *
 * @schema Postgres
 */
export class Postgres extends ApiObject {
  /**
   * Defines a "Postgres" API object
   * @param scope the scope in which to define this object
   * @param name a scope-local name for the object
   * @param options configuration options
   */
  public constructor(scope: Construct, name: string, options: PostgresOptions = {}) {
    super(scope, name, {
      ...options,
      kind: 'Postgres',
      apiVersion: 'kubedb.com/v1alpha1',
    });
  }
}

/**
 * @schema Postgres
 */
export interface PostgresOptions {
  /**
   * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
   *
   * @schema Postgres#metadata
   */
  readonly metadata?: PostgresMetadata;

  /**
   * @schema Postgres#spec
   */
  readonly spec?: PostgresSpec;

}

/**
 * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
 *
 * @schema PostgresMetadata
 */
export interface PostgresMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema PostgresMetadata#annotations
   */
  readonly annotations?: any;

  /**
   * The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
   *
   * @schema PostgresMetadata#clusterName
   */
  readonly clusterName?: string;

  /**
   * Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
   *
   * @schema PostgresMetadata#creationTimestamp
   */
  readonly creationTimestamp?: Date;

  /**
   * Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
   *
   * @schema PostgresMetadata#deletionGracePeriodSeconds
   */
  readonly deletionGracePeriodSeconds?: number;

  /**
   * Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
   *
   * @schema PostgresMetadata#deletionTimestamp
   */
  readonly deletionTimestamp?: Date;

  /**
   * Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
   *
   * @schema PostgresMetadata#finalizers
   */
  readonly finalizers?: string[];

  /**
   * GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.

If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).

Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#idempotency
   *
   * @schema PostgresMetadata#generateName
   */
  readonly generateName?: string;

  /**
   * A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.
   *
   * @schema PostgresMetadata#generation
   */
  readonly generation?: number;

  /**
   * Initializers tracks the progress of initialization.
   *
   * @schema PostgresMetadata#initializers
   */
  readonly initializers?: PostgresMetadataInitializers;

  /**
   * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
   *
   * @schema PostgresMetadata#labels
   */
  readonly labels?: any;

  /**
   * ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like "ci-cd". The set of fields is always in the version that the workflow used when modifying the object.

This field is alpha and can be changed or removed without notice.
   *
   * @schema PostgresMetadata#managedFields
   */
  readonly managedFields?: PostgresMetadataManagedFields[];

  /**
   * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
   *
   * @schema PostgresMetadata#name
   */
  readonly name?: string;

  /**
   * Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.

Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
   *
   * @schema PostgresMetadata#namespace
   */
  readonly namespace?: string;

  /**
   * List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.
   *
   * @schema PostgresMetadata#ownerReferences
   */
  readonly ownerReferences?: PostgresMetadataOwnerReferences[];

  /**
   * An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.

Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
   *
   * @schema PostgresMetadata#resourceVersion
   */
  readonly resourceVersion?: string;

  /**
   * SelfLink is a URL representing this object. Populated by the system. Read-only.
   *
   * @schema PostgresMetadata#selfLink
   */
  readonly selfLink?: string;

  /**
   * UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.

Populated by the system. Read-only. More info: http://kubernetes.io/docs/user-guide/identifiers#uids
   *
   * @schema PostgresMetadata#uid
   */
  readonly uid?: string;

}

/**
 * @schema PostgresSpec
 */
export interface PostgresSpec {
  /**
   * @schema PostgresSpec#archiver
   */
  readonly archiver?: PostgresSpecArchiver;

  /**
   * @schema PostgresSpec#backupSchedule
   */
  readonly backupSchedule?: PostgresSpecBackupSchedule;

  /**
   * Represents the source of a volume to mount. Only one of its members may be specified.
   *
   * @schema PostgresSpec#configSource
   */
  readonly configSource?: PostgresSpecConfigSource;

  /**
   * Adapts a Secret into a volume.

The contents of the target Secret's Data field will be presented in a volume as files using the keys in the Data field as the file names. Secret volumes support ownership management and SELinux relabeling.
   *
   * @schema PostgresSpec#databaseSecret
   */
  readonly databaseSecret?: PostgresSpecDatabaseSecret;

  /**
   * @schema PostgresSpec#init
   */
  readonly init?: PostgresSpecInit;

  /**
   * LeaderElectionConfig contains essential attributes of leader election. ref: https://github.com/kubernetes/client-go/blob/6134db91200ea474868bc6775e62cc294a74c6c6/tools/leaderelection/leaderelection.go#L105-L114
   *
   * @schema PostgresSpec#leaderElection
   */
  readonly leaderElection?: PostgresSpecLeaderElection;

  /**
   * @schema PostgresSpec#monitor
   */
  readonly monitor?: PostgresSpecMonitor;

  /**
   * PodTemplateSpec describes the data a pod should have when created from a template
   *
   * @schema PostgresSpec#podTemplate
   */
  readonly podTemplate?: PostgresSpecPodTemplate;

  /**
   * ServiceTemplateSpec describes the data a service should have when created from a template
   *
   * @schema PostgresSpec#replicaServiceTemplate
   */
  readonly replicaServiceTemplate?: PostgresSpecReplicaServiceTemplate;

  /**
   * Number of instances to deploy for a Postgres database.
   *
   * @schema PostgresSpec#replicas
   */
  readonly replicas?: number;

  /**
   * ServiceTemplateSpec describes the data a service should have when created from a template
   *
   * @schema PostgresSpec#serviceTemplate
   */
  readonly serviceTemplate?: PostgresSpecServiceTemplate;

  /**
   * Standby mode
   *
   * @schema PostgresSpec#standbyMode
   */
  readonly standbyMode?: string;

  /**
   * PersistentVolumeClaimSpec describes the common attributes of storage devices and allows a Source for provider-specific attributes
   *
   * @schema PostgresSpec#storage
   */
  readonly storage?: PostgresSpecStorage;

  /**
   * StorageType can be durable (default) or ephemeral
   *
   * @schema PostgresSpec#storageType
   */
  readonly storageType?: string;

  /**
   * Streaming mode
   *
   * @schema PostgresSpec#streamingMode
   */
  readonly streamingMode?: string;

  /**
   * TerminationPolicy controls the delete operation for database
   *
   * @schema PostgresSpec#terminationPolicy
   */
  readonly terminationPolicy?: string;

  /**
   * StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to perform updates. It includes any additional parameters necessary to perform the update for the indicated strategy.
   *
   * @schema PostgresSpec#updateStrategy
   */
  readonly updateStrategy?: PostgresSpecUpdateStrategy;

  /**
   * Version of Postgres to be deployed.
   *
   * @schema PostgresSpec#version
   */
  readonly version: string;

}

/**
 * Initializers tracks the progress of initialization.
 *
 * @schema PostgresMetadataInitializers
 */
export interface PostgresMetadataInitializers {
  /**
   * Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
   *
   * @schema PostgresMetadataInitializers#pending
   */
  readonly pending: PostgresMetadataInitializersPending[];

  /**
   * Status is a return value for calls that don't return other objects.
   *
   * @schema PostgresMetadataInitializers#result
   */
  readonly result?: PostgresMetadataInitializersResult;

}

/**
 * ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to.
 *
 * @schema PostgresMetadataManagedFields
 */
export interface PostgresMetadataManagedFields {
  /**
   * APIVersion defines the version of this resource that this field set applies to. The format is "group/version" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted.
   *
   * @schema PostgresMetadataManagedFields#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Fields stores a set of fields in a data structure like a Trie. To understand how this is used, see: https://github.com/kubernetes-sigs/structured-merge-diff
   *
   * @schema PostgresMetadataManagedFields#fields
   */
  readonly fields?: any;

  /**
   * Manager is an identifier of the workflow managing these fields.
   *
   * @schema PostgresMetadataManagedFields#manager
   */
  readonly manager?: string;

  /**
   * Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'.
   *
   * @schema PostgresMetadataManagedFields#operation
   */
  readonly operation?: string;

  /**
   * Time is a wrapper around time.Time which supports correct marshaling to YAML and JSON.  Wrappers are provided for many of the factory methods that the time package offers.
   *
   * @schema PostgresMetadataManagedFields#time
   */
  readonly time?: Date;

}

/**
 * OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.
 *
 * @schema PostgresMetadataOwnerReferences
 */
export interface PostgresMetadataOwnerReferences {
  /**
   * API version of the referent.
   *
   * @schema PostgresMetadataOwnerReferences#apiVersion
   */
  readonly apiVersion: string;

  /**
   * If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.
   *
   * @default false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.
   * @schema PostgresMetadataOwnerReferences#blockOwnerDeletion
   */
  readonly blockOwnerDeletion?: boolean;

  /**
   * If true, this reference points to the managing controller.
   *
   * @schema PostgresMetadataOwnerReferences#controller
   */
  readonly controller?: boolean;

  /**
   * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
   *
   * @schema PostgresMetadataOwnerReferences#kind
   */
  readonly kind: string;

  /**
   * Name of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#names
   *
   * @schema PostgresMetadataOwnerReferences#name
   */
  readonly name: string;

  /**
   * UID of the referent. More info: http://kubernetes.io/docs/user-guide/identifiers#uids
   *
   * @schema PostgresMetadataOwnerReferences#uid
   */
  readonly uid: string;

}

/**
 * @schema PostgresSpecArchiver
 */
export interface PostgresSpecArchiver {
  /**
   * @schema PostgresSpecArchiver#storage
   */
  readonly storage?: any;

}

/**
 * @schema PostgresSpecBackupSchedule
 */
export interface PostgresSpecBackupSchedule {
  /**
   * @schema PostgresSpecBackupSchedule#azure
   */
  readonly azure?: any;

  /**
   * @schema PostgresSpecBackupSchedule#b2
   */
  readonly b2?: any;

  /**
   * @schema PostgresSpecBackupSchedule#cronExpression
   */
  readonly cronExpression?: string;

  /**
   * @schema PostgresSpecBackupSchedule#gcs
   */
  readonly gcs?: any;

  /**
   * @schema PostgresSpecBackupSchedule#local
   */
  readonly local?: any;

  /**
   * PodTemplateSpec describes the data a pod should have when created from a template
   *
   * @schema PostgresSpecBackupSchedule#podTemplate
   */
  readonly podTemplate?: PostgresSpecBackupSchedulePodTemplate;

  /**
   * PersistentVolumeClaimSpec describes the common attributes of storage devices and allows a Source for provider-specific attributes
   *
   * @schema PostgresSpecBackupSchedule#podVolumeClaimSpec
   */
  readonly podVolumeClaimSpec?: PostgresSpecBackupSchedulePodVolumeClaimSpec;

  /**
   * @schema PostgresSpecBackupSchedule#rest
   */
  readonly rest?: any;

  /**
   * @schema PostgresSpecBackupSchedule#s3
   */
  readonly s3?: any;

  /**
   * @schema PostgresSpecBackupSchedule#storageSecretName
   */
  readonly storageSecretName?: string;

  /**
   * StorageType can be durable or ephemeral. If not given, database storage type will be used.
   *
   * @schema PostgresSpecBackupSchedule#storageType
   */
  readonly storageType?: string;

  /**
   * @schema PostgresSpecBackupSchedule#swift
   */
  readonly swift?: any;

}

/**
 * Represents the source of a volume to mount. Only one of its members may be specified.
 *
 * @schema PostgresSpecConfigSource
 */
export interface PostgresSpecConfigSource {
  /**
   * Represents a Persistent Disk resource in AWS.

An AWS EBS disk must exist before mounting to a container. The disk must also be in the same AWS zone as the kubelet. An AWS EBS disk can only be mounted as read/write once. AWS EBS volumes support ownership management and SELinux relabeling.
   *
   * @schema PostgresSpecConfigSource#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: PostgresSpecConfigSourceAwsElasticBlockStore;

  /**
   * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   *
   * @schema PostgresSpecConfigSource#azureDisk
   */
  readonly azureDisk?: PostgresSpecConfigSourceAzureDisk;

  /**
   * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
   *
   * @schema PostgresSpecConfigSource#azureFile
   */
  readonly azureFile?: PostgresSpecConfigSourceAzureFile;

  /**
   * Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not support ownership management or SELinux relabeling.
   *
   * @schema PostgresSpecConfigSource#cephfs
   */
  readonly cephfs?: PostgresSpecConfigSourceCephfs;

  /**
   * Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting to a container. The volume must also be in the same region as the kubelet. Cinder volumes support ownership management and SELinux relabeling.
   *
   * @schema PostgresSpecConfigSource#cinder
   */
  readonly cinder?: PostgresSpecConfigSourceCinder;

  /**
   * Adapts a ConfigMap into a volume.

The contents of the target ConfigMap's Data field will be presented in a volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. ConfigMap volumes support ownership management and SELinux relabeling.
   *
   * @schema PostgresSpecConfigSource#configMap
   */
  readonly configMap?: PostgresSpecConfigSourceConfigMap;

  /**
   * Represents a source location of a volume to mount, managed by an external CSI driver
   *
   * @schema PostgresSpecConfigSource#csi
   */
  readonly csi?: PostgresSpecConfigSourceCsi;

  /**
   * DownwardAPIVolumeSource represents a volume containing downward API info. Downward API volumes support ownership management and SELinux relabeling.
   *
   * @schema PostgresSpecConfigSource#downwardAPI
   */
  readonly downwardAPI?: PostgresSpecConfigSourceDownwardApi;

  /**
   * Represents an empty directory for a pod. Empty directory volumes support ownership management and SELinux relabeling.
   *
   * @schema PostgresSpecConfigSource#emptyDir
   */
  readonly emptyDir?: PostgresSpecConfigSourceEmptyDir;

  /**
   * Represents a Fibre Channel volume. Fibre Channel volumes can only be mounted as read/write once. Fibre Channel volumes support ownership management and SELinux relabeling.
   *
   * @schema PostgresSpecConfigSource#fc
   */
  readonly fc?: PostgresSpecConfigSourceFc;

  /**
   * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
   *
   * @schema PostgresSpecConfigSource#flexVolume
   */
  readonly flexVolume?: PostgresSpecConfigSourceFlexVolume;

  /**
   * Represents a Flocker volume mounted by the Flocker agent. One and only one of datasetName and datasetUUID should be set. Flocker volumes do not support ownership management or SELinux relabeling.
   *
   * @schema PostgresSpecConfigSource#flocker
   */
  readonly flocker?: PostgresSpecConfigSourceFlocker;

  /**
   * Represents a Persistent Disk resource in Google Compute Engine.

A GCE PD must exist before mounting to a container. The disk must also be in the same GCE project and zone as the kubelet. A GCE PD can only be mounted as read/write once or read-only many times. GCE PDs support ownership management and SELinux relabeling.
   *
   * @schema PostgresSpecConfigSource#gcePersistentDisk
   */
  readonly gcePersistentDisk?: PostgresSpecConfigSourceGcePersistentDisk;

  /**
   * Represents a volume that is populated with the contents of a git repository. Git repo volumes do not support ownership management. Git repo volumes support SELinux relabeling.

DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
   *
   * @schema PostgresSpecConfigSource#gitRepo
   */
  readonly gitRepo?: PostgresSpecConfigSourceGitRepo;

  /**
   * Represents a Glusterfs mount that lasts the lifetime of a pod. Glusterfs volumes do not support ownership management or SELinux relabeling.
   *
   * @schema PostgresSpecConfigSource#glusterfs
   */
  readonly glusterfs?: PostgresSpecConfigSourceGlusterfs;

  /**
   * Represents a host path mapped into a pod. Host path volumes do not support ownership management or SELinux relabeling.
   *
   * @schema PostgresSpecConfigSource#hostPath
   */
  readonly hostPath?: PostgresSpecConfigSourceHostPath;

  /**
   * Represents an ISCSI disk. ISCSI volumes can only be mounted as read/write once. ISCSI volumes support ownership management and SELinux relabeling.
   *
   * @schema PostgresSpecConfigSource#iscsi
   */
  readonly iscsi?: PostgresSpecConfigSourceIscsi;

  /**
   * Represents an NFS mount that lasts the lifetime of a pod. NFS volumes do not support ownership management or SELinux relabeling.
   *
   * @schema PostgresSpecConfigSource#nfs
   */
  readonly nfs?: PostgresSpecConfigSourceNfs;

  /**
   * PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace. This volume finds the bound PV and mounts that volume for the pod. A PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another type of volume that is owned by someone else (the system).
   *
   * @schema PostgresSpecConfigSource#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: PostgresSpecConfigSourcePersistentVolumeClaim;

  /**
   * Represents a Photon Controller persistent disk resource.
   *
   * @schema PostgresSpecConfigSource#photonPersistentDisk
   */
  readonly photonPersistentDisk?: PostgresSpecConfigSourcePhotonPersistentDisk;

  /**
   * PortworxVolumeSource represents a Portworx volume resource.
   *
   * @schema PostgresSpecConfigSource#portworxVolume
   */
  readonly portworxVolume?: PostgresSpecConfigSourcePortworxVolume;

  /**
   * Represents a projected volume source
   *
   * @schema PostgresSpecConfigSource#projected
   */
  readonly projected?: PostgresSpecConfigSourceProjected;

  /**
   * Represents a Quobyte mount that lasts the lifetime of a pod. Quobyte volumes do not support ownership management or SELinux relabeling.
   *
   * @schema PostgresSpecConfigSource#quobyte
   */
  readonly quobyte?: PostgresSpecConfigSourceQuobyte;

  /**
   * Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support ownership management and SELinux relabeling.
   *
   * @schema PostgresSpecConfigSource#rbd
   */
  readonly rbd?: PostgresSpecConfigSourceRbd;

  /**
   * ScaleIOVolumeSource represents a persistent ScaleIO volume
   *
   * @schema PostgresSpecConfigSource#scaleIO
   */
  readonly scaleIO?: PostgresSpecConfigSourceScaleIo;

  /**
   * Adapts a Secret into a volume.

The contents of the target Secret's Data field will be presented in a volume as files using the keys in the Data field as the file names. Secret volumes support ownership management and SELinux relabeling.
   *
   * @schema PostgresSpecConfigSource#secret
   */
  readonly secret?: PostgresSpecConfigSourceSecret;

  /**
   * Represents a StorageOS persistent volume resource.
   *
   * @schema PostgresSpecConfigSource#storageos
   */
  readonly storageos?: PostgresSpecConfigSourceStorageos;

  /**
   * Represents a vSphere volume resource.
   *
   * @schema PostgresSpecConfigSource#vsphereVolume
   */
  readonly vsphereVolume?: PostgresSpecConfigSourceVsphereVolume;

}

/**
 * Adapts a Secret into a volume.

The contents of the target Secret's Data field will be presented in a volume as files using the keys in the Data field as the file names. Secret volumes support ownership management and SELinux relabeling.
 *
 * @schema PostgresSpecDatabaseSecret
 */
export interface PostgresSpecDatabaseSecret {
  /**
   * Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema PostgresSpecDatabaseSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema PostgresSpecDatabaseSecret#items
   */
  readonly items?: PostgresSpecDatabaseSecretItems[];

  /**
   * Specify whether the Secret or it's keys must be defined
   *
   * @schema PostgresSpecDatabaseSecret#optional
   */
  readonly optional?: boolean;

  /**
   * Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema PostgresSpecDatabaseSecret#secretName
   */
  readonly secretName?: string;

}

/**
 * @schema PostgresSpecInit
 */
export interface PostgresSpecInit {
  /**
   * @schema PostgresSpecInit#postgresWAL
   */
  readonly postgresWAL?: PostgresSpecInitPostgresWal;

  /**
   * @schema PostgresSpecInit#scriptSource
   */
  readonly scriptSource?: PostgresSpecInitScriptSource;

  /**
   * @schema PostgresSpecInit#snapshotSource
   */
  readonly snapshotSource?: PostgresSpecInitSnapshotSource;

  /**
   * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
   *
   * @schema PostgresSpecInit#stashRestoreSession
   */
  readonly stashRestoreSession?: PostgresSpecInitStashRestoreSession;

}

/**
 * LeaderElectionConfig contains essential attributes of leader election. ref: https://github.com/kubernetes/client-go/blob/6134db91200ea474868bc6775e62cc294a74c6c6/tools/leaderelection/leaderelection.go#L105-L114
 *
 * @schema PostgresSpecLeaderElection
 */
export interface PostgresSpecLeaderElection {
  /**
   * LeaseDuration is the duration in second that non-leader candidates will wait to force acquire leadership. This is measured against time of last observed ack. Default 15
   *
   * @schema PostgresSpecLeaderElection#leaseDurationSeconds
   */
  readonly leaseDurationSeconds: number;

  /**
   * RenewDeadline is the duration in second that the acting master will retry refreshing leadership before giving up. Normally, LeaseDuration * 2 / 3. Default 10
   *
   * @schema PostgresSpecLeaderElection#renewDeadlineSeconds
   */
  readonly renewDeadlineSeconds: number;

  /**
   * RetryPeriod is the duration in second the LeaderElector clients should wait between tries of actions. Normally, LeaseDuration / 3. Default 2
   *
   * @schema PostgresSpecLeaderElection#retryPeriodSeconds
   */
  readonly retryPeriodSeconds: number;

}

/**
 * @schema PostgresSpecMonitor
 */
export interface PostgresSpecMonitor {
  /**
   * @schema PostgresSpecMonitor#agent
   */
  readonly agent?: string;

  /**
   * Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema PostgresSpecMonitor#args
   */
  readonly args?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema PostgresSpecMonitor#env
   */
  readonly env?: PostgresSpecMonitorEnv[];

  /**
   * @schema PostgresSpecMonitor#prometheus
   */
  readonly prometheus?: PostgresSpecMonitorPrometheus;

  /**
   * ResourceRequirements describes the compute resource requirements.
   *
   * @schema PostgresSpecMonitor#resources
   */
  readonly resources?: PostgresSpecMonitorResources;

  /**
   * SecurityContext holds security configuration that will be applied to a container. Some fields are present in both SecurityContext and PodSecurityContext.  When both are set, the values in SecurityContext take precedence.
   *
   * @schema PostgresSpecMonitor#securityContext
   */
  readonly securityContext?: PostgresSpecMonitorSecurityContext;

}

/**
 * PodTemplateSpec describes the data a pod should have when created from a template
 *
 * @schema PostgresSpecPodTemplate
 */
export interface PostgresSpecPodTemplate {
  /**
   * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
   *
   * @schema PostgresSpecPodTemplate#controller
   */
  readonly controller?: PostgresSpecPodTemplateController;

  /**
   * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
   *
   * @schema PostgresSpecPodTemplate#metadata
   */
  readonly metadata?: PostgresSpecPodTemplateMetadata;

  /**
   * @schema PostgresSpecPodTemplate#spec
   */
  readonly spec?: PostgresSpecPodTemplateSpec;

}

/**
 * ServiceTemplateSpec describes the data a service should have when created from a template
 *
 * @schema PostgresSpecReplicaServiceTemplate
 */
export interface PostgresSpecReplicaServiceTemplate {
  /**
   * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
   *
   * @schema PostgresSpecReplicaServiceTemplate#metadata
   */
  readonly metadata?: PostgresSpecReplicaServiceTemplateMetadata;

  /**
   * ServiceSpec describes the attributes that a user creates on a service.
   *
   * @schema PostgresSpecReplicaServiceTemplate#spec
   */
  readonly spec?: PostgresSpecReplicaServiceTemplateSpec;

}

/**
 * ServiceTemplateSpec describes the data a service should have when created from a template
 *
 * @schema PostgresSpecServiceTemplate
 */
export interface PostgresSpecServiceTemplate {
  /**
   * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
   *
   * @schema PostgresSpecServiceTemplate#metadata
   */
  readonly metadata?: PostgresSpecServiceTemplateMetadata;

  /**
   * ServiceSpec describes the attributes that a user creates on a service.
   *
   * @schema PostgresSpecServiceTemplate#spec
   */
  readonly spec?: PostgresSpecServiceTemplateSpec;

}

/**
 * PersistentVolumeClaimSpec describes the common attributes of storage devices and allows a Source for provider-specific attributes
 *
 * @schema PostgresSpecStorage
 */
export interface PostgresSpecStorage {
  /**
   * AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema PostgresSpecStorage#accessModes
   */
  readonly accessModes?: string[];

  /**
   * TypedLocalObjectReference contains enough information to let you locate the typed referenced object inside the same namespace.
   *
   * @schema PostgresSpecStorage#dataSource
   */
  readonly dataSource?: PostgresSpecStorageDataSource;

  /**
   * ResourceRequirements describes the compute resource requirements.
   *
   * @schema PostgresSpecStorage#resources
   */
  readonly resources?: PostgresSpecStorageResources;

  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
   *
   * @schema PostgresSpecStorage#selector
   */
  readonly selector?: PostgresSpecStorageSelector;

  /**
   * Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema PostgresSpecStorage#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec. This is a beta feature.
   *
   * @schema PostgresSpecStorage#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * VolumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema PostgresSpecStorage#volumeName
   */
  readonly volumeName?: string;

}

/**
 * StatefulSetUpdateStrategy indicates the strategy that the StatefulSet controller will use to perform updates. It includes any additional parameters necessary to perform the update for the indicated strategy.
 *
 * @schema PostgresSpecUpdateStrategy
 */
export interface PostgresSpecUpdateStrategy {
  /**
   * RollingUpdateStatefulSetStrategy is used to communicate parameter for RollingUpdateStatefulSetStrategyType.
   *
   * @schema PostgresSpecUpdateStrategy#rollingUpdate
   */
  readonly rollingUpdate?: PostgresSpecUpdateStrategyRollingUpdate;

  /**
   * Type indicates the type of the StatefulSetUpdateStrategy. Default is RollingUpdate.
   *
   * @default RollingUpdate.
   * @schema PostgresSpecUpdateStrategy#type
   */
  readonly type?: string;

}

/**
 * Initializer is information about an initializer that has not yet completed.
 *
 * @schema PostgresMetadataInitializersPending
 */
export interface PostgresMetadataInitializersPending {
  /**
   * name of the process that is responsible for initializing this object.
   *
   * @schema PostgresMetadataInitializersPending#name
   */
  readonly name: string;

}

/**
 * Status is a return value for calls that don't return other objects.
 *
 * @schema PostgresMetadataInitializersResult
 */
export interface PostgresMetadataInitializersResult {
  /**
   * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources
   *
   * @schema PostgresMetadataInitializersResult#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Suggested HTTP return code for this status, 0 if not set.
   *
   * @schema PostgresMetadataInitializersResult#code
   */
  readonly code?: number;

  /**
   * StatusDetails is a set of additional properties that MAY be set by the server to provide additional information about a response. The Reason field of a Status object defines what attributes will be set. Clients must ignore fields that do not match the defined type of each attribute, and should assume that any attribute may be empty, invalid, or under defined.
   *
   * @schema PostgresMetadataInitializersResult#details
   */
  readonly details?: PostgresMetadataInitializersResultDetails;

  /**
   * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
   *
   * @schema PostgresMetadataInitializersResult#kind
   */
  readonly kind?: string;

  /**
   * A human-readable description of the status of this operation.
   *
   * @schema PostgresMetadataInitializersResult#message
   */
  readonly message?: string;

  /**
   * ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
   *
   * @schema PostgresMetadataInitializersResult#metadata
   */
  readonly metadata?: PostgresMetadataInitializersResultMetadata;

  /**
   * A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
   *
   * @schema PostgresMetadataInitializersResult#reason
   */
  readonly reason?: string;

  /**
   * Status of the operation. One of: "Success" or "Failure". More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
   *
   * @schema PostgresMetadataInitializersResult#status
   */
  readonly status?: string;

}

/**
 * PodTemplateSpec describes the data a pod should have when created from a template
 *
 * @schema PostgresSpecBackupSchedulePodTemplate
 */
export interface PostgresSpecBackupSchedulePodTemplate {
  /**
   * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
   *
   * @schema PostgresSpecBackupSchedulePodTemplate#controller
   */
  readonly controller?: PostgresSpecBackupSchedulePodTemplateController;

  /**
   * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
   *
   * @schema PostgresSpecBackupSchedulePodTemplate#metadata
   */
  readonly metadata?: PostgresSpecBackupSchedulePodTemplateMetadata;

  /**
   * @schema PostgresSpecBackupSchedulePodTemplate#spec
   */
  readonly spec?: PostgresSpecBackupSchedulePodTemplateSpec;

}

/**
 * PersistentVolumeClaimSpec describes the common attributes of storage devices and allows a Source for provider-specific attributes
 *
 * @schema PostgresSpecBackupSchedulePodVolumeClaimSpec
 */
export interface PostgresSpecBackupSchedulePodVolumeClaimSpec {
  /**
   * AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
   *
   * @schema PostgresSpecBackupSchedulePodVolumeClaimSpec#accessModes
   */
  readonly accessModes?: string[];

  /**
   * TypedLocalObjectReference contains enough information to let you locate the typed referenced object inside the same namespace.
   *
   * @schema PostgresSpecBackupSchedulePodVolumeClaimSpec#dataSource
   */
  readonly dataSource?: PostgresSpecBackupSchedulePodVolumeClaimSpecDataSource;

  /**
   * ResourceRequirements describes the compute resource requirements.
   *
   * @schema PostgresSpecBackupSchedulePodVolumeClaimSpec#resources
   */
  readonly resources?: PostgresSpecBackupSchedulePodVolumeClaimSpecResources;

  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
   *
   * @schema PostgresSpecBackupSchedulePodVolumeClaimSpec#selector
   */
  readonly selector?: PostgresSpecBackupSchedulePodVolumeClaimSpecSelector;

  /**
   * Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
   *
   * @schema PostgresSpecBackupSchedulePodVolumeClaimSpec#storageClassName
   */
  readonly storageClassName?: string;

  /**
   * volumeMode defines what type of volume is required by the claim. Value of Filesystem is implied when not included in claim spec. This is a beta feature.
   *
   * @schema PostgresSpecBackupSchedulePodVolumeClaimSpec#volumeMode
   */
  readonly volumeMode?: string;

  /**
   * VolumeName is the binding reference to the PersistentVolume backing this claim.
   *
   * @schema PostgresSpecBackupSchedulePodVolumeClaimSpec#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Represents a Persistent Disk resource in AWS.

An AWS EBS disk must exist before mounting to a container. The disk must also be in the same AWS zone as the kubelet. An AWS EBS disk can only be mounted as read/write once. AWS EBS volumes support ownership management and SELinux relabeling.
 *
 * @schema PostgresSpecConfigSourceAwsElasticBlockStore
 */
export interface PostgresSpecConfigSourceAwsElasticBlockStore {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema PostgresSpecConfigSourceAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema PostgresSpecConfigSourceAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * Specify "true" to force and set the ReadOnly property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema PostgresSpecConfigSourceAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema PostgresSpecConfigSourceAwsElasticBlockStore#volumeID
   */
  readonly volumeID: string;

}

/**
 * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 *
 * @schema PostgresSpecConfigSourceAzureDisk
 */
export interface PostgresSpecConfigSourceAzureDisk {
  /**
   * Host Caching mode: None, Read Only, Read Write.
   *
   * @schema PostgresSpecConfigSourceAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * The Name of the data disk in the blob storage
   *
   * @schema PostgresSpecConfigSourceAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * The URI the data disk in the blob storage
   *
   * @schema PostgresSpecConfigSourceAzureDisk#diskURI
   */
  readonly diskURI: string;

  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PostgresSpecConfigSourceAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * Expected values Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema PostgresSpecConfigSourceAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema PostgresSpecConfigSourceAzureDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @schema PostgresSpecConfigSourceAzureFile
 */
export interface PostgresSpecConfigSourceAzureFile {
  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema PostgresSpecConfigSourceAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * the name of secret that contains Azure Storage Account Name and Key
   *
   * @schema PostgresSpecConfigSourceAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * Share Name
   *
   * @schema PostgresSpecConfigSourceAzureFile#shareName
   */
  readonly shareName: string;

}

/**
 * Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not support ownership management or SELinux relabeling.
 *
 * @schema PostgresSpecConfigSourceCephfs
 */
export interface PostgresSpecConfigSourceCephfs {
  /**
   * Required: Monitors is a collection of Ceph monitors More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema PostgresSpecConfigSourceCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema PostgresSpecConfigSourceCephfs#path
   */
  readonly path?: string;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
   * @schema PostgresSpecConfigSourceCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema PostgresSpecConfigSourceCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
   *
   * @schema PostgresSpecConfigSourceCephfs#secretRef
   */
  readonly secretRef?: PostgresSpecConfigSourceCephfsSecretRef;

  /**
   * Optional: User is the rados user name, default is admin More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema PostgresSpecConfigSourceCephfs#user
   */
  readonly user?: string;

}

/**
 * Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting to a container. The volume must also be in the same region as the kubelet. Cinder volumes support ownership management and SELinux relabeling.
 *
 * @schema PostgresSpecConfigSourceCinder
 */
export interface PostgresSpecConfigSourceCinder {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
   *
   * @schema PostgresSpecConfigSourceCinder#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
   * @schema PostgresSpecConfigSourceCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
   *
   * @schema PostgresSpecConfigSourceCinder#secretRef
   */
  readonly secretRef?: PostgresSpecConfigSourceCinderSecretRef;

  /**
   * volume id used to identify the volume in cinder More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
   *
   * @schema PostgresSpecConfigSourceCinder#volumeID
   */
  readonly volumeID: string;

}

/**
 * Adapts a ConfigMap into a volume.

The contents of the target ConfigMap's Data field will be presented in a volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. ConfigMap volumes support ownership management and SELinux relabeling.
 *
 * @schema PostgresSpecConfigSourceConfigMap
 */
export interface PostgresSpecConfigSourceConfigMap {
  /**
   * Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema PostgresSpecConfigSourceConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema PostgresSpecConfigSourceConfigMap#items
   */
  readonly items?: PostgresSpecConfigSourceConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecConfigSourceConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or it's keys must be defined
   *
   * @schema PostgresSpecConfigSourceConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Represents a source location of a volume to mount, managed by an external CSI driver
 *
 * @schema PostgresSpecConfigSourceCsi
 */
export interface PostgresSpecConfigSourceCsi {
  /**
   * Driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema PostgresSpecConfigSourceCsi#driver
   */
  readonly driver: string;

  /**
   * Filesystem type to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty value is passed to the associated CSI driver which will determine the default filesystem to apply.
   *
   * @schema PostgresSpecConfigSourceCsi#fsType
   */
  readonly fsType?: string;

  /**
   * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
   *
   * @schema PostgresSpecConfigSourceCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: PostgresSpecConfigSourceCsiNodePublishSecretRef;

  /**
   * Specifies a read-only configuration for the volume. Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema PostgresSpecConfigSourceCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * VolumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values.
   *
   * @schema PostgresSpecConfigSourceCsi#volumeAttributes
   */
  readonly volumeAttributes?: any;

}

/**
 * DownwardAPIVolumeSource represents a volume containing downward API info. Downward API volumes support ownership management and SELinux relabeling.
 *
 * @schema PostgresSpecConfigSourceDownwardApi
 */
export interface PostgresSpecConfigSourceDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema PostgresSpecConfigSourceDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema PostgresSpecConfigSourceDownwardApi#items
   */
  readonly items?: PostgresSpecConfigSourceDownwardApiItems[];

}

/**
 * Represents an empty directory for a pod. Empty directory volumes support ownership management and SELinux relabeling.
 *
 * @schema PostgresSpecConfigSourceEmptyDir
 */
export interface PostgresSpecConfigSourceEmptyDir {
  /**
   * What type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema PostgresSpecConfigSourceEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and Int64() accessors.

The serialization format is:

<quantity>        ::= <signedNumber><suffix>
  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
<digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
<decimalSI>       ::= m | "" | k | M | G | T | P | E
  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
<decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>

No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:
  a. No precision is lost
  b. No fractional digits will be emitted
  c. The exponent (or suffix) is as large as possible.
The sign will be omitted unless the number is negative.

Examples:
  1.5 will be serialized as "1500m"
  1.5Gi will be serialized as "1536Mi"

Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.
   *
   * @schema PostgresSpecConfigSourceEmptyDir#sizeLimit
   */
  readonly sizeLimit?: string;

}

/**
 * Represents a Fibre Channel volume. Fibre Channel volumes can only be mounted as read/write once. Fibre Channel volumes support ownership management and SELinux relabeling.
 *
 * @schema PostgresSpecConfigSourceFc
 */
export interface PostgresSpecConfigSourceFc {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PostgresSpecConfigSourceFc#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: FC target lun number
   *
   * @schema PostgresSpecConfigSourceFc#lun
   */
  readonly lun?: number;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema PostgresSpecConfigSourceFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: FC target worldwide names (WWNs)
   *
   * @schema PostgresSpecConfigSourceFc#targetWWNs
   */
  readonly targetWWNs?: string[];

  /**
   * Optional: FC volume world wide identifiers (wwids) Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema PostgresSpecConfigSourceFc#wwids
   */
  readonly wwids?: string[];

}

/**
 * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
 *
 * @schema PostgresSpecConfigSourceFlexVolume
 */
export interface PostgresSpecConfigSourceFlexVolume {
  /**
   * Driver is the name of the driver to use for this volume.
   *
   * @schema PostgresSpecConfigSourceFlexVolume#driver
   */
  readonly driver: string;

  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema PostgresSpecConfigSourceFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: Extra command options if any.
   *
   * @schema PostgresSpecConfigSourceFlexVolume#options
   */
  readonly options?: any;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema PostgresSpecConfigSourceFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
   *
   * @schema PostgresSpecConfigSourceFlexVolume#secretRef
   */
  readonly secretRef?: PostgresSpecConfigSourceFlexVolumeSecretRef;

}

/**
 * Represents a Flocker volume mounted by the Flocker agent. One and only one of datasetName and datasetUUID should be set. Flocker volumes do not support ownership management or SELinux relabeling.
 *
 * @schema PostgresSpecConfigSourceFlocker
 */
export interface PostgresSpecConfigSourceFlocker {
  /**
   * Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated
   *
   * @schema PostgresSpecConfigSourceFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema PostgresSpecConfigSourceFlocker#datasetUUID
   */
  readonly datasetUUID?: string;

}

/**
 * Represents a Persistent Disk resource in Google Compute Engine.

A GCE PD must exist before mounting to a container. The disk must also be in the same GCE project and zone as the kubelet. A GCE PD can only be mounted as read/write once or read-only many times. GCE PDs support ownership management and SELinux relabeling.
 *
 * @schema PostgresSpecConfigSourceGcePersistentDisk
 */
export interface PostgresSpecConfigSourceGcePersistentDisk {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema PostgresSpecConfigSourceGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema PostgresSpecConfigSourceGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema PostgresSpecConfigSourceGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * @schema PostgresSpecConfigSourceGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Represents a volume that is populated with the contents of a git repository. Git repo volumes do not support ownership management. Git repo volumes support SELinux relabeling.

DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
 *
 * @schema PostgresSpecConfigSourceGitRepo
 */
export interface PostgresSpecConfigSourceGitRepo {
  /**
   * Target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
   *
   * @schema PostgresSpecConfigSourceGitRepo#directory
   */
  readonly directory?: string;

  /**
   * Repository URL
   *
   * @schema PostgresSpecConfigSourceGitRepo#repository
   */
  readonly repository: string;

  /**
   * Commit hash for the specified revision.
   *
   * @schema PostgresSpecConfigSourceGitRepo#revision
   */
  readonly revision?: string;

}

/**
 * Represents a Glusterfs mount that lasts the lifetime of a pod. Glusterfs volumes do not support ownership management or SELinux relabeling.
 *
 * @schema PostgresSpecConfigSourceGlusterfs
 */
export interface PostgresSpecConfigSourceGlusterfs {
  /**
   * EndpointsName is the endpoint name that details Glusterfs topology. More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema PostgresSpecConfigSourceGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * Path is the Glusterfs volume path. More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema PostgresSpecConfigSourceGlusterfs#path
   */
  readonly path: string;

  /**
   * ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false. More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod
   * @schema PostgresSpecConfigSourceGlusterfs#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Represents a host path mapped into a pod. Host path volumes do not support ownership management or SELinux relabeling.
 *
 * @schema PostgresSpecConfigSourceHostPath
 */
export interface PostgresSpecConfigSourceHostPath {
  /**
   * Path of the directory on the host. If the path is a symlink, it will follow the link to the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema PostgresSpecConfigSourceHostPath#path
   */
  readonly path: string;

  /**
   * Type for HostPath Volume Defaults to "" More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema PostgresSpecConfigSourceHostPath#type
   */
  readonly type?: string;

}

/**
 * Represents an ISCSI disk. ISCSI volumes can only be mounted as read/write once. ISCSI volumes support ownership management and SELinux relabeling.
 *
 * @schema PostgresSpecConfigSourceIscsi
 */
export interface PostgresSpecConfigSourceIscsi {
  /**
   * whether support iSCSI Discovery CHAP authentication
   *
   * @schema PostgresSpecConfigSourceIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * whether support iSCSI Session CHAP authentication
   *
   * @schema PostgresSpecConfigSourceIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
   *
   * @schema PostgresSpecConfigSourceIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the connection.
   *
   * @schema PostgresSpecConfigSourceIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * Target iSCSI Qualified Name.
   *
   * @schema PostgresSpecConfigSourceIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema PostgresSpecConfigSourceIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * iSCSI Target Lun number.
   *
   * @schema PostgresSpecConfigSourceIscsi#lun
   */
  readonly lun: number;

  /**
   * iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema PostgresSpecConfigSourceIscsi#portals
   */
  readonly portals?: string[];

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
   *
   * @default false.
   * @schema PostgresSpecConfigSourceIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
   *
   * @schema PostgresSpecConfigSourceIscsi#secretRef
   */
  readonly secretRef?: PostgresSpecConfigSourceIscsiSecretRef;

  /**
   * iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema PostgresSpecConfigSourceIscsi#targetPortal
   */
  readonly targetPortal: string;

}

/**
 * Represents an NFS mount that lasts the lifetime of a pod. NFS volumes do not support ownership management or SELinux relabeling.
 *
 * @schema PostgresSpecConfigSourceNfs
 */
export interface PostgresSpecConfigSourceNfs {
  /**
   * Path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema PostgresSpecConfigSourceNfs#path
   */
  readonly path: string;

  /**
   * ReadOnly here will force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * @schema PostgresSpecConfigSourceNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema PostgresSpecConfigSourceNfs#server
   */
  readonly server: string;

}

/**
 * PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace. This volume finds the bound PV and mounts that volume for the pod. A PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another type of volume that is owned by someone else (the system).
 *
 * @schema PostgresSpecConfigSourcePersistentVolumeClaim
 */
export interface PostgresSpecConfigSourcePersistentVolumeClaim {
  /**
   * ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema PostgresSpecConfigSourcePersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * Will force the ReadOnly setting in VolumeMounts. Default false.
   *
   * @schema PostgresSpecConfigSourcePersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Represents a Photon Controller persistent disk resource.
 *
 * @schema PostgresSpecConfigSourcePhotonPersistentDisk
 */
export interface PostgresSpecConfigSourcePhotonPersistentDisk {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PostgresSpecConfigSourcePhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * ID that identifies Photon Controller persistent disk
   *
   * @schema PostgresSpecConfigSourcePhotonPersistentDisk#pdID
   */
  readonly pdID: string;

}

/**
 * PortworxVolumeSource represents a Portworx volume resource.
 *
 * @schema PostgresSpecConfigSourcePortworxVolume
 */
export interface PostgresSpecConfigSourcePortworxVolume {
  /**
   * FSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PostgresSpecConfigSourcePortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema PostgresSpecConfigSourcePortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * VolumeID uniquely identifies a Portworx volume
   *
   * @schema PostgresSpecConfigSourcePortworxVolume#volumeID
   */
  readonly volumeID: string;

}

/**
 * Represents a projected volume source
 *
 * @schema PostgresSpecConfigSourceProjected
 */
export interface PostgresSpecConfigSourceProjected {
  /**
   * Mode bits to use on created files by default. Must be a value between 0 and 0777. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PostgresSpecConfigSourceProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * list of volume projections
   *
   * @schema PostgresSpecConfigSourceProjected#sources
   */
  readonly sources: PostgresSpecConfigSourceProjectedSources[];

}

/**
 * Represents a Quobyte mount that lasts the lifetime of a pod. Quobyte volumes do not support ownership management or SELinux relabeling.
 *
 * @schema PostgresSpecConfigSourceQuobyte
 */
export interface PostgresSpecConfigSourceQuobyte {
  /**
   * Group to map volume access to Default is no group
   *
   * @default no group
   * @schema PostgresSpecConfigSourceQuobyte#group
   */
  readonly group?: string;

  /**
   * ReadOnly here will force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
   *
   * @default false.
   * @schema PostgresSpecConfigSourceQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
   *
   * @schema PostgresSpecConfigSourceQuobyte#registry
   */
  readonly registry: string;

  /**
   * Tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema PostgresSpecConfigSourceQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * User to map volume access to Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema PostgresSpecConfigSourceQuobyte#user
   */
  readonly user?: string;

  /**
   * Volume is a string that references an already created Quobyte volume by name.
   *
   * @schema PostgresSpecConfigSourceQuobyte#volume
   */
  readonly volume: string;

}

/**
 * Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support ownership management and SELinux relabeling.
 *
 * @schema PostgresSpecConfigSourceRbd
 */
export interface PostgresSpecConfigSourceRbd {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
   *
   * @schema PostgresSpecConfigSourceRbd#fsType
   */
  readonly fsType?: string;

  /**
   * The rados image name. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   *
   * @schema PostgresSpecConfigSourceRbd#image
   */
  readonly image: string;

  /**
   * Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   * @schema PostgresSpecConfigSourceRbd#keyring
   */
  readonly keyring?: string;

  /**
   * A collection of Ceph monitors. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   *
   * @schema PostgresSpecConfigSourceRbd#monitors
   */
  readonly monitors: string[];

  /**
   * The rados pool name. Default is rbd. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   * @schema PostgresSpecConfigSourceRbd#pool
   */
  readonly pool?: string;

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   *
   * @default false. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   * @schema PostgresSpecConfigSourceRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
   *
   * @schema PostgresSpecConfigSourceRbd#secretRef
   */
  readonly secretRef?: PostgresSpecConfigSourceRbdSecretRef;

  /**
   * The rados user name. Default is admin. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   * @schema PostgresSpecConfigSourceRbd#user
   */
  readonly user?: string;

}

/**
 * ScaleIOVolumeSource represents a persistent ScaleIO volume
 *
 * @schema PostgresSpecConfigSourceScaleIo
 */
export interface PostgresSpecConfigSourceScaleIo {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
   *
   * @default xfs".
   * @schema PostgresSpecConfigSourceScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * The host address of the ScaleIO API Gateway.
   *
   * @schema PostgresSpecConfigSourceScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * The name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema PostgresSpecConfigSourceScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema PostgresSpecConfigSourceScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
   *
   * @schema PostgresSpecConfigSourceScaleIo#secretRef
   */
  readonly secretRef: PostgresSpecConfigSourceScaleIoSecretRef;

  /**
   * Flag to enable/disable SSL communication with Gateway, default false
   *
   * @schema PostgresSpecConfigSourceScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned. Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema PostgresSpecConfigSourceScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * The ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema PostgresSpecConfigSourceScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * The name of the storage system as configured in ScaleIO.
   *
   * @schema PostgresSpecConfigSourceScaleIo#system
   */
  readonly system: string;

  /**
   * The name of a volume already created in the ScaleIO system that is associated with this volume source.
   *
   * @schema PostgresSpecConfigSourceScaleIo#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Adapts a Secret into a volume.

The contents of the target Secret's Data field will be presented in a volume as files using the keys in the Data field as the file names. Secret volumes support ownership management and SELinux relabeling.
 *
 * @schema PostgresSpecConfigSourceSecret
 */
export interface PostgresSpecConfigSourceSecret {
  /**
   * Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema PostgresSpecConfigSourceSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema PostgresSpecConfigSourceSecret#items
   */
  readonly items?: PostgresSpecConfigSourceSecretItems[];

  /**
   * Specify whether the Secret or it's keys must be defined
   *
   * @schema PostgresSpecConfigSourceSecret#optional
   */
  readonly optional?: boolean;

  /**
   * Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema PostgresSpecConfigSourceSecret#secretName
   */
  readonly secretName?: string;

}

/**
 * Represents a StorageOS persistent volume resource.
 *
 * @schema PostgresSpecConfigSourceStorageos
 */
export interface PostgresSpecConfigSourceStorageos {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PostgresSpecConfigSourceStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema PostgresSpecConfigSourceStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
   *
   * @schema PostgresSpecConfigSourceStorageos#secretRef
   */
  readonly secretRef?: PostgresSpecConfigSourceStorageosSecretRef;

  /**
   * VolumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.
   *
   * @schema PostgresSpecConfigSourceStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * VolumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to override the default behaviour. Set to "default" if you are not using namespaces within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema PostgresSpecConfigSourceStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;

}

/**
 * Represents a vSphere volume resource.
 *
 * @schema PostgresSpecConfigSourceVsphereVolume
 */
export interface PostgresSpecConfigSourceVsphereVolume {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PostgresSpecConfigSourceVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema PostgresSpecConfigSourceVsphereVolume#storagePolicyID
   */
  readonly storagePolicyID?: string;

  /**
   * Storage Policy Based Management (SPBM) profile name.
   *
   * @schema PostgresSpecConfigSourceVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * Path that identifies vSphere volume vmdk
   *
   * @schema PostgresSpecConfigSourceVsphereVolume#volumePath
   */
  readonly volumePath: string;

}

/**
 * Maps a string key to a path within a volume.
 *
 * @schema PostgresSpecDatabaseSecretItems
 */
export interface PostgresSpecDatabaseSecretItems {
  /**
   * The key to project.
   *
   * @schema PostgresSpecDatabaseSecretItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PostgresSpecDatabaseSecretItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema PostgresSpecDatabaseSecretItems#path
   */
  readonly path: string;

}

/**
 * @schema PostgresSpecInitPostgresWal
 */
export interface PostgresSpecInitPostgresWal {
  /**
   * @schema PostgresSpecInitPostgresWal#azure
   */
  readonly azure?: any;

  /**
   * @schema PostgresSpecInitPostgresWal#b2
   */
  readonly b2?: any;

  /**
   * @schema PostgresSpecInitPostgresWal#backupName
   */
  readonly backupName?: string;

  /**
   * @schema PostgresSpecInitPostgresWal#gcs
   */
  readonly gcs?: any;

  /**
   * @schema PostgresSpecInitPostgresWal#local
   */
  readonly local?: any;

  /**
   * @schema PostgresSpecInitPostgresWal#pitr
   */
  readonly pitr?: PostgresSpecInitPostgresWalPitr;

  /**
   * @schema PostgresSpecInitPostgresWal#rest
   */
  readonly rest?: any;

  /**
   * @schema PostgresSpecInitPostgresWal#s3
   */
  readonly s3?: any;

  /**
   * @schema PostgresSpecInitPostgresWal#storageSecretName
   */
  readonly storageSecretName?: string;

  /**
   * @schema PostgresSpecInitPostgresWal#swift
   */
  readonly swift?: any;

}

/**
 * @schema PostgresSpecInitScriptSource
 */
export interface PostgresSpecInitScriptSource {
  /**
   * Represents a Persistent Disk resource in AWS.

An AWS EBS disk must exist before mounting to a container. The disk must also be in the same AWS zone as the kubelet. An AWS EBS disk can only be mounted as read/write once. AWS EBS volumes support ownership management and SELinux relabeling.
   *
   * @schema PostgresSpecInitScriptSource#awsElasticBlockStore
   */
  readonly awsElasticBlockStore?: PostgresSpecInitScriptSourceAwsElasticBlockStore;

  /**
   * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
   *
   * @schema PostgresSpecInitScriptSource#azureDisk
   */
  readonly azureDisk?: PostgresSpecInitScriptSourceAzureDisk;

  /**
   * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
   *
   * @schema PostgresSpecInitScriptSource#azureFile
   */
  readonly azureFile?: PostgresSpecInitScriptSourceAzureFile;

  /**
   * Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not support ownership management or SELinux relabeling.
   *
   * @schema PostgresSpecInitScriptSource#cephfs
   */
  readonly cephfs?: PostgresSpecInitScriptSourceCephfs;

  /**
   * Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting to a container. The volume must also be in the same region as the kubelet. Cinder volumes support ownership management and SELinux relabeling.
   *
   * @schema PostgresSpecInitScriptSource#cinder
   */
  readonly cinder?: PostgresSpecInitScriptSourceCinder;

  /**
   * Adapts a ConfigMap into a volume.

The contents of the target ConfigMap's Data field will be presented in a volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. ConfigMap volumes support ownership management and SELinux relabeling.
   *
   * @schema PostgresSpecInitScriptSource#configMap
   */
  readonly configMap?: PostgresSpecInitScriptSourceConfigMap;

  /**
   * Represents a source location of a volume to mount, managed by an external CSI driver
   *
   * @schema PostgresSpecInitScriptSource#csi
   */
  readonly csi?: PostgresSpecInitScriptSourceCsi;

  /**
   * DownwardAPIVolumeSource represents a volume containing downward API info. Downward API volumes support ownership management and SELinux relabeling.
   *
   * @schema PostgresSpecInitScriptSource#downwardAPI
   */
  readonly downwardAPI?: PostgresSpecInitScriptSourceDownwardApi;

  /**
   * Represents an empty directory for a pod. Empty directory volumes support ownership management and SELinux relabeling.
   *
   * @schema PostgresSpecInitScriptSource#emptyDir
   */
  readonly emptyDir?: PostgresSpecInitScriptSourceEmptyDir;

  /**
   * Represents a Fibre Channel volume. Fibre Channel volumes can only be mounted as read/write once. Fibre Channel volumes support ownership management and SELinux relabeling.
   *
   * @schema PostgresSpecInitScriptSource#fc
   */
  readonly fc?: PostgresSpecInitScriptSourceFc;

  /**
   * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
   *
   * @schema PostgresSpecInitScriptSource#flexVolume
   */
  readonly flexVolume?: PostgresSpecInitScriptSourceFlexVolume;

  /**
   * Represents a Flocker volume mounted by the Flocker agent. One and only one of datasetName and datasetUUID should be set. Flocker volumes do not support ownership management or SELinux relabeling.
   *
   * @schema PostgresSpecInitScriptSource#flocker
   */
  readonly flocker?: PostgresSpecInitScriptSourceFlocker;

  /**
   * Represents a Persistent Disk resource in Google Compute Engine.

A GCE PD must exist before mounting to a container. The disk must also be in the same GCE project and zone as the kubelet. A GCE PD can only be mounted as read/write once or read-only many times. GCE PDs support ownership management and SELinux relabeling.
   *
   * @schema PostgresSpecInitScriptSource#gcePersistentDisk
   */
  readonly gcePersistentDisk?: PostgresSpecInitScriptSourceGcePersistentDisk;

  /**
   * Represents a volume that is populated with the contents of a git repository. Git repo volumes do not support ownership management. Git repo volumes support SELinux relabeling.

DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
   *
   * @schema PostgresSpecInitScriptSource#gitRepo
   */
  readonly gitRepo?: PostgresSpecInitScriptSourceGitRepo;

  /**
   * Represents a Glusterfs mount that lasts the lifetime of a pod. Glusterfs volumes do not support ownership management or SELinux relabeling.
   *
   * @schema PostgresSpecInitScriptSource#glusterfs
   */
  readonly glusterfs?: PostgresSpecInitScriptSourceGlusterfs;

  /**
   * Represents a host path mapped into a pod. Host path volumes do not support ownership management or SELinux relabeling.
   *
   * @schema PostgresSpecInitScriptSource#hostPath
   */
  readonly hostPath?: PostgresSpecInitScriptSourceHostPath;

  /**
   * Represents an ISCSI disk. ISCSI volumes can only be mounted as read/write once. ISCSI volumes support ownership management and SELinux relabeling.
   *
   * @schema PostgresSpecInitScriptSource#iscsi
   */
  readonly iscsi?: PostgresSpecInitScriptSourceIscsi;

  /**
   * Represents an NFS mount that lasts the lifetime of a pod. NFS volumes do not support ownership management or SELinux relabeling.
   *
   * @schema PostgresSpecInitScriptSource#nfs
   */
  readonly nfs?: PostgresSpecInitScriptSourceNfs;

  /**
   * PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace. This volume finds the bound PV and mounts that volume for the pod. A PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another type of volume that is owned by someone else (the system).
   *
   * @schema PostgresSpecInitScriptSource#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: PostgresSpecInitScriptSourcePersistentVolumeClaim;

  /**
   * Represents a Photon Controller persistent disk resource.
   *
   * @schema PostgresSpecInitScriptSource#photonPersistentDisk
   */
  readonly photonPersistentDisk?: PostgresSpecInitScriptSourcePhotonPersistentDisk;

  /**
   * PortworxVolumeSource represents a Portworx volume resource.
   *
   * @schema PostgresSpecInitScriptSource#portworxVolume
   */
  readonly portworxVolume?: PostgresSpecInitScriptSourcePortworxVolume;

  /**
   * Represents a projected volume source
   *
   * @schema PostgresSpecInitScriptSource#projected
   */
  readonly projected?: PostgresSpecInitScriptSourceProjected;

  /**
   * Represents a Quobyte mount that lasts the lifetime of a pod. Quobyte volumes do not support ownership management or SELinux relabeling.
   *
   * @schema PostgresSpecInitScriptSource#quobyte
   */
  readonly quobyte?: PostgresSpecInitScriptSourceQuobyte;

  /**
   * Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support ownership management and SELinux relabeling.
   *
   * @schema PostgresSpecInitScriptSource#rbd
   */
  readonly rbd?: PostgresSpecInitScriptSourceRbd;

  /**
   * ScaleIOVolumeSource represents a persistent ScaleIO volume
   *
   * @schema PostgresSpecInitScriptSource#scaleIO
   */
  readonly scaleIO?: PostgresSpecInitScriptSourceScaleIo;

  /**
   * @schema PostgresSpecInitScriptSource#scriptPath
   */
  readonly scriptPath?: string;

  /**
   * Adapts a Secret into a volume.

The contents of the target Secret's Data field will be presented in a volume as files using the keys in the Data field as the file names. Secret volumes support ownership management and SELinux relabeling.
   *
   * @schema PostgresSpecInitScriptSource#secret
   */
  readonly secret?: PostgresSpecInitScriptSourceSecret;

  /**
   * Represents a StorageOS persistent volume resource.
   *
   * @schema PostgresSpecInitScriptSource#storageos
   */
  readonly storageos?: PostgresSpecInitScriptSourceStorageos;

  /**
   * Represents a vSphere volume resource.
   *
   * @schema PostgresSpecInitScriptSource#vsphereVolume
   */
  readonly vsphereVolume?: PostgresSpecInitScriptSourceVsphereVolume;

}

/**
 * @schema PostgresSpecInitSnapshotSource
 */
export interface PostgresSpecInitSnapshotSource {
  /**
   * Arguments to the restore job
   *
   * @schema PostgresSpecInitSnapshotSource#args
   */
  readonly args?: string[];

  /**
   * @schema PostgresSpecInitSnapshotSource#name
   */
  readonly name: string;

  /**
   * @schema PostgresSpecInitSnapshotSource#namespace
   */
  readonly namespace: string;

}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema PostgresSpecInitStashRestoreSession
 */
export interface PostgresSpecInitStashRestoreSession {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecInitStashRestoreSession#name
   */
  readonly name?: string;

}

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema PostgresSpecMonitorEnv
 */
export interface PostgresSpecMonitorEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema PostgresSpecMonitorEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema PostgresSpecMonitorEnv#value
   */
  readonly value?: string;

  /**
   * EnvVarSource represents a source for the value of an EnvVar.
   *
   * @schema PostgresSpecMonitorEnv#valueFrom
   */
  readonly valueFrom?: PostgresSpecMonitorEnvValueFrom;

}

/**
 * @schema PostgresSpecMonitorPrometheus
 */
export interface PostgresSpecMonitorPrometheus {
  /**
   * Interval at which metrics should be scraped
   *
   * @schema PostgresSpecMonitorPrometheus#interval
   */
  readonly interval?: string;

  /**
   * Labels are key value pairs that is used to select Prometheus instance via ServiceMonitor labels.
   *
   * @schema PostgresSpecMonitorPrometheus#labels
   */
  readonly labels?: any;

  /**
   * Namespace of Prometheus. Service monitors will be created in this namespace.
   *
   * @schema PostgresSpecMonitorPrometheus#namespace
   */
  readonly namespace?: string;

  /**
   * Port number for the exporter side car.
   *
   * @schema PostgresSpecMonitorPrometheus#port
   */
  readonly port?: number;

}

/**
 * ResourceRequirements describes the compute resource requirements.
 *
 * @schema PostgresSpecMonitorResources
 */
export interface PostgresSpecMonitorResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   *
   * @schema PostgresSpecMonitorResources#limits
   */
  readonly limits?: any;

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   *
   * @schema PostgresSpecMonitorResources#requests
   */
  readonly requests?: any;

}

/**
 * SecurityContext holds security configuration that will be applied to a container. Some fields are present in both SecurityContext and PodSecurityContext.  When both are set, the values in SecurityContext take precedence.
 *
 * @schema PostgresSpecMonitorSecurityContext
 */
export interface PostgresSpecMonitorSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN
   *
   * @schema PostgresSpecMonitorSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * Adds and removes POSIX capabilities from running containers.
   *
   * @schema PostgresSpecMonitorSecurityContext#capabilities
   */
  readonly capabilities?: PostgresSpecMonitorSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false.
   *
   * @default false.
   * @schema PostgresSpecMonitorSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled.
   *
   * @schema PostgresSpecMonitorSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false.
   *
   * @default false.
   * @schema PostgresSpecMonitorSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema PostgresSpecMonitorSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema PostgresSpecMonitorSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema PostgresSpecMonitorSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * SELinuxOptions are the labels to be applied to the container
   *
   * @schema PostgresSpecMonitorSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: PostgresSpecMonitorSecurityContextSeLinuxOptions;

}

/**
 * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
 *
 * @schema PostgresSpecPodTemplateController
 */
export interface PostgresSpecPodTemplateController {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema PostgresSpecPodTemplateController#annotations
   */
  readonly annotations?: any;

}

/**
 * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
 *
 * @schema PostgresSpecPodTemplateMetadata
 */
export interface PostgresSpecPodTemplateMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema PostgresSpecPodTemplateMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema PostgresSpecPodTemplateSpec
 */
export interface PostgresSpecPodTemplateSpec {
  /**
   * Affinity is a group of affinity scheduling rules.
   *
   * @schema PostgresSpecPodTemplateSpec#affinity
   */
  readonly affinity?: PostgresSpecPodTemplateSpecAffinity;

  /**
   * Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema PostgresSpecPodTemplateSpec#args
   */
  readonly args?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema PostgresSpecPodTemplateSpec#env
   */
  readonly env?: PostgresSpecPodTemplateSpecEnv[];

  /**
   * ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use.
   *
   * @schema PostgresSpecPodTemplateSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: PostgresSpecPodTemplateSpecImagePullSecrets[];

  /**
   * List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, or Liveness probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema PostgresSpecPodTemplateSpec#initContainers
   */
  readonly initContainers?: PostgresSpecPodTemplateSpecInitContainers[];

  /**
   * Lifecycle describes actions that the management system should take in response to container lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the container blocks until the action is complete, unless the container process fails, in which case the handler is aborted.
   *
   * @schema PostgresSpecPodTemplateSpec#lifecycle
   */
  readonly lifecycle?: PostgresSpecPodTemplateSpecLifecycle;

  /**
   * Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
   *
   * @schema PostgresSpecPodTemplateSpec#livenessProbe
   */
  readonly livenessProbe?: PostgresSpecPodTemplateSpecLivenessProbe;

  /**
   * NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   *
   * @schema PostgresSpecPodTemplateSpec#nodeSelector
   */
  readonly nodeSelector?: any;

  /**
   * The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.
   *
   * @schema PostgresSpecPodTemplateSpec#priority
   */
  readonly priority?: number;

  /**
   * If specified, indicates the pod's priority. "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.
   *
   * @schema PostgresSpecPodTemplateSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
   *
   * @schema PostgresSpecPodTemplateSpec#readinessProbe
   */
  readonly readinessProbe?: PostgresSpecPodTemplateSpecReadinessProbe;

  /**
   * ResourceRequirements describes the compute resource requirements.
   *
   * @schema PostgresSpecPodTemplateSpec#resources
   */
  readonly resources?: PostgresSpecPodTemplateSpecResources;

  /**
   * If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.
   *
   * @schema PostgresSpecPodTemplateSpec#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * PodSecurityContext holds pod-level security attributes and common container settings. Some fields are also present in container.securityContext.  Field values of container.securityContext take precedence over field values of PodSecurityContext.
   *
   * @schema PostgresSpecPodTemplateSpec#securityContext
   */
  readonly securityContext?: PostgresSpecPodTemplateSpecSecurityContext;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
   *
   * @schema PostgresSpecPodTemplateSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * If specified, the pod's tolerations.
   *
   * @schema PostgresSpecPodTemplateSpec#tolerations
   */
  readonly tolerations?: PostgresSpecPodTemplateSpecTolerations[];

}

/**
 * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
 *
 * @schema PostgresSpecReplicaServiceTemplateMetadata
 */
export interface PostgresSpecReplicaServiceTemplateMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema PostgresSpecReplicaServiceTemplateMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * ServiceSpec describes the attributes that a user creates on a service.
 *
 * @schema PostgresSpecReplicaServiceTemplateSpec
 */
export interface PostgresSpecReplicaServiceTemplateSpec {
  /**
   * clusterIP is the IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are "None", empty string (""), or a valid IP address. "None" can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   *
   * @schema PostgresSpecReplicaServiceTemplateSpec#clusterIP
   */
  readonly clusterIP?: string;

  /**
   * externalIPs is a list of IP addresses for which nodes in the cluster will also accept traffic for this service.  These IPs are not managed by Kubernetes.  The user is responsible for ensuring that traffic arrives at a node with this IP.  A common example is external load-balancers that are not part of the Kubernetes system.
   *
   * @schema PostgresSpecReplicaServiceTemplateSpec#externalIPs
   */
  readonly externalIPs?: string[];

  /**
   * externalTrafficPolicy denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints. "Local" preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading. "Cluster" obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading.
   *
   * @schema PostgresSpecReplicaServiceTemplateSpec#externalTrafficPolicy
   */
  readonly externalTrafficPolicy?: string;

  /**
   * healthCheckNodePort specifies the healthcheck nodePort for the service. If not specified, HealthCheckNodePort is created by the service api backend with the allocated nodePort. Will use user-specified nodePort value if specified by the client. Only effects when Type is set to LoadBalancer and ExternalTrafficPolicy is set to Local.
   *
   * @schema PostgresSpecReplicaServiceTemplateSpec#healthCheckNodePort
   */
  readonly healthCheckNodePort?: number;

  /**
   * Only applies to Service Type: LoadBalancer LoadBalancer will get created with the IP specified in this field. This feature depends on whether the underlying cloud-provider supports specifying the loadBalancerIP when a load balancer is created. This field will be ignored if the cloud-provider does not support the feature.
   *
   * @schema PostgresSpecReplicaServiceTemplateSpec#loadBalancerIP
   */
  readonly loadBalancerIP?: string;

  /**
   * If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature." More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/
   *
   * @schema PostgresSpecReplicaServiceTemplateSpec#loadBalancerSourceRanges
   */
  readonly loadBalancerSourceRanges?: string[];

  /**
   * The list of ports that are exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   *
   * @schema PostgresSpecReplicaServiceTemplateSpec#ports
   */
  readonly ports?: PostgresSpecReplicaServiceTemplateSpecPorts[];

  /**
   * type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. "ExternalName" maps to the specified externalName. "ClusterIP" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a stable IP. "NodePort" builds on ClusterIP and allocates a port on every node which routes to the clusterIP. "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the clusterIP. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types
   *
   * @default ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. "ExternalName" maps to the specified externalName. "ClusterIP" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a stable IP. "NodePort" builds on ClusterIP and allocates a port on every node which routes to the clusterIP. "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the clusterIP. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types
   * @schema PostgresSpecReplicaServiceTemplateSpec#type
   */
  readonly type?: string;

}

/**
 * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
 *
 * @schema PostgresSpecServiceTemplateMetadata
 */
export interface PostgresSpecServiceTemplateMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema PostgresSpecServiceTemplateMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * ServiceSpec describes the attributes that a user creates on a service.
 *
 * @schema PostgresSpecServiceTemplateSpec
 */
export interface PostgresSpecServiceTemplateSpec {
  /**
   * clusterIP is the IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are "None", empty string (""), or a valid IP address. "None" can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   *
   * @schema PostgresSpecServiceTemplateSpec#clusterIP
   */
  readonly clusterIP?: string;

  /**
   * externalIPs is a list of IP addresses for which nodes in the cluster will also accept traffic for this service.  These IPs are not managed by Kubernetes.  The user is responsible for ensuring that traffic arrives at a node with this IP.  A common example is external load-balancers that are not part of the Kubernetes system.
   *
   * @schema PostgresSpecServiceTemplateSpec#externalIPs
   */
  readonly externalIPs?: string[];

  /**
   * externalTrafficPolicy denotes if this Service desires to route external traffic to node-local or cluster-wide endpoints. "Local" preserves the client source IP and avoids a second hop for LoadBalancer and Nodeport type services, but risks potentially imbalanced traffic spreading. "Cluster" obscures the client source IP and may cause a second hop to another node, but should have good overall load-spreading.
   *
   * @schema PostgresSpecServiceTemplateSpec#externalTrafficPolicy
   */
  readonly externalTrafficPolicy?: string;

  /**
   * healthCheckNodePort specifies the healthcheck nodePort for the service. If not specified, HealthCheckNodePort is created by the service api backend with the allocated nodePort. Will use user-specified nodePort value if specified by the client. Only effects when Type is set to LoadBalancer and ExternalTrafficPolicy is set to Local.
   *
   * @schema PostgresSpecServiceTemplateSpec#healthCheckNodePort
   */
  readonly healthCheckNodePort?: number;

  /**
   * Only applies to Service Type: LoadBalancer LoadBalancer will get created with the IP specified in this field. This feature depends on whether the underlying cloud-provider supports specifying the loadBalancerIP when a load balancer is created. This field will be ignored if the cloud-provider does not support the feature.
   *
   * @schema PostgresSpecServiceTemplateSpec#loadBalancerIP
   */
  readonly loadBalancerIP?: string;

  /**
   * If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature." More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/
   *
   * @schema PostgresSpecServiceTemplateSpec#loadBalancerSourceRanges
   */
  readonly loadBalancerSourceRanges?: string[];

  /**
   * The list of ports that are exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
   *
   * @schema PostgresSpecServiceTemplateSpec#ports
   */
  readonly ports?: PostgresSpecServiceTemplateSpecPorts[];

  /**
   * type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. "ExternalName" maps to the specified externalName. "ClusterIP" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a stable IP. "NodePort" builds on ClusterIP and allocates a port on every node which routes to the clusterIP. "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the clusterIP. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types
   *
   * @default ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. "ExternalName" maps to the specified externalName. "ClusterIP" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a stable IP. "NodePort" builds on ClusterIP and allocates a port on every node which routes to the clusterIP. "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the clusterIP. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types
   * @schema PostgresSpecServiceTemplateSpec#type
   */
  readonly type?: string;

}

/**
 * TypedLocalObjectReference contains enough information to let you locate the typed referenced object inside the same namespace.
 *
 * @schema PostgresSpecStorageDataSource
 */
export interface PostgresSpecStorageDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema PostgresSpecStorageDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema PostgresSpecStorageDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema PostgresSpecStorageDataSource#name
   */
  readonly name: string;

}

/**
 * ResourceRequirements describes the compute resource requirements.
 *
 * @schema PostgresSpecStorageResources
 */
export interface PostgresSpecStorageResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   *
   * @schema PostgresSpecStorageResources#limits
   */
  readonly limits?: any;

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   *
   * @schema PostgresSpecStorageResources#requests
   */
  readonly requests?: any;

}

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema PostgresSpecStorageSelector
 */
export interface PostgresSpecStorageSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PostgresSpecStorageSelector#matchExpressions
   */
  readonly matchExpressions?: PostgresSpecStorageSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PostgresSpecStorageSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * RollingUpdateStatefulSetStrategy is used to communicate parameter for RollingUpdateStatefulSetStrategyType.
 *
 * @schema PostgresSpecUpdateStrategyRollingUpdate
 */
export interface PostgresSpecUpdateStrategyRollingUpdate {
  /**
   * Partition indicates the ordinal at which the StatefulSet should be partitioned. Default value is 0.
   *
   * @schema PostgresSpecUpdateStrategyRollingUpdate#partition
   */
  readonly partition?: number;

}

/**
 * StatusDetails is a set of additional properties that MAY be set by the server to provide additional information about a response. The Reason field of a Status object defines what attributes will be set. Clients must ignore fields that do not match the defined type of each attribute, and should assume that any attribute may be empty, invalid, or under defined.
 *
 * @schema PostgresMetadataInitializersResultDetails
 */
export interface PostgresMetadataInitializersResultDetails {
  /**
   * The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
   *
   * @schema PostgresMetadataInitializersResultDetails#causes
   */
  readonly causes?: PostgresMetadataInitializersResultDetailsCauses[];

  /**
   * The group attribute of the resource associated with the status StatusReason.
   *
   * @schema PostgresMetadataInitializersResultDetails#group
   */
  readonly group?: string;

  /**
   * The kind attribute of the resource associated with the status StatusReason. On some operations may differ from the requested resource Kind. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
   *
   * @schema PostgresMetadataInitializersResultDetails#kind
   */
  readonly kind?: string;

  /**
   * The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
   *
   * @schema PostgresMetadataInitializersResultDetails#name
   */
  readonly name?: string;

  /**
   * If specified, the time in seconds before the operation should be retried. Some errors may indicate the client must take an alternate action - for those errors this field may indicate how long to wait before taking the alternate action.
   *
   * @schema PostgresMetadataInitializersResultDetails#retryAfterSeconds
   */
  readonly retryAfterSeconds?: number;

  /**
   * UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
   *
   * @schema PostgresMetadataInitializersResultDetails#uid
   */
  readonly uid?: string;

}

/**
 * ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
 *
 * @schema PostgresMetadataInitializersResultMetadata
 */
export interface PostgresMetadataInitializersResultMetadata {
  /**
   * continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message.
   *
   * @schema PostgresMetadataInitializersResultMetadata#continue
   */
  readonly continue?: string;

  /**
   * String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#concurrency-control-and-consistency
   *
   * @schema PostgresMetadataInitializersResultMetadata#resourceVersion
   */
  readonly resourceVersion?: string;

  /**
   * selfLink is a URL representing this object. Populated by the system. Read-only.
   *
   * @schema PostgresMetadataInitializersResultMetadata#selfLink
   */
  readonly selfLink?: string;

}

/**
 * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateController
 */
export interface PostgresSpecBackupSchedulePodTemplateController {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema PostgresSpecBackupSchedulePodTemplateController#annotations
   */
  readonly annotations?: any;

}

/**
 * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateMetadata
 */
export interface PostgresSpecBackupSchedulePodTemplateMetadata {
  /**
   * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
   *
   * @schema PostgresSpecBackupSchedulePodTemplateMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema PostgresSpecBackupSchedulePodTemplateSpec
 */
export interface PostgresSpecBackupSchedulePodTemplateSpec {
  /**
   * Affinity is a group of affinity scheduling rules.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpec#affinity
   */
  readonly affinity?: PostgresSpecBackupSchedulePodTemplateSpecAffinity;

  /**
   * Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpec#args
   */
  readonly args?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpec#env
   */
  readonly env?: PostgresSpecBackupSchedulePodTemplateSpecEnv[];

  /**
   * ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpec#imagePullSecrets
   */
  readonly imagePullSecrets?: PostgresSpecBackupSchedulePodTemplateSpecImagePullSecrets[];

  /**
   * List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, or Liveness probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpec#initContainers
   */
  readonly initContainers?: PostgresSpecBackupSchedulePodTemplateSpecInitContainers[];

  /**
   * Lifecycle describes actions that the management system should take in response to container lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the container blocks until the action is complete, unless the container process fails, in which case the handler is aborted.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpec#lifecycle
   */
  readonly lifecycle?: PostgresSpecBackupSchedulePodTemplateSpecLifecycle;

  /**
   * Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpec#livenessProbe
   */
  readonly livenessProbe?: PostgresSpecBackupSchedulePodTemplateSpecLivenessProbe;

  /**
   * NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpec#nodeSelector
   */
  readonly nodeSelector?: any;

  /**
   * The priority value. Various system components use this field to find the priority of the pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpec#priority
   */
  readonly priority?: number;

  /**
   * If specified, indicates the pod's priority. "system-node-critical" and "system-cluster-critical" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpec#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpec#readinessProbe
   */
  readonly readinessProbe?: PostgresSpecBackupSchedulePodTemplateSpecReadinessProbe;

  /**
   * ResourceRequirements describes the compute resource requirements.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpec#resources
   */
  readonly resources?: PostgresSpecBackupSchedulePodTemplateSpecResources;

  /**
   * If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpec#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * PodSecurityContext holds pod-level security attributes and common container settings. Some fields are also present in container.securityContext.  Field values of container.securityContext take precedence over field values of PodSecurityContext.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpec#securityContext
   */
  readonly securityContext?: PostgresSpecBackupSchedulePodTemplateSpecSecurityContext;

  /**
   * ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpec#serviceAccountName
   */
  readonly serviceAccountName?: string;

  /**
   * If specified, the pod's tolerations.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpec#tolerations
   */
  readonly tolerations?: PostgresSpecBackupSchedulePodTemplateSpecTolerations[];

}

/**
 * TypedLocalObjectReference contains enough information to let you locate the typed referenced object inside the same namespace.
 *
 * @schema PostgresSpecBackupSchedulePodVolumeClaimSpecDataSource
 */
export interface PostgresSpecBackupSchedulePodVolumeClaimSpecDataSource {
  /**
   * APIGroup is the group for the resource being referenced. If APIGroup is not specified, the specified Kind must be in the core API group. For any other third-party types, APIGroup is required.
   *
   * @schema PostgresSpecBackupSchedulePodVolumeClaimSpecDataSource#apiGroup
   */
  readonly apiGroup?: string;

  /**
   * Kind is the type of resource being referenced
   *
   * @schema PostgresSpecBackupSchedulePodVolumeClaimSpecDataSource#kind
   */
  readonly kind: string;

  /**
   * Name is the name of resource being referenced
   *
   * @schema PostgresSpecBackupSchedulePodVolumeClaimSpecDataSource#name
   */
  readonly name: string;

}

/**
 * ResourceRequirements describes the compute resource requirements.
 *
 * @schema PostgresSpecBackupSchedulePodVolumeClaimSpecResources
 */
export interface PostgresSpecBackupSchedulePodVolumeClaimSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   *
   * @schema PostgresSpecBackupSchedulePodVolumeClaimSpecResources#limits
   */
  readonly limits?: any;

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   *
   * @schema PostgresSpecBackupSchedulePodVolumeClaimSpecResources#requests
   */
  readonly requests?: any;

}

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema PostgresSpecBackupSchedulePodVolumeClaimSpecSelector
 */
export interface PostgresSpecBackupSchedulePodVolumeClaimSpecSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PostgresSpecBackupSchedulePodVolumeClaimSpecSelector#matchExpressions
   */
  readonly matchExpressions?: PostgresSpecBackupSchedulePodVolumeClaimSpecSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PostgresSpecBackupSchedulePodVolumeClaimSpecSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema PostgresSpecConfigSourceCephfsSecretRef
 */
export interface PostgresSpecConfigSourceCephfsSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecConfigSourceCephfsSecretRef#name
   */
  readonly name?: string;

}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema PostgresSpecConfigSourceCinderSecretRef
 */
export interface PostgresSpecConfigSourceCinderSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecConfigSourceCinderSecretRef#name
   */
  readonly name?: string;

}

/**
 * Maps a string key to a path within a volume.
 *
 * @schema PostgresSpecConfigSourceConfigMapItems
 */
export interface PostgresSpecConfigSourceConfigMapItems {
  /**
   * The key to project.
   *
   * @schema PostgresSpecConfigSourceConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PostgresSpecConfigSourceConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema PostgresSpecConfigSourceConfigMapItems#path
   */
  readonly path: string;

}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema PostgresSpecConfigSourceCsiNodePublishSecretRef
 */
export interface PostgresSpecConfigSourceCsiNodePublishSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecConfigSourceCsiNodePublishSecretRef#name
   */
  readonly name?: string;

}

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema PostgresSpecConfigSourceDownwardApiItems
 */
export interface PostgresSpecConfigSourceDownwardApiItems {
  /**
   * ObjectFieldSelector selects an APIVersioned field of an object.
   *
   * @schema PostgresSpecConfigSourceDownwardApiItems#fieldRef
   */
  readonly fieldRef?: PostgresSpecConfigSourceDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PostgresSpecConfigSourceDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema PostgresSpecConfigSourceDownwardApiItems#path
   */
  readonly path: string;

  /**
   * ResourceFieldSelector represents container resources (cpu, memory) and their output format
   *
   * @schema PostgresSpecConfigSourceDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: PostgresSpecConfigSourceDownwardApiItemsResourceFieldRef;

}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema PostgresSpecConfigSourceFlexVolumeSecretRef
 */
export interface PostgresSpecConfigSourceFlexVolumeSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecConfigSourceFlexVolumeSecretRef#name
   */
  readonly name?: string;

}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema PostgresSpecConfigSourceIscsiSecretRef
 */
export interface PostgresSpecConfigSourceIscsiSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecConfigSourceIscsiSecretRef#name
   */
  readonly name?: string;

}

/**
 * Projection that may be projected along with other supported volume types
 *
 * @schema PostgresSpecConfigSourceProjectedSources
 */
export interface PostgresSpecConfigSourceProjectedSources {
  /**
   * Adapts a ConfigMap into a projected volume.

The contents of the target ConfigMap's Data field will be presented in a projected volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. Note that this is identical to a configmap volume source without the default mode.
   *
   * @schema PostgresSpecConfigSourceProjectedSources#configMap
   */
  readonly configMap?: PostgresSpecConfigSourceProjectedSourcesConfigMap;

  /**
   * Represents downward API info for projecting into a projected volume. Note that this is identical to a downwardAPI volume source without the default mode.
   *
   * @schema PostgresSpecConfigSourceProjectedSources#downwardAPI
   */
  readonly downwardAPI?: PostgresSpecConfigSourceProjectedSourcesDownwardApi;

  /**
   * Adapts a secret into a projected volume.

The contents of the target Secret's Data field will be presented in a projected volume as files using the keys in the Data field as the file names. Note that this is identical to a secret volume source without the default mode.
   *
   * @schema PostgresSpecConfigSourceProjectedSources#secret
   */
  readonly secret?: PostgresSpecConfigSourceProjectedSourcesSecret;

  /**
   * ServiceAccountTokenProjection represents a projected service account token volume. This projection can be used to insert a service account token into the pods runtime filesystem for use against APIs (Kubernetes API Server or otherwise).
   *
   * @schema PostgresSpecConfigSourceProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: PostgresSpecConfigSourceProjectedSourcesServiceAccountToken;

}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema PostgresSpecConfigSourceRbdSecretRef
 */
export interface PostgresSpecConfigSourceRbdSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecConfigSourceRbdSecretRef#name
   */
  readonly name?: string;

}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema PostgresSpecConfigSourceScaleIoSecretRef
 */
export interface PostgresSpecConfigSourceScaleIoSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecConfigSourceScaleIoSecretRef#name
   */
  readonly name?: string;

}

/**
 * Maps a string key to a path within a volume.
 *
 * @schema PostgresSpecConfigSourceSecretItems
 */
export interface PostgresSpecConfigSourceSecretItems {
  /**
   * The key to project.
   *
   * @schema PostgresSpecConfigSourceSecretItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PostgresSpecConfigSourceSecretItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema PostgresSpecConfigSourceSecretItems#path
   */
  readonly path: string;

}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema PostgresSpecConfigSourceStorageosSecretRef
 */
export interface PostgresSpecConfigSourceStorageosSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecConfigSourceStorageosSecretRef#name
   */
  readonly name?: string;

}

/**
 * @schema PostgresSpecInitPostgresWalPitr
 */
export interface PostgresSpecInitPostgresWalPitr {
  /**
   * TargetInclusive specifies whether to include ongoing transaction in given target point.
   *
   * @schema PostgresSpecInitPostgresWalPitr#targetInclusive
   */
  readonly targetInclusive?: boolean;

  /**
   * TargetTime specifies the time stamp up to which recovery will proceed.
   *
   * @schema PostgresSpecInitPostgresWalPitr#targetTime
   */
  readonly targetTime?: string;

  /**
   * TargetTimeline specifies recovering into a particular timeline. The default is to recover along the same timeline that was current when the base backup was taken.
   *
   * @schema PostgresSpecInitPostgresWalPitr#targetTimeline
   */
  readonly targetTimeline?: string;

  /**
   * TargetXID specifies the transaction ID up to which recovery will proceed.
   *
   * @schema PostgresSpecInitPostgresWalPitr#targetXID
   */
  readonly targetXID?: string;

}

/**
 * Represents a Persistent Disk resource in AWS.

An AWS EBS disk must exist before mounting to a container. The disk must also be in the same AWS zone as the kubelet. An AWS EBS disk can only be mounted as read/write once. AWS EBS volumes support ownership management and SELinux relabeling.
 *
 * @schema PostgresSpecInitScriptSourceAwsElasticBlockStore
 */
export interface PostgresSpecInitScriptSourceAwsElasticBlockStore {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema PostgresSpecInitScriptSourceAwsElasticBlockStore#fsType
   */
  readonly fsType?: string;

  /**
   * The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
   *
   * @schema PostgresSpecInitScriptSourceAwsElasticBlockStore#partition
   */
  readonly partition?: number;

  /**
   * Specify "true" to force and set the ReadOnly property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema PostgresSpecInitScriptSourceAwsElasticBlockStore#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
   *
   * @schema PostgresSpecInitScriptSourceAwsElasticBlockStore#volumeID
   */
  readonly volumeID: string;

}

/**
 * AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
 *
 * @schema PostgresSpecInitScriptSourceAzureDisk
 */
export interface PostgresSpecInitScriptSourceAzureDisk {
  /**
   * Host Caching mode: None, Read Only, Read Write.
   *
   * @schema PostgresSpecInitScriptSourceAzureDisk#cachingMode
   */
  readonly cachingMode?: string;

  /**
   * The Name of the data disk in the blob storage
   *
   * @schema PostgresSpecInitScriptSourceAzureDisk#diskName
   */
  readonly diskName: string;

  /**
   * The URI the data disk in the blob storage
   *
   * @schema PostgresSpecInitScriptSourceAzureDisk#diskURI
   */
  readonly diskURI: string;

  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PostgresSpecInitScriptSourceAzureDisk#fsType
   */
  readonly fsType?: string;

  /**
   * Expected values Shared: multiple blob disks per storage account  Dedicated: single blob disk per storage account  Managed: azure managed data disk (only in managed availability set). defaults to shared
   *
   * @schema PostgresSpecInitScriptSourceAzureDisk#kind
   */
  readonly kind?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema PostgresSpecInitScriptSourceAzureDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
 *
 * @schema PostgresSpecInitScriptSourceAzureFile
 */
export interface PostgresSpecInitScriptSourceAzureFile {
  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema PostgresSpecInitScriptSourceAzureFile#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * the name of secret that contains Azure Storage Account Name and Key
   *
   * @schema PostgresSpecInitScriptSourceAzureFile#secretName
   */
  readonly secretName: string;

  /**
   * Share Name
   *
   * @schema PostgresSpecInitScriptSourceAzureFile#shareName
   */
  readonly shareName: string;

}

/**
 * Represents a Ceph Filesystem mount that lasts the lifetime of a pod Cephfs volumes do not support ownership management or SELinux relabeling.
 *
 * @schema PostgresSpecInitScriptSourceCephfs
 */
export interface PostgresSpecInitScriptSourceCephfs {
  /**
   * Required: Monitors is a collection of Ceph monitors More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema PostgresSpecInitScriptSourceCephfs#monitors
   */
  readonly monitors: string[];

  /**
   * Optional: Used as the mounted root, rather than the full Ceph tree, default is /
   *
   * @schema PostgresSpecInitScriptSourceCephfs#path
   */
  readonly path?: string;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
   * @schema PostgresSpecInitScriptSourceCephfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema PostgresSpecInitScriptSourceCephfs#secretFile
   */
  readonly secretFile?: string;

  /**
   * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
   *
   * @schema PostgresSpecInitScriptSourceCephfs#secretRef
   */
  readonly secretRef?: PostgresSpecInitScriptSourceCephfsSecretRef;

  /**
   * Optional: User is the rados user name, default is admin More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
   *
   * @schema PostgresSpecInitScriptSourceCephfs#user
   */
  readonly user?: string;

}

/**
 * Represents a cinder volume resource in Openstack. A Cinder volume must exist before mounting to a container. The volume must also be in the same region as the kubelet. Cinder volumes support ownership management and SELinux relabeling.
 *
 * @schema PostgresSpecInitScriptSourceCinder
 */
export interface PostgresSpecInitScriptSourceCinder {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
   *
   * @schema PostgresSpecInitScriptSourceCinder#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
   * @schema PostgresSpecInitScriptSourceCinder#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
   *
   * @schema PostgresSpecInitScriptSourceCinder#secretRef
   */
  readonly secretRef?: PostgresSpecInitScriptSourceCinderSecretRef;

  /**
   * volume id used to identify the volume in cinder More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
   *
   * @schema PostgresSpecInitScriptSourceCinder#volumeID
   */
  readonly volumeID: string;

}

/**
 * Adapts a ConfigMap into a volume.

The contents of the target ConfigMap's Data field will be presented in a volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. ConfigMap volumes support ownership management and SELinux relabeling.
 *
 * @schema PostgresSpecInitScriptSourceConfigMap
 */
export interface PostgresSpecInitScriptSourceConfigMap {
  /**
   * Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema PostgresSpecInitScriptSourceConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema PostgresSpecInitScriptSourceConfigMap#items
   */
  readonly items?: PostgresSpecInitScriptSourceConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecInitScriptSourceConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or it's keys must be defined
   *
   * @schema PostgresSpecInitScriptSourceConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Represents a source location of a volume to mount, managed by an external CSI driver
 *
 * @schema PostgresSpecInitScriptSourceCsi
 */
export interface PostgresSpecInitScriptSourceCsi {
  /**
   * Driver is the name of the CSI driver that handles this volume. Consult with your admin for the correct name as registered in the cluster.
   *
   * @schema PostgresSpecInitScriptSourceCsi#driver
   */
  readonly driver: string;

  /**
   * Filesystem type to mount. Ex. "ext4", "xfs", "ntfs". If not provided, the empty value is passed to the associated CSI driver which will determine the default filesystem to apply.
   *
   * @schema PostgresSpecInitScriptSourceCsi#fsType
   */
  readonly fsType?: string;

  /**
   * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
   *
   * @schema PostgresSpecInitScriptSourceCsi#nodePublishSecretRef
   */
  readonly nodePublishSecretRef?: PostgresSpecInitScriptSourceCsiNodePublishSecretRef;

  /**
   * Specifies a read-only configuration for the volume. Defaults to false (read/write).
   *
   * @default false (read/write).
   * @schema PostgresSpecInitScriptSourceCsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * VolumeAttributes stores driver-specific properties that are passed to the CSI driver. Consult your driver's documentation for supported values.
   *
   * @schema PostgresSpecInitScriptSourceCsi#volumeAttributes
   */
  readonly volumeAttributes?: any;

}

/**
 * DownwardAPIVolumeSource represents a volume containing downward API info. Downward API volumes support ownership management and SELinux relabeling.
 *
 * @schema PostgresSpecInitScriptSourceDownwardApi
 */
export interface PostgresSpecInitScriptSourceDownwardApi {
  /**
   * Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema PostgresSpecInitScriptSourceDownwardApi#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * Items is a list of downward API volume file
   *
   * @schema PostgresSpecInitScriptSourceDownwardApi#items
   */
  readonly items?: PostgresSpecInitScriptSourceDownwardApiItems[];

}

/**
 * Represents an empty directory for a pod. Empty directory volumes support ownership management and SELinux relabeling.
 *
 * @schema PostgresSpecInitScriptSourceEmptyDir
 */
export interface PostgresSpecInitScriptSourceEmptyDir {
  /**
   * What type of storage medium should back this directory. The default is "" which means to use the node's default medium. Must be an empty string (default) or Memory. More info: https://kubernetes.io/docs/concepts/storage/volumes#emptydir
   *
   * @schema PostgresSpecInitScriptSourceEmptyDir#medium
   */
  readonly medium?: string;

  /**
   * Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and Int64() accessors.

The serialization format is:

<quantity>        ::= <signedNumber><suffix>
  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
<digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
<decimalSI>       ::= m | "" | k | M | G | T | P | E
  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
<decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>

No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:
  a. No precision is lost
  b. No fractional digits will be emitted
  c. The exponent (or suffix) is as large as possible.
The sign will be omitted unless the number is negative.

Examples:
  1.5 will be serialized as "1500m"
  1.5Gi will be serialized as "1536Mi"

Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.
   *
   * @schema PostgresSpecInitScriptSourceEmptyDir#sizeLimit
   */
  readonly sizeLimit?: string;

}

/**
 * Represents a Fibre Channel volume. Fibre Channel volumes can only be mounted as read/write once. Fibre Channel volumes support ownership management and SELinux relabeling.
 *
 * @schema PostgresSpecInitScriptSourceFc
 */
export interface PostgresSpecInitScriptSourceFc {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PostgresSpecInitScriptSourceFc#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: FC target lun number
   *
   * @schema PostgresSpecInitScriptSourceFc#lun
   */
  readonly lun?: number;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema PostgresSpecInitScriptSourceFc#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Optional: FC target worldwide names (WWNs)
   *
   * @schema PostgresSpecInitScriptSourceFc#targetWWNs
   */
  readonly targetWWNs?: string[];

  /**
   * Optional: FC volume world wide identifiers (wwids) Either wwids or combination of targetWWNs and lun must be set, but not both simultaneously.
   *
   * @schema PostgresSpecInitScriptSourceFc#wwids
   */
  readonly wwids?: string[];

}

/**
 * FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin.
 *
 * @schema PostgresSpecInitScriptSourceFlexVolume
 */
export interface PostgresSpecInitScriptSourceFlexVolume {
  /**
   * Driver is the name of the driver to use for this volume.
   *
   * @schema PostgresSpecInitScriptSourceFlexVolume#driver
   */
  readonly driver: string;

  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
   *
   * @schema PostgresSpecInitScriptSourceFlexVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Optional: Extra command options if any.
   *
   * @schema PostgresSpecInitScriptSourceFlexVolume#options
   */
  readonly options?: any;

  /**
   * Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema PostgresSpecInitScriptSourceFlexVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
   *
   * @schema PostgresSpecInitScriptSourceFlexVolume#secretRef
   */
  readonly secretRef?: PostgresSpecInitScriptSourceFlexVolumeSecretRef;

}

/**
 * Represents a Flocker volume mounted by the Flocker agent. One and only one of datasetName and datasetUUID should be set. Flocker volumes do not support ownership management or SELinux relabeling.
 *
 * @schema PostgresSpecInitScriptSourceFlocker
 */
export interface PostgresSpecInitScriptSourceFlocker {
  /**
   * Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated
   *
   * @schema PostgresSpecInitScriptSourceFlocker#datasetName
   */
  readonly datasetName?: string;

  /**
   * UUID of the dataset. This is unique identifier of a Flocker dataset
   *
   * @schema PostgresSpecInitScriptSourceFlocker#datasetUUID
   */
  readonly datasetUUID?: string;

}

/**
 * Represents a Persistent Disk resource in Google Compute Engine.

A GCE PD must exist before mounting to a container. The disk must also be in the same GCE project and zone as the kubelet. A GCE PD can only be mounted as read/write once or read-only many times. GCE PDs support ownership management and SELinux relabeling.
 *
 * @schema PostgresSpecInitScriptSourceGcePersistentDisk
 */
export interface PostgresSpecInitScriptSourceGcePersistentDisk {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema PostgresSpecInitScriptSourceGcePersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema PostgresSpecInitScriptSourceGcePersistentDisk#partition
   */
  readonly partition?: number;

  /**
   * Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @schema PostgresSpecInitScriptSourceGcePersistentDisk#pdName
   */
  readonly pdName: string;

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
   * @schema PostgresSpecInitScriptSourceGcePersistentDisk#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Represents a volume that is populated with the contents of a git repository. Git repo volumes do not support ownership management. Git repo volumes support SELinux relabeling.

DEPRECATED: GitRepo is deprecated. To provision a container with a git repo, mount an EmptyDir into an InitContainer that clones the repo using git, then mount the EmptyDir into the Pod's container.
 *
 * @schema PostgresSpecInitScriptSourceGitRepo
 */
export interface PostgresSpecInitScriptSourceGitRepo {
  /**
   * Target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
   *
   * @schema PostgresSpecInitScriptSourceGitRepo#directory
   */
  readonly directory?: string;

  /**
   * Repository URL
   *
   * @schema PostgresSpecInitScriptSourceGitRepo#repository
   */
  readonly repository: string;

  /**
   * Commit hash for the specified revision.
   *
   * @schema PostgresSpecInitScriptSourceGitRepo#revision
   */
  readonly revision?: string;

}

/**
 * Represents a Glusterfs mount that lasts the lifetime of a pod. Glusterfs volumes do not support ownership management or SELinux relabeling.
 *
 * @schema PostgresSpecInitScriptSourceGlusterfs
 */
export interface PostgresSpecInitScriptSourceGlusterfs {
  /**
   * EndpointsName is the endpoint name that details Glusterfs topology. More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema PostgresSpecInitScriptSourceGlusterfs#endpoints
   */
  readonly endpoints: string;

  /**
   * Path is the Glusterfs volume path. More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod
   *
   * @schema PostgresSpecInitScriptSourceGlusterfs#path
   */
  readonly path: string;

  /**
   * ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod
   *
   * @default false. More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod
   * @schema PostgresSpecInitScriptSourceGlusterfs#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Represents a host path mapped into a pod. Host path volumes do not support ownership management or SELinux relabeling.
 *
 * @schema PostgresSpecInitScriptSourceHostPath
 */
export interface PostgresSpecInitScriptSourceHostPath {
  /**
   * Path of the directory on the host. If the path is a symlink, it will follow the link to the real path. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @schema PostgresSpecInitScriptSourceHostPath#path
   */
  readonly path: string;

  /**
   * Type for HostPath Volume Defaults to "" More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   *
   * @default More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
   * @schema PostgresSpecInitScriptSourceHostPath#type
   */
  readonly type?: string;

}

/**
 * Represents an ISCSI disk. ISCSI volumes can only be mounted as read/write once. ISCSI volumes support ownership management and SELinux relabeling.
 *
 * @schema PostgresSpecInitScriptSourceIscsi
 */
export interface PostgresSpecInitScriptSourceIscsi {
  /**
   * whether support iSCSI Discovery CHAP authentication
   *
   * @schema PostgresSpecInitScriptSourceIscsi#chapAuthDiscovery
   */
  readonly chapAuthDiscovery?: boolean;

  /**
   * whether support iSCSI Session CHAP authentication
   *
   * @schema PostgresSpecInitScriptSourceIscsi#chapAuthSession
   */
  readonly chapAuthSession?: boolean;

  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
   *
   * @schema PostgresSpecInitScriptSourceIscsi#fsType
   */
  readonly fsType?: string;

  /**
   * Custom iSCSI Initiator Name. If initiatorName is specified with iscsiInterface simultaneously, new iSCSI interface <target portal>:<volume name> will be created for the connection.
   *
   * @schema PostgresSpecInitScriptSourceIscsi#initiatorName
   */
  readonly initiatorName?: string;

  /**
   * Target iSCSI Qualified Name.
   *
   * @schema PostgresSpecInitScriptSourceIscsi#iqn
   */
  readonly iqn: string;

  /**
   * iSCSI Interface Name that uses an iSCSI transport. Defaults to 'default' (tcp).
   *
   * @default default' (tcp).
   * @schema PostgresSpecInitScriptSourceIscsi#iscsiInterface
   */
  readonly iscsiInterface?: string;

  /**
   * iSCSI Target Lun number.
   *
   * @schema PostgresSpecInitScriptSourceIscsi#lun
   */
  readonly lun: number;

  /**
   * iSCSI Target Portal List. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema PostgresSpecInitScriptSourceIscsi#portals
   */
  readonly portals?: string[];

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
   *
   * @default false.
   * @schema PostgresSpecInitScriptSourceIscsi#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
   *
   * @schema PostgresSpecInitScriptSourceIscsi#secretRef
   */
  readonly secretRef?: PostgresSpecInitScriptSourceIscsiSecretRef;

  /**
   * iSCSI Target Portal. The Portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
   *
   * @schema PostgresSpecInitScriptSourceIscsi#targetPortal
   */
  readonly targetPortal: string;

}

/**
 * Represents an NFS mount that lasts the lifetime of a pod. NFS volumes do not support ownership management or SELinux relabeling.
 *
 * @schema PostgresSpecInitScriptSourceNfs
 */
export interface PostgresSpecInitScriptSourceNfs {
  /**
   * Path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema PostgresSpecInitScriptSourceNfs#path
   */
  readonly path: string;

  /**
   * ReadOnly here will force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @default false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   * @schema PostgresSpecInitScriptSourceNfs#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
   *
   * @schema PostgresSpecInitScriptSourceNfs#server
   */
  readonly server: string;

}

/**
 * PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace. This volume finds the bound PV and mounts that volume for the pod. A PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another type of volume that is owned by someone else (the system).
 *
 * @schema PostgresSpecInitScriptSourcePersistentVolumeClaim
 */
export interface PostgresSpecInitScriptSourcePersistentVolumeClaim {
  /**
   * ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
   *
   * @schema PostgresSpecInitScriptSourcePersistentVolumeClaim#claimName
   */
  readonly claimName: string;

  /**
   * Will force the ReadOnly setting in VolumeMounts. Default false.
   *
   * @schema PostgresSpecInitScriptSourcePersistentVolumeClaim#readOnly
   */
  readonly readOnly?: boolean;

}

/**
 * Represents a Photon Controller persistent disk resource.
 *
 * @schema PostgresSpecInitScriptSourcePhotonPersistentDisk
 */
export interface PostgresSpecInitScriptSourcePhotonPersistentDisk {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PostgresSpecInitScriptSourcePhotonPersistentDisk#fsType
   */
  readonly fsType?: string;

  /**
   * ID that identifies Photon Controller persistent disk
   *
   * @schema PostgresSpecInitScriptSourcePhotonPersistentDisk#pdID
   */
  readonly pdID: string;

}

/**
 * PortworxVolumeSource represents a Portworx volume resource.
 *
 * @schema PostgresSpecInitScriptSourcePortworxVolume
 */
export interface PostgresSpecInitScriptSourcePortworxVolume {
  /**
   * FSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PostgresSpecInitScriptSourcePortworxVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema PostgresSpecInitScriptSourcePortworxVolume#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * VolumeID uniquely identifies a Portworx volume
   *
   * @schema PostgresSpecInitScriptSourcePortworxVolume#volumeID
   */
  readonly volumeID: string;

}

/**
 * Represents a projected volume source
 *
 * @schema PostgresSpecInitScriptSourceProjected
 */
export interface PostgresSpecInitScriptSourceProjected {
  /**
   * Mode bits to use on created files by default. Must be a value between 0 and 0777. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PostgresSpecInitScriptSourceProjected#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * list of volume projections
   *
   * @schema PostgresSpecInitScriptSourceProjected#sources
   */
  readonly sources: PostgresSpecInitScriptSourceProjectedSources[];

}

/**
 * Represents a Quobyte mount that lasts the lifetime of a pod. Quobyte volumes do not support ownership management or SELinux relabeling.
 *
 * @schema PostgresSpecInitScriptSourceQuobyte
 */
export interface PostgresSpecInitScriptSourceQuobyte {
  /**
   * Group to map volume access to Default is no group
   *
   * @default no group
   * @schema PostgresSpecInitScriptSourceQuobyte#group
   */
  readonly group?: string;

  /**
   * ReadOnly here will force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
   *
   * @default false.
   * @schema PostgresSpecInitScriptSourceQuobyte#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
   *
   * @schema PostgresSpecInitScriptSourceQuobyte#registry
   */
  readonly registry: string;

  /**
   * Tenant owning the given Quobyte volume in the Backend Used with dynamically provisioned Quobyte volumes, value is set by the plugin
   *
   * @schema PostgresSpecInitScriptSourceQuobyte#tenant
   */
  readonly tenant?: string;

  /**
   * User to map volume access to Defaults to serivceaccount user
   *
   * @default serivceaccount user
   * @schema PostgresSpecInitScriptSourceQuobyte#user
   */
  readonly user?: string;

  /**
   * Volume is a string that references an already created Quobyte volume by name.
   *
   * @schema PostgresSpecInitScriptSourceQuobyte#volume
   */
  readonly volume: string;

}

/**
 * Represents a Rados Block Device mount that lasts the lifetime of a pod. RBD volumes support ownership management and SELinux relabeling.
 *
 * @schema PostgresSpecInitScriptSourceRbd
 */
export interface PostgresSpecInitScriptSourceRbd {
  /**
   * Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
   *
   * @schema PostgresSpecInitScriptSourceRbd#fsType
   */
  readonly fsType?: string;

  /**
   * The rados image name. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   *
   * @schema PostgresSpecInitScriptSourceRbd#image
   */
  readonly image: string;

  /**
   * Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   *
   * @default etc/ceph/keyring. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   * @schema PostgresSpecInitScriptSourceRbd#keyring
   */
  readonly keyring?: string;

  /**
   * A collection of Ceph monitors. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   *
   * @schema PostgresSpecInitScriptSourceRbd#monitors
   */
  readonly monitors: string[];

  /**
   * The rados pool name. Default is rbd. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   *
   * @default rbd. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   * @schema PostgresSpecInitScriptSourceRbd#pool
   */
  readonly pool?: string;

  /**
   * ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   *
   * @default false. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   * @schema PostgresSpecInitScriptSourceRbd#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
   *
   * @schema PostgresSpecInitScriptSourceRbd#secretRef
   */
  readonly secretRef?: PostgresSpecInitScriptSourceRbdSecretRef;

  /**
   * The rados user name. Default is admin. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   *
   * @default admin. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
   * @schema PostgresSpecInitScriptSourceRbd#user
   */
  readonly user?: string;

}

/**
 * ScaleIOVolumeSource represents a persistent ScaleIO volume
 *
 * @schema PostgresSpecInitScriptSourceScaleIo
 */
export interface PostgresSpecInitScriptSourceScaleIo {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Default is "xfs".
   *
   * @default xfs".
   * @schema PostgresSpecInitScriptSourceScaleIo#fsType
   */
  readonly fsType?: string;

  /**
   * The host address of the ScaleIO API Gateway.
   *
   * @schema PostgresSpecInitScriptSourceScaleIo#gateway
   */
  readonly gateway: string;

  /**
   * The name of the ScaleIO Protection Domain for the configured storage.
   *
   * @schema PostgresSpecInitScriptSourceScaleIo#protectionDomain
   */
  readonly protectionDomain?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema PostgresSpecInitScriptSourceScaleIo#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
   *
   * @schema PostgresSpecInitScriptSourceScaleIo#secretRef
   */
  readonly secretRef: PostgresSpecInitScriptSourceScaleIoSecretRef;

  /**
   * Flag to enable/disable SSL communication with Gateway, default false
   *
   * @schema PostgresSpecInitScriptSourceScaleIo#sslEnabled
   */
  readonly sslEnabled?: boolean;

  /**
   * Indicates whether the storage for a volume should be ThickProvisioned or ThinProvisioned. Default is ThinProvisioned.
   *
   * @default ThinProvisioned.
   * @schema PostgresSpecInitScriptSourceScaleIo#storageMode
   */
  readonly storageMode?: string;

  /**
   * The ScaleIO Storage Pool associated with the protection domain.
   *
   * @schema PostgresSpecInitScriptSourceScaleIo#storagePool
   */
  readonly storagePool?: string;

  /**
   * The name of the storage system as configured in ScaleIO.
   *
   * @schema PostgresSpecInitScriptSourceScaleIo#system
   */
  readonly system: string;

  /**
   * The name of a volume already created in the ScaleIO system that is associated with this volume source.
   *
   * @schema PostgresSpecInitScriptSourceScaleIo#volumeName
   */
  readonly volumeName?: string;

}

/**
 * Adapts a Secret into a volume.

The contents of the target Secret's Data field will be presented in a volume as files using the keys in the Data field as the file names. Secret volumes support ownership management and SELinux relabeling.
 *
 * @schema PostgresSpecInitScriptSourceSecret
 */
export interface PostgresSpecInitScriptSourceSecret {
  /**
   * Optional: mode bits to use on created files by default. Must be a value between 0 and 0777. Defaults to 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @default 0644. Directories within the path are not affected by this setting. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   * @schema PostgresSpecInitScriptSourceSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema PostgresSpecInitScriptSourceSecret#items
   */
  readonly items?: PostgresSpecInitScriptSourceSecretItems[];

  /**
   * Specify whether the Secret or it's keys must be defined
   *
   * @schema PostgresSpecInitScriptSourceSecret#optional
   */
  readonly optional?: boolean;

  /**
   * Name of the secret in the pod's namespace to use. More info: https://kubernetes.io/docs/concepts/storage/volumes#secret
   *
   * @schema PostgresSpecInitScriptSourceSecret#secretName
   */
  readonly secretName?: string;

}

/**
 * Represents a StorageOS persistent volume resource.
 *
 * @schema PostgresSpecInitScriptSourceStorageos
 */
export interface PostgresSpecInitScriptSourceStorageos {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PostgresSpecInitScriptSourceStorageos#fsType
   */
  readonly fsType?: string;

  /**
   * Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   *
   * @default false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
   * @schema PostgresSpecInitScriptSourceStorageos#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
   *
   * @schema PostgresSpecInitScriptSourceStorageos#secretRef
   */
  readonly secretRef?: PostgresSpecInitScriptSourceStorageosSecretRef;

  /**
   * VolumeName is the human-readable name of the StorageOS volume.  Volume names are only unique within a namespace.
   *
   * @schema PostgresSpecInitScriptSourceStorageos#volumeName
   */
  readonly volumeName?: string;

  /**
   * VolumeNamespace specifies the scope of the volume within StorageOS.  If no namespace is specified then the Pod's namespace will be used.  This allows the Kubernetes name scoping to be mirrored within StorageOS for tighter integration. Set VolumeName to any name to override the default behaviour. Set to "default" if you are not using namespaces within StorageOS. Namespaces that do not pre-exist within StorageOS will be created.
   *
   * @schema PostgresSpecInitScriptSourceStorageos#volumeNamespace
   */
  readonly volumeNamespace?: string;

}

/**
 * Represents a vSphere volume resource.
 *
 * @schema PostgresSpecInitScriptSourceVsphereVolume
 */
export interface PostgresSpecInitScriptSourceVsphereVolume {
  /**
   * Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
   *
   * @schema PostgresSpecInitScriptSourceVsphereVolume#fsType
   */
  readonly fsType?: string;

  /**
   * Storage Policy Based Management (SPBM) profile ID associated with the StoragePolicyName.
   *
   * @schema PostgresSpecInitScriptSourceVsphereVolume#storagePolicyID
   */
  readonly storagePolicyID?: string;

  /**
   * Storage Policy Based Management (SPBM) profile name.
   *
   * @schema PostgresSpecInitScriptSourceVsphereVolume#storagePolicyName
   */
  readonly storagePolicyName?: string;

  /**
   * Path that identifies vSphere volume vmdk
   *
   * @schema PostgresSpecInitScriptSourceVsphereVolume#volumePath
   */
  readonly volumePath: string;

}

/**
 * EnvVarSource represents a source for the value of an EnvVar.
 *
 * @schema PostgresSpecMonitorEnvValueFrom
 */
export interface PostgresSpecMonitorEnvValueFrom {
  /**
   * Selects a key from a ConfigMap.
   *
   * @schema PostgresSpecMonitorEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: PostgresSpecMonitorEnvValueFromConfigMapKeyRef;

  /**
   * ObjectFieldSelector selects an APIVersioned field of an object.
   *
   * @schema PostgresSpecMonitorEnvValueFrom#fieldRef
   */
  readonly fieldRef?: PostgresSpecMonitorEnvValueFromFieldRef;

  /**
   * ResourceFieldSelector represents container resources (cpu, memory) and their output format
   *
   * @schema PostgresSpecMonitorEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: PostgresSpecMonitorEnvValueFromResourceFieldRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema PostgresSpecMonitorEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: PostgresSpecMonitorEnvValueFromSecretKeyRef;

}

/**
 * Adds and removes POSIX capabilities from running containers.
 *
 * @schema PostgresSpecMonitorSecurityContextCapabilities
 */
export interface PostgresSpecMonitorSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema PostgresSpecMonitorSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema PostgresSpecMonitorSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * SELinuxOptions are the labels to be applied to the container
 *
 * @schema PostgresSpecMonitorSecurityContextSeLinuxOptions
 */
export interface PostgresSpecMonitorSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema PostgresSpecMonitorSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema PostgresSpecMonitorSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema PostgresSpecMonitorSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema PostgresSpecMonitorSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Affinity is a group of affinity scheduling rules.
 *
 * @schema PostgresSpecPodTemplateSpecAffinity
 */
export interface PostgresSpecPodTemplateSpecAffinity {
  /**
   * Node affinity is a group of node affinity scheduling rules.
   *
   * @schema PostgresSpecPodTemplateSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: PostgresSpecPodTemplateSpecAffinityNodeAffinity;

  /**
   * Pod affinity is a group of inter pod affinity scheduling rules.
   *
   * @schema PostgresSpecPodTemplateSpecAffinity#podAffinity
   */
  readonly podAffinity?: PostgresSpecPodTemplateSpecAffinityPodAffinity;

  /**
   * Pod anti affinity is a group of inter pod anti affinity scheduling rules.
   *
   * @schema PostgresSpecPodTemplateSpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: PostgresSpecPodTemplateSpecAffinityPodAntiAffinity;

}

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema PostgresSpecPodTemplateSpecEnv
 */
export interface PostgresSpecPodTemplateSpecEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema PostgresSpecPodTemplateSpecEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema PostgresSpecPodTemplateSpecEnv#value
   */
  readonly value?: string;

  /**
   * EnvVarSource represents a source for the value of an EnvVar.
   *
   * @schema PostgresSpecPodTemplateSpecEnv#valueFrom
   */
  readonly valueFrom?: PostgresSpecPodTemplateSpecEnvValueFrom;

}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema PostgresSpecPodTemplateSpecImagePullSecrets
 */
export interface PostgresSpecPodTemplateSpecImagePullSecrets {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecPodTemplateSpecImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * A single application container that you want to run within a pod.
 *
 * @schema PostgresSpecPodTemplateSpecInitContainers
 */
export interface PostgresSpecPodTemplateSpecInitContainers {
  /**
   * Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema PostgresSpecPodTemplateSpecInitContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema PostgresSpecPodTemplateSpecInitContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainers#env
   */
  readonly env?: PostgresSpecPodTemplateSpecInitContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainers#envFrom
   */
  readonly envFrom?: PostgresSpecPodTemplateSpecInitContainersEnvFrom[];

  /**
   * Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema PostgresSpecPodTemplateSpecInitContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Lifecycle describes actions that the management system should take in response to container lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the container blocks until the action is complete, unless the container process fails, in which case the handler is aborted.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainers#lifecycle
   */
  readonly lifecycle?: PostgresSpecPodTemplateSpecInitContainersLifecycle;

  /**
   * Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainers#livenessProbe
   */
  readonly livenessProbe?: PostgresSpecPodTemplateSpecInitContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainers#ports
   */
  readonly ports?: PostgresSpecPodTemplateSpecInitContainersPorts[];

  /**
   * Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainers#readinessProbe
   */
  readonly readinessProbe?: PostgresSpecPodTemplateSpecInitContainersReadinessProbe;

  /**
   * ResourceRequirements describes the compute resource requirements.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainers#resources
   */
  readonly resources?: PostgresSpecPodTemplateSpecInitContainersResources;

  /**
   * SecurityContext holds security configuration that will be applied to a container. Some fields are present in both SecurityContext and PodSecurityContext.  When both are set, the values in SecurityContext take precedence.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainers#securityContext
   */
  readonly securityContext?: PostgresSpecPodTemplateSpecInitContainersSecurityContext;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema PostgresSpecPodTemplateSpecInitContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema PostgresSpecPodTemplateSpecInitContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema PostgresSpecPodTemplateSpecInitContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema PostgresSpecPodTemplateSpecInitContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema PostgresSpecPodTemplateSpecInitContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container. This is a beta feature.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainers#volumeDevices
   */
  readonly volumeDevices?: PostgresSpecPodTemplateSpecInitContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Cannot be updated.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainers#volumeMounts
   */
  readonly volumeMounts?: PostgresSpecPodTemplateSpecInitContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Lifecycle describes actions that the management system should take in response to container lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the container blocks until the action is complete, unless the container process fails, in which case the handler is aborted.
 *
 * @schema PostgresSpecPodTemplateSpecLifecycle
 */
export interface PostgresSpecPodTemplateSpecLifecycle {
  /**
   * Handler defines a specific action that should be taken
   *
   * @schema PostgresSpecPodTemplateSpecLifecycle#postStart
   */
  readonly postStart?: PostgresSpecPodTemplateSpecLifecyclePostStart;

  /**
   * Handler defines a specific action that should be taken
   *
   * @schema PostgresSpecPodTemplateSpecLifecycle#preStop
   */
  readonly preStop?: PostgresSpecPodTemplateSpecLifecyclePreStop;

}

/**
 * Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
 *
 * @schema PostgresSpecPodTemplateSpecLivenessProbe
 */
export interface PostgresSpecPodTemplateSpecLivenessProbe {
  /**
   * ExecAction describes a "run in container" action.
   *
   * @schema PostgresSpecPodTemplateSpecLivenessProbe#exec
   */
  readonly exec?: PostgresSpecPodTemplateSpecLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PostgresSpecPodTemplateSpecLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * HTTPGetAction describes an action based on HTTP Get requests.
   *
   * @schema PostgresSpecPodTemplateSpecLivenessProbe#httpGet
   */
  readonly httpGet?: PostgresSpecPodTemplateSpecLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PostgresSpecPodTemplateSpecLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PostgresSpecPodTemplateSpecLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema PostgresSpecPodTemplateSpecLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocketAction describes an action based on opening a socket
   *
   * @schema PostgresSpecPodTemplateSpecLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: PostgresSpecPodTemplateSpecLivenessProbeTcpSocket;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema PostgresSpecPodTemplateSpecLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
 *
 * @schema PostgresSpecPodTemplateSpecReadinessProbe
 */
export interface PostgresSpecPodTemplateSpecReadinessProbe {
  /**
   * ExecAction describes a "run in container" action.
   *
   * @schema PostgresSpecPodTemplateSpecReadinessProbe#exec
   */
  readonly exec?: PostgresSpecPodTemplateSpecReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PostgresSpecPodTemplateSpecReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * HTTPGetAction describes an action based on HTTP Get requests.
   *
   * @schema PostgresSpecPodTemplateSpecReadinessProbe#httpGet
   */
  readonly httpGet?: PostgresSpecPodTemplateSpecReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PostgresSpecPodTemplateSpecReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PostgresSpecPodTemplateSpecReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema PostgresSpecPodTemplateSpecReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocketAction describes an action based on opening a socket
   *
   * @schema PostgresSpecPodTemplateSpecReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: PostgresSpecPodTemplateSpecReadinessProbeTcpSocket;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema PostgresSpecPodTemplateSpecReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * ResourceRequirements describes the compute resource requirements.
 *
 * @schema PostgresSpecPodTemplateSpecResources
 */
export interface PostgresSpecPodTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   *
   * @schema PostgresSpecPodTemplateSpecResources#limits
   */
  readonly limits?: any;

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   *
   * @schema PostgresSpecPodTemplateSpecResources#requests
   */
  readonly requests?: any;

}

/**
 * PodSecurityContext holds pod-level security attributes and common container settings. Some fields are also present in container.securityContext.  Field values of container.securityContext take precedence over field values of PodSecurityContext.
 *
 * @schema PostgresSpecPodTemplateSpecSecurityContext
 */
export interface PostgresSpecPodTemplateSpecSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:

1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----

If unset, the Kubelet will not modify the ownership and permissions of any volume.
   *
   * @schema PostgresSpecPodTemplateSpecSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
   *
   * @schema PostgresSpecPodTemplateSpecSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema PostgresSpecPodTemplateSpecSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
   *
   * @default user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
   * @schema PostgresSpecPodTemplateSpecSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * SELinuxOptions are the labels to be applied to the container
   *
   * @schema PostgresSpecPodTemplateSpecSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: PostgresSpecPodTemplateSpecSecurityContextSeLinuxOptions;

  /**
   * A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container.
   *
   * @schema PostgresSpecPodTemplateSpecSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch.
   *
   * @schema PostgresSpecPodTemplateSpecSecurityContext#sysctls
   */
  readonly sysctls?: PostgresSpecPodTemplateSpecSecurityContextSysctls[];

}

/**
 * The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema PostgresSpecPodTemplateSpecTolerations
 */
export interface PostgresSpecPodTemplateSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema PostgresSpecPodTemplateSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema PostgresSpecPodTemplateSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   *
   * @default Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   * @schema PostgresSpecPodTemplateSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema PostgresSpecPodTemplateSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema PostgresSpecPodTemplateSpecTolerations#value
   */
  readonly value?: string;

}

/**
 * ServicePort contains information on service's port.
 *
 * @schema PostgresSpecReplicaServiceTemplateSpecPorts
 */
export interface PostgresSpecReplicaServiceTemplateSpecPorts {
  /**
   * The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the 'Name' field in EndpointPort objects. Optional if only one ServicePort is defined on this service.
   *
   * @schema PostgresSpecReplicaServiceTemplateSpecPorts#name
   */
  readonly name?: string;

  /**
   * The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
   *
   * @default to auto-allocate a port if the ServiceType of this Service requires one. More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
   * @schema PostgresSpecReplicaServiceTemplateSpecPorts#nodePort
   */
  readonly nodePort?: number;

  /**
   * The port that will be exposed by this service.
   *
   * @schema PostgresSpecReplicaServiceTemplateSpecPorts#port
   */
  readonly port: number;

}

/**
 * ServicePort contains information on service's port.
 *
 * @schema PostgresSpecServiceTemplateSpecPorts
 */
export interface PostgresSpecServiceTemplateSpecPorts {
  /**
   * The name of this port within the service. This must be a DNS_LABEL. All ports within a ServiceSpec must have unique names. This maps to the 'Name' field in EndpointPort objects. Optional if only one ServicePort is defined on this service.
   *
   * @schema PostgresSpecServiceTemplateSpecPorts#name
   */
  readonly name?: string;

  /**
   * The port on each node on which this service is exposed when type=NodePort or LoadBalancer. Usually assigned by the system. If specified, it will be allocated to the service if unused or else creation of the service will fail. Default is to auto-allocate a port if the ServiceType of this Service requires one. More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
   *
   * @default to auto-allocate a port if the ServiceType of this Service requires one. More info: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
   * @schema PostgresSpecServiceTemplateSpecPorts#nodePort
   */
  readonly nodePort?: number;

  /**
   * The port that will be exposed by this service.
   *
   * @schema PostgresSpecServiceTemplateSpecPorts#port
   */
  readonly port: number;

}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PostgresSpecStorageSelectorMatchExpressions
 */
export interface PostgresSpecStorageSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PostgresSpecStorageSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PostgresSpecStorageSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PostgresSpecStorageSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * StatusCause provides more information about an api.Status failure, including cases when multiple errors are encountered.
 *
 * @schema PostgresMetadataInitializersResultDetailsCauses
 */
export interface PostgresMetadataInitializersResultDetailsCauses {
  /**
   * The field of the resource that has caused this error, as named by its JSON serialization. May include dot and postfix notation for nested attributes. Arrays are zero-indexed.  Fields may appear more than once in an array of causes due to fields having multiple errors. Optional.

Examples:
  "name" - the field "name" on the current resource
  "items[0].name" - the field "name" on the first array entry in "items"
   *
   * @schema PostgresMetadataInitializersResultDetailsCauses#field
   */
  readonly field?: string;

  /**
   * A human-readable description of the cause of the error.  This field may be presented as-is to a reader.
   *
   * @schema PostgresMetadataInitializersResultDetailsCauses#message
   */
  readonly message?: string;

  /**
   * A machine-readable description of the cause of the error. If this value is empty there is no information available.
   *
   * @schema PostgresMetadataInitializersResultDetailsCauses#reason
   */
  readonly reason?: string;

}

/**
 * Affinity is a group of affinity scheduling rules.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinity
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecAffinity {
  /**
   * Node affinity is a group of node affinity scheduling rules.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinity;

  /**
   * Pod affinity is a group of inter pod affinity scheduling rules.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinity#podAffinity
   */
  readonly podAffinity?: PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinity;

  /**
   * Pod anti affinity is a group of inter pod anti affinity scheduling rules.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinity;

}

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecEnv
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema PostgresSpecBackupSchedulePodTemplateSpecEnv#value
   */
  readonly value?: string;

  /**
   * EnvVarSource represents a source for the value of an EnvVar.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecEnv#valueFrom
   */
  readonly valueFrom?: PostgresSpecBackupSchedulePodTemplateSpecEnvValueFrom;

}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecImagePullSecrets
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecImagePullSecrets {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * A single application container that you want to run within a pod.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainers
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainers {
  /**
   * Arguments to the entrypoint. The docker image's CMD is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainers#args
   */
  readonly args?: string[];

  /**
   * Entrypoint array. Not executed within a shell. The docker image's ENTRYPOINT is used if this is not provided. Variable references $(VAR_NAME) are expanded using the container's environment. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Cannot be updated. More info: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#running-a-command-in-a-shell
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainers#command
   */
  readonly command?: string[];

  /**
   * List of environment variables to set in the container. Cannot be updated.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainers#env
   */
  readonly env?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnv[];

  /**
   * List of sources to populate environment variables in the container. The keys defined within a source must be a C_IDENTIFIER. All invalid keys will be reported as an event when the container is starting. When a key exists in multiple sources, the value associated with the last source will take precedence. Values defined by an Env with a duplicate key will take precedence. Cannot be updated.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainers#envFrom
   */
  readonly envFrom?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvFrom[];

  /**
   * Docker image name. More info: https://kubernetes.io/docs/concepts/containers/images This field is optional to allow higher level config management to default or override container images in workload controllers like Deployments and StatefulSets.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainers#image
   */
  readonly image?: string;

  /**
   * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   *
   * @default Always if :latest tag is specified, or IfNotPresent otherwise. Cannot be updated. More info: https://kubernetes.io/docs/concepts/containers/images#updating-images
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainers#imagePullPolicy
   */
  readonly imagePullPolicy?: string;

  /**
   * Lifecycle describes actions that the management system should take in response to container lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the container blocks until the action is complete, unless the container process fails, in which case the handler is aborted.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainers#lifecycle
   */
  readonly lifecycle?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecycle;

  /**
   * Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainers#livenessProbe
   */
  readonly livenessProbe?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbe;

  /**
   * Name of the container specified as a DNS_LABEL. Each container in a pod must have a unique name (DNS_LABEL). Cannot be updated.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainers#name
   */
  readonly name: string;

  /**
   * List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default "0.0.0.0" address inside a container will be accessible from the network. Cannot be updated.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainers#ports
   */
  readonly ports?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersPorts[];

  /**
   * Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainers#readinessProbe
   */
  readonly readinessProbe?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbe;

  /**
   * ResourceRequirements describes the compute resource requirements.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainers#resources
   */
  readonly resources?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersResources;

  /**
   * SecurityContext holds security configuration that will be applied to a container. Some fields are present in both SecurityContext and PodSecurityContext.  When both are set, the values in SecurityContext take precedence.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainers#securityContext
   */
  readonly securityContext?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersSecurityContext;

  /**
   * Whether this container should allocate a buffer for stdin in the container runtime. If this is not set, reads from stdin in the container will always result in EOF. Default is false.
   *
   * @default false.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainers#stdin
   */
  readonly stdin?: boolean;

  /**
   * Whether the container runtime should close the stdin channel after it has been opened by a single attach. When stdin is true the stdin stream will remain open across multiple attach sessions. If stdinOnce is set to true, stdin is opened on container start, is empty until the first client attaches to stdin, and then remains open and accepts data until the client disconnects, at which time stdin is closed and remains closed until the container is restarted. If this flag is false, a container processes that reads from stdin will never receive an EOF. Default is false
   *
   * @default false
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainers#stdinOnce
   */
  readonly stdinOnce?: boolean;

  /**
   * Optional: Path at which the file to which the container's termination message will be written is mounted into the container's filesystem. Message written is intended to be brief final status, such as an assertion failure message. Will be truncated by the node if greater than 4096 bytes. The total message length across all containers will be limited to 12kb. Defaults to /dev/termination-log. Cannot be updated.
   *
   * @default dev/termination-log. Cannot be updated.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainers#terminationMessagePath
   */
  readonly terminationMessagePath?: string;

  /**
   * Indicate how the termination message should be populated. File will use the contents of terminationMessagePath to populate the container status message on both success and failure. FallbackToLogsOnError will use the last chunk of container log output if the termination message file is empty and the container exited with an error. The log output is limited to 2048 bytes or 80 lines, whichever is smaller. Defaults to File. Cannot be updated.
   *
   * @default File. Cannot be updated.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainers#terminationMessagePolicy
   */
  readonly terminationMessagePolicy?: string;

  /**
   * Whether this container should allocate a TTY for itself, also requires 'stdin' to be true. Default is false.
   *
   * @default false.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainers#tty
   */
  readonly tty?: boolean;

  /**
   * volumeDevices is the list of block devices to be used by the container. This is a beta feature.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainers#volumeDevices
   */
  readonly volumeDevices?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersVolumeDevices[];

  /**
   * Pod volumes to mount into the container's filesystem. Cannot be updated.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainers#volumeMounts
   */
  readonly volumeMounts?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersVolumeMounts[];

  /**
   * Container's working directory. If not specified, the container runtime's default will be used, which might be configured in the container image. Cannot be updated.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainers#workingDir
   */
  readonly workingDir?: string;

}

/**
 * Lifecycle describes actions that the management system should take in response to container lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the container blocks until the action is complete, unless the container process fails, in which case the handler is aborted.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecycle
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecLifecycle {
  /**
   * Handler defines a specific action that should be taken
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecycle#postStart
   */
  readonly postStart?: PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStart;

  /**
   * Handler defines a specific action that should be taken
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecycle#preStop
   */
  readonly preStop?: PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStop;

}

/**
 * Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecLivenessProbe
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecLivenessProbe {
  /**
   * ExecAction describes a "run in container" action.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLivenessProbe#exec
   */
  readonly exec?: PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * HTTPGetAction describes an action based on HTTP Get requests.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLivenessProbe#httpGet
   */
  readonly httpGet?: PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocketAction describes an action based on opening a socket
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeTcpSocket;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecReadinessProbe
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecReadinessProbe {
  /**
   * ExecAction describes a "run in container" action.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecReadinessProbe#exec
   */
  readonly exec?: PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * HTTPGetAction describes an action based on HTTP Get requests.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecReadinessProbe#httpGet
   */
  readonly httpGet?: PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocketAction describes an action based on opening a socket
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeTcpSocket;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema PostgresSpecBackupSchedulePodTemplateSpecReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * ResourceRequirements describes the compute resource requirements.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecResources
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecResources#limits
   */
  readonly limits?: any;

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecResources#requests
   */
  readonly requests?: any;

}

/**
 * PodSecurityContext holds pod-level security attributes and common container settings. Some fields are also present in container.securityContext.  Field values of container.securityContext take precedence over field values of PodSecurityContext.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecSecurityContext
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecSecurityContext {
  /**
   * A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:

1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----

If unset, the Kubelet will not modify the ownership and permissions of any volume.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
   *
   * @default user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * SELinuxOptions are the labels to be applied to the container
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: PostgresSpecBackupSchedulePodTemplateSpecSecurityContextSeLinuxOptions;

  /**
   * A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported sysctls (by the container runtime) might fail to launch.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecSecurityContext#sysctls
   */
  readonly sysctls?: PostgresSpecBackupSchedulePodTemplateSpecSecurityContextSysctls[];

}

/**
 * The pod this Toleration is attached to tolerates any taint that matches the triple <key,value,effect> using the matching operator <operator>.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecTolerations
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecTolerations {
  /**
   * Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecTolerations#key
   */
  readonly key?: string;

  /**
   * Operator represents a key's relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   *
   * @default Equal. Exists is equivalent to wildcard for value, so that a pod can tolerate all taints of a particular category.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * TolerationSeconds represents the period of time the toleration (which must be of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default, it is not set, which means tolerate the taint forever (do not evict). Zero and negative values will be treated as 0 (evict immediately) by the system.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecTolerations#value
   */
  readonly value?: string;

}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PostgresSpecBackupSchedulePodVolumeClaimSpecSelectorMatchExpressions
 */
export interface PostgresSpecBackupSchedulePodVolumeClaimSpecSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PostgresSpecBackupSchedulePodVolumeClaimSpecSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PostgresSpecBackupSchedulePodVolumeClaimSpecSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PostgresSpecBackupSchedulePodVolumeClaimSpecSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * ObjectFieldSelector selects an APIVersioned field of an object.
 *
 * @schema PostgresSpecConfigSourceDownwardApiItemsFieldRef
 */
export interface PostgresSpecConfigSourceDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema PostgresSpecConfigSourceDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema PostgresSpecConfigSourceDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * ResourceFieldSelector represents container resources (cpu, memory) and their output format
 *
 * @schema PostgresSpecConfigSourceDownwardApiItemsResourceFieldRef
 */
export interface PostgresSpecConfigSourceDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema PostgresSpecConfigSourceDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and Int64() accessors.

The serialization format is:

<quantity>        ::= <signedNumber><suffix>
  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
<digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
<decimalSI>       ::= m | "" | k | M | G | T | P | E
  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
<decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>

No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:
  a. No precision is lost
  b. No fractional digits will be emitted
  c. The exponent (or suffix) is as large as possible.
The sign will be omitted unless the number is negative.

Examples:
  1.5 will be serialized as "1500m"
  1.5Gi will be serialized as "1536Mi"

Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.
   *
   * @schema PostgresSpecConfigSourceDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: string;

  /**
   * Required: resource to select
   *
   * @schema PostgresSpecConfigSourceDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Adapts a ConfigMap into a projected volume.

The contents of the target ConfigMap's Data field will be presented in a projected volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. Note that this is identical to a configmap volume source without the default mode.
 *
 * @schema PostgresSpecConfigSourceProjectedSourcesConfigMap
 */
export interface PostgresSpecConfigSourceProjectedSourcesConfigMap {
  /**
   * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema PostgresSpecConfigSourceProjectedSourcesConfigMap#items
   */
  readonly items?: PostgresSpecConfigSourceProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecConfigSourceProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or it's keys must be defined
   *
   * @schema PostgresSpecConfigSourceProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Represents downward API info for projecting into a projected volume. Note that this is identical to a downwardAPI volume source without the default mode.
 *
 * @schema PostgresSpecConfigSourceProjectedSourcesDownwardApi
 */
export interface PostgresSpecConfigSourceProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema PostgresSpecConfigSourceProjectedSourcesDownwardApi#items
   */
  readonly items?: PostgresSpecConfigSourceProjectedSourcesDownwardApiItems[];

}

/**
 * Adapts a secret into a projected volume.

The contents of the target Secret's Data field will be presented in a projected volume as files using the keys in the Data field as the file names. Note that this is identical to a secret volume source without the default mode.
 *
 * @schema PostgresSpecConfigSourceProjectedSourcesSecret
 */
export interface PostgresSpecConfigSourceProjectedSourcesSecret {
  /**
   * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema PostgresSpecConfigSourceProjectedSourcesSecret#items
   */
  readonly items?: PostgresSpecConfigSourceProjectedSourcesSecretItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecConfigSourceProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PostgresSpecConfigSourceProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * ServiceAccountTokenProjection represents a projected service account token volume. This projection can be used to insert a service account token into the pods runtime filesystem for use against APIs (Kubernetes API Server or otherwise).
 *
 * @schema PostgresSpecConfigSourceProjectedSourcesServiceAccountToken
 */
export interface PostgresSpecConfigSourceProjectedSourcesServiceAccountToken {
  /**
   * Audience is the intended audience of the token. A recipient of a token must identify itself with an identifier specified in the audience of the token, and otherwise should reject the token. The audience defaults to the identifier of the apiserver.
   *
   * @schema PostgresSpecConfigSourceProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * ExpirationSeconds is the requested duration of validity of the service account token. As the token approaches expiration, the kubelet volume plugin will proactively rotate the service account token. The kubelet will start trying to rotate the token if the token is older than 80 percent of its time to live or if the token is older than 24 hours.Defaults to 1 hour and must be at least 10 minutes.
   *
   * @default 1 hour and must be at least 10 minutes.
   * @schema PostgresSpecConfigSourceProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * Path is the path relative to the mount point of the file to project the token into.
   *
   * @schema PostgresSpecConfigSourceProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;

}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema PostgresSpecInitScriptSourceCephfsSecretRef
 */
export interface PostgresSpecInitScriptSourceCephfsSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecInitScriptSourceCephfsSecretRef#name
   */
  readonly name?: string;

}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema PostgresSpecInitScriptSourceCinderSecretRef
 */
export interface PostgresSpecInitScriptSourceCinderSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecInitScriptSourceCinderSecretRef#name
   */
  readonly name?: string;

}

/**
 * Maps a string key to a path within a volume.
 *
 * @schema PostgresSpecInitScriptSourceConfigMapItems
 */
export interface PostgresSpecInitScriptSourceConfigMapItems {
  /**
   * The key to project.
   *
   * @schema PostgresSpecInitScriptSourceConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PostgresSpecInitScriptSourceConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema PostgresSpecInitScriptSourceConfigMapItems#path
   */
  readonly path: string;

}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema PostgresSpecInitScriptSourceCsiNodePublishSecretRef
 */
export interface PostgresSpecInitScriptSourceCsiNodePublishSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecInitScriptSourceCsiNodePublishSecretRef#name
   */
  readonly name?: string;

}

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema PostgresSpecInitScriptSourceDownwardApiItems
 */
export interface PostgresSpecInitScriptSourceDownwardApiItems {
  /**
   * ObjectFieldSelector selects an APIVersioned field of an object.
   *
   * @schema PostgresSpecInitScriptSourceDownwardApiItems#fieldRef
   */
  readonly fieldRef?: PostgresSpecInitScriptSourceDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PostgresSpecInitScriptSourceDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema PostgresSpecInitScriptSourceDownwardApiItems#path
   */
  readonly path: string;

  /**
   * ResourceFieldSelector represents container resources (cpu, memory) and their output format
   *
   * @schema PostgresSpecInitScriptSourceDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: PostgresSpecInitScriptSourceDownwardApiItemsResourceFieldRef;

}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema PostgresSpecInitScriptSourceFlexVolumeSecretRef
 */
export interface PostgresSpecInitScriptSourceFlexVolumeSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecInitScriptSourceFlexVolumeSecretRef#name
   */
  readonly name?: string;

}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema PostgresSpecInitScriptSourceIscsiSecretRef
 */
export interface PostgresSpecInitScriptSourceIscsiSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecInitScriptSourceIscsiSecretRef#name
   */
  readonly name?: string;

}

/**
 * Projection that may be projected along with other supported volume types
 *
 * @schema PostgresSpecInitScriptSourceProjectedSources
 */
export interface PostgresSpecInitScriptSourceProjectedSources {
  /**
   * Adapts a ConfigMap into a projected volume.

The contents of the target ConfigMap's Data field will be presented in a projected volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. Note that this is identical to a configmap volume source without the default mode.
   *
   * @schema PostgresSpecInitScriptSourceProjectedSources#configMap
   */
  readonly configMap?: PostgresSpecInitScriptSourceProjectedSourcesConfigMap;

  /**
   * Represents downward API info for projecting into a projected volume. Note that this is identical to a downwardAPI volume source without the default mode.
   *
   * @schema PostgresSpecInitScriptSourceProjectedSources#downwardAPI
   */
  readonly downwardAPI?: PostgresSpecInitScriptSourceProjectedSourcesDownwardApi;

  /**
   * Adapts a secret into a projected volume.

The contents of the target Secret's Data field will be presented in a projected volume as files using the keys in the Data field as the file names. Note that this is identical to a secret volume source without the default mode.
   *
   * @schema PostgresSpecInitScriptSourceProjectedSources#secret
   */
  readonly secret?: PostgresSpecInitScriptSourceProjectedSourcesSecret;

  /**
   * ServiceAccountTokenProjection represents a projected service account token volume. This projection can be used to insert a service account token into the pods runtime filesystem for use against APIs (Kubernetes API Server or otherwise).
   *
   * @schema PostgresSpecInitScriptSourceProjectedSources#serviceAccountToken
   */
  readonly serviceAccountToken?: PostgresSpecInitScriptSourceProjectedSourcesServiceAccountToken;

}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema PostgresSpecInitScriptSourceRbdSecretRef
 */
export interface PostgresSpecInitScriptSourceRbdSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecInitScriptSourceRbdSecretRef#name
   */
  readonly name?: string;

}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema PostgresSpecInitScriptSourceScaleIoSecretRef
 */
export interface PostgresSpecInitScriptSourceScaleIoSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecInitScriptSourceScaleIoSecretRef#name
   */
  readonly name?: string;

}

/**
 * Maps a string key to a path within a volume.
 *
 * @schema PostgresSpecInitScriptSourceSecretItems
 */
export interface PostgresSpecInitScriptSourceSecretItems {
  /**
   * The key to project.
   *
   * @schema PostgresSpecInitScriptSourceSecretItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PostgresSpecInitScriptSourceSecretItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema PostgresSpecInitScriptSourceSecretItems#path
   */
  readonly path: string;

}

/**
 * LocalObjectReference contains enough information to let you locate the referenced object inside the same namespace.
 *
 * @schema PostgresSpecInitScriptSourceStorageosSecretRef
 */
export interface PostgresSpecInitScriptSourceStorageosSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecInitScriptSourceStorageosSecretRef#name
   */
  readonly name?: string;

}

/**
 * Selects a key from a ConfigMap.
 *
 * @schema PostgresSpecMonitorEnvValueFromConfigMapKeyRef
 */
export interface PostgresSpecMonitorEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema PostgresSpecMonitorEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecMonitorEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or it's key must be defined
   *
   * @schema PostgresSpecMonitorEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * ObjectFieldSelector selects an APIVersioned field of an object.
 *
 * @schema PostgresSpecMonitorEnvValueFromFieldRef
 */
export interface PostgresSpecMonitorEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema PostgresSpecMonitorEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema PostgresSpecMonitorEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * ResourceFieldSelector represents container resources (cpu, memory) and their output format
 *
 * @schema PostgresSpecMonitorEnvValueFromResourceFieldRef
 */
export interface PostgresSpecMonitorEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema PostgresSpecMonitorEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and Int64() accessors.

The serialization format is:

<quantity>        ::= <signedNumber><suffix>
  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
<digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
<decimalSI>       ::= m | "" | k | M | G | T | P | E
  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
<decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>

No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:
  a. No precision is lost
  b. No fractional digits will be emitted
  c. The exponent (or suffix) is as large as possible.
The sign will be omitted unless the number is negative.

Examples:
  1.5 will be serialized as "1500m"
  1.5Gi will be serialized as "1536Mi"

Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.
   *
   * @schema PostgresSpecMonitorEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: string;

  /**
   * Required: resource to select
   *
   * @schema PostgresSpecMonitorEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema PostgresSpecMonitorEnvValueFromSecretKeyRef
 */
export interface PostgresSpecMonitorEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PostgresSpecMonitorEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecMonitorEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or it's key must be defined
   *
   * @schema PostgresSpecMonitorEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Node affinity is a group of node affinity scheduling rules.
 *
 * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinity
 */
export interface PostgresSpecPodTemplateSpecAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: PostgresSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * A node selector represents the union of the results of one or more label queries over a set of nodes; that is, it represents the OR of the selectors represented by the node selector terms.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: PostgresSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Pod affinity is a group of inter pod affinity scheduling rules.
 *
 * @schema PostgresSpecPodTemplateSpecAffinityPodAffinity
 */
export interface PostgresSpecPodTemplateSpecAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: PostgresSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: PostgresSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Pod anti affinity is a group of inter pod anti affinity scheduling rules.
 *
 * @schema PostgresSpecPodTemplateSpecAffinityPodAntiAffinity
 */
export interface PostgresSpecPodTemplateSpecAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: PostgresSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: PostgresSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * EnvVarSource represents a source for the value of an EnvVar.
 *
 * @schema PostgresSpecPodTemplateSpecEnvValueFrom
 */
export interface PostgresSpecPodTemplateSpecEnvValueFrom {
  /**
   * Selects a key from a ConfigMap.
   *
   * @schema PostgresSpecPodTemplateSpecEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: PostgresSpecPodTemplateSpecEnvValueFromConfigMapKeyRef;

  /**
   * ObjectFieldSelector selects an APIVersioned field of an object.
   *
   * @schema PostgresSpecPodTemplateSpecEnvValueFrom#fieldRef
   */
  readonly fieldRef?: PostgresSpecPodTemplateSpecEnvValueFromFieldRef;

  /**
   * ResourceFieldSelector represents container resources (cpu, memory) and their output format
   *
   * @schema PostgresSpecPodTemplateSpecEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: PostgresSpecPodTemplateSpecEnvValueFromResourceFieldRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema PostgresSpecPodTemplateSpecEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: PostgresSpecPodTemplateSpecEnvValueFromSecretKeyRef;

}

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersEnv
 */
export interface PostgresSpecPodTemplateSpecInitContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema PostgresSpecPodTemplateSpecInitContainersEnv#value
   */
  readonly value?: string;

  /**
   * EnvVarSource represents a source for the value of an EnvVar.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersEnv#valueFrom
   */
  readonly valueFrom?: PostgresSpecPodTemplateSpecInitContainersEnvValueFrom;

}

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersEnvFrom
 */
export interface PostgresSpecPodTemplateSpecInitContainersEnvFrom {
  /**
   * ConfigMapEnvSource selects a ConfigMap to populate the environment variables with.

The contents of the target ConfigMap's Data field will represent the key-value pairs as environment variables.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: PostgresSpecPodTemplateSpecInitContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * SecretEnvSource selects a Secret to populate the environment variables with.

The contents of the target Secret's Data field will represent the key-value pairs as environment variables.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersEnvFrom#secretRef
   */
  readonly secretRef?: PostgresSpecPodTemplateSpecInitContainersEnvFromSecretRef;

}

/**
 * Lifecycle describes actions that the management system should take in response to container lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the container blocks until the action is complete, unless the container process fails, in which case the handler is aborted.
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersLifecycle
 */
export interface PostgresSpecPodTemplateSpecInitContainersLifecycle {
  /**
   * Handler defines a specific action that should be taken
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLifecycle#postStart
   */
  readonly postStart?: PostgresSpecPodTemplateSpecInitContainersLifecyclePostStart;

  /**
   * Handler defines a specific action that should be taken
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLifecycle#preStop
   */
  readonly preStop?: PostgresSpecPodTemplateSpecInitContainersLifecyclePreStop;

}

/**
 * Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersLivenessProbe
 */
export interface PostgresSpecPodTemplateSpecInitContainersLivenessProbe {
  /**
   * ExecAction describes a "run in container" action.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLivenessProbe#exec
   */
  readonly exec?: PostgresSpecPodTemplateSpecInitContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PostgresSpecPodTemplateSpecInitContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * HTTPGetAction describes an action based on HTTP Get requests.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLivenessProbe#httpGet
   */
  readonly httpGet?: PostgresSpecPodTemplateSpecInitContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PostgresSpecPodTemplateSpecInitContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema PostgresSpecPodTemplateSpecInitContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocketAction describes an action based on opening a socket
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: PostgresSpecPodTemplateSpecInitContainersLivenessProbeTcpSocket;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema PostgresSpecPodTemplateSpecInitContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersPorts
 */
export interface PostgresSpecPodTemplateSpecInitContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersPorts#hostIP
   */
  readonly hostIP?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema PostgresSpecPodTemplateSpecInitContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersReadinessProbe
 */
export interface PostgresSpecPodTemplateSpecInitContainersReadinessProbe {
  /**
   * ExecAction describes a "run in container" action.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersReadinessProbe#exec
   */
  readonly exec?: PostgresSpecPodTemplateSpecInitContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PostgresSpecPodTemplateSpecInitContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * HTTPGetAction describes an action based on HTTP Get requests.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersReadinessProbe#httpGet
   */
  readonly httpGet?: PostgresSpecPodTemplateSpecInitContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PostgresSpecPodTemplateSpecInitContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema PostgresSpecPodTemplateSpecInitContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocketAction describes an action based on opening a socket
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: PostgresSpecPodTemplateSpecInitContainersReadinessProbeTcpSocket;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema PostgresSpecPodTemplateSpecInitContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * ResourceRequirements describes the compute resource requirements.
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersResources
 */
export interface PostgresSpecPodTemplateSpecInitContainersResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersResources#limits
   */
  readonly limits?: any;

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersResources#requests
   */
  readonly requests?: any;

}

/**
 * SecurityContext holds security configuration that will be applied to a container. Some fields are present in both SecurityContext and PodSecurityContext.  When both are set, the values in SecurityContext take precedence.
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersSecurityContext
 */
export interface PostgresSpecPodTemplateSpecInitContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * Adds and removes POSIX capabilities from running containers.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersSecurityContext#capabilities
   */
  readonly capabilities?: PostgresSpecPodTemplateSpecInitContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false.
   *
   * @default false.
   * @schema PostgresSpecPodTemplateSpecInitContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false.
   *
   * @default false.
   * @schema PostgresSpecPodTemplateSpecInitContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema PostgresSpecPodTemplateSpecInitContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * SELinuxOptions are the labels to be applied to the container
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: PostgresSpecPodTemplateSpecInitContainersSecurityContextSeLinuxOptions;

}

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersVolumeDevices
 */
export interface PostgresSpecPodTemplateSpecInitContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersVolumeMounts
 */
export interface PostgresSpecPodTemplateSpecInitContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema PostgresSpecPodTemplateSpecInitContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema PostgresSpecPodTemplateSpecInitContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive. This field is alpha in 1.14.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive. This field is alpha in 1.14.
   * @schema PostgresSpecPodTemplateSpecInitContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Handler defines a specific action that should be taken
 *
 * @schema PostgresSpecPodTemplateSpecLifecyclePostStart
 */
export interface PostgresSpecPodTemplateSpecLifecyclePostStart {
  /**
   * ExecAction describes a "run in container" action.
   *
   * @schema PostgresSpecPodTemplateSpecLifecyclePostStart#exec
   */
  readonly exec?: PostgresSpecPodTemplateSpecLifecyclePostStartExec;

  /**
   * HTTPGetAction describes an action based on HTTP Get requests.
   *
   * @schema PostgresSpecPodTemplateSpecLifecyclePostStart#httpGet
   */
  readonly httpGet?: PostgresSpecPodTemplateSpecLifecyclePostStartHttpGet;

  /**
   * TCPSocketAction describes an action based on opening a socket
   *
   * @schema PostgresSpecPodTemplateSpecLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: PostgresSpecPodTemplateSpecLifecyclePostStartTcpSocket;

}

/**
 * Handler defines a specific action that should be taken
 *
 * @schema PostgresSpecPodTemplateSpecLifecyclePreStop
 */
export interface PostgresSpecPodTemplateSpecLifecyclePreStop {
  /**
   * ExecAction describes a "run in container" action.
   *
   * @schema PostgresSpecPodTemplateSpecLifecyclePreStop#exec
   */
  readonly exec?: PostgresSpecPodTemplateSpecLifecyclePreStopExec;

  /**
   * HTTPGetAction describes an action based on HTTP Get requests.
   *
   * @schema PostgresSpecPodTemplateSpecLifecyclePreStop#httpGet
   */
  readonly httpGet?: PostgresSpecPodTemplateSpecLifecyclePreStopHttpGet;

  /**
   * TCPSocketAction describes an action based on opening a socket
   *
   * @schema PostgresSpecPodTemplateSpecLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: PostgresSpecPodTemplateSpecLifecyclePreStopTcpSocket;

}

/**
 * ExecAction describes a "run in container" action.
 *
 * @schema PostgresSpecPodTemplateSpecLivenessProbeExec
 */
export interface PostgresSpecPodTemplateSpecLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PostgresSpecPodTemplateSpecLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 *
 * @schema PostgresSpecPodTemplateSpecLivenessProbeHttpGet
 */
export interface PostgresSpecPodTemplateSpecLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PostgresSpecPodTemplateSpecLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PostgresSpecPodTemplateSpecLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: PostgresSpecPodTemplateSpecLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PostgresSpecPodTemplateSpecLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * @schema PostgresSpecPodTemplateSpecLivenessProbeHttpGet#port
   */
  readonly port: PostgresSpecPodTemplateSpecLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PostgresSpecPodTemplateSpecLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * TCPSocketAction describes an action based on opening a socket
 *
 * @schema PostgresSpecPodTemplateSpecLivenessProbeTcpSocket
 */
export interface PostgresSpecPodTemplateSpecLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PostgresSpecPodTemplateSpecLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema PostgresSpecPodTemplateSpecLivenessProbeTcpSocket#port
   */
  readonly port: PostgresSpecPodTemplateSpecLivenessProbeTcpSocketPort;

}

/**
 * ExecAction describes a "run in container" action.
 *
 * @schema PostgresSpecPodTemplateSpecReadinessProbeExec
 */
export interface PostgresSpecPodTemplateSpecReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PostgresSpecPodTemplateSpecReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 *
 * @schema PostgresSpecPodTemplateSpecReadinessProbeHttpGet
 */
export interface PostgresSpecPodTemplateSpecReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PostgresSpecPodTemplateSpecReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PostgresSpecPodTemplateSpecReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: PostgresSpecPodTemplateSpecReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PostgresSpecPodTemplateSpecReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * @schema PostgresSpecPodTemplateSpecReadinessProbeHttpGet#port
   */
  readonly port: PostgresSpecPodTemplateSpecReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PostgresSpecPodTemplateSpecReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * TCPSocketAction describes an action based on opening a socket
 *
 * @schema PostgresSpecPodTemplateSpecReadinessProbeTcpSocket
 */
export interface PostgresSpecPodTemplateSpecReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PostgresSpecPodTemplateSpecReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema PostgresSpecPodTemplateSpecReadinessProbeTcpSocket#port
   */
  readonly port: PostgresSpecPodTemplateSpecReadinessProbeTcpSocketPort;

}

/**
 * SELinuxOptions are the labels to be applied to the container
 *
 * @schema PostgresSpecPodTemplateSpecSecurityContextSeLinuxOptions
 */
export interface PostgresSpecPodTemplateSpecSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema PostgresSpecPodTemplateSpecSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema PostgresSpecPodTemplateSpecSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema PostgresSpecPodTemplateSpecSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema PostgresSpecPodTemplateSpecSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema PostgresSpecPodTemplateSpecSecurityContextSysctls
 */
export interface PostgresSpecPodTemplateSpecSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema PostgresSpecPodTemplateSpecSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema PostgresSpecPodTemplateSpecSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Node affinity is a group of node affinity scheduling rules.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinity
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * A node selector represents the union of the results of one or more label queries over a set of nodes; that is, it represents the OR of the selectors represented by the node selector terms.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * Pod affinity is a group of inter pod affinity scheduling rules.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinity
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Pod anti affinity is a group of inter pod anti affinity scheduling rules.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinity
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinity {
  /**
   * The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * EnvVarSource represents a source for the value of an EnvVar.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecEnvValueFrom
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecEnvValueFrom {
  /**
   * Selects a key from a ConfigMap.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: PostgresSpecBackupSchedulePodTemplateSpecEnvValueFromConfigMapKeyRef;

  /**
   * ObjectFieldSelector selects an APIVersioned field of an object.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecEnvValueFrom#fieldRef
   */
  readonly fieldRef?: PostgresSpecBackupSchedulePodTemplateSpecEnvValueFromFieldRef;

  /**
   * ResourceFieldSelector represents container resources (cpu, memory) and their output format
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: PostgresSpecBackupSchedulePodTemplateSpecEnvValueFromResourceFieldRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: PostgresSpecBackupSchedulePodTemplateSpecEnvValueFromSecretKeyRef;

}

/**
 * EnvVar represents an environment variable present in a Container.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnv
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnv {
  /**
   * Name of the environment variable. Must be a C_IDENTIFIER.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnv#name
   */
  readonly name: string;

  /**
   * Variable references $(VAR_NAME) are expanded using the previous defined environment variables in the container and any service environment variables. If a variable cannot be resolved, the reference in the input string will be unchanged. The $(VAR_NAME) syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped references will never be expanded, regardless of whether the variable exists or not. Defaults to "".
   *
   * @default .
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnv#value
   */
  readonly value?: string;

  /**
   * EnvVarSource represents a source for the value of an EnvVar.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnv#valueFrom
   */
  readonly valueFrom?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFrom;

}

/**
 * EnvFromSource represents the source of a set of ConfigMaps
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvFrom
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvFrom {
  /**
   * ConfigMapEnvSource selects a ConfigMap to populate the environment variables with.

The contents of the target ConfigMap's Data field will represent the key-value pairs as environment variables.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvFrom#configMapRef
   */
  readonly configMapRef?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvFromConfigMapRef;

  /**
   * An optional identifier to prepend to each key in the ConfigMap. Must be a C_IDENTIFIER.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvFrom#prefix
   */
  readonly prefix?: string;

  /**
   * SecretEnvSource selects a Secret to populate the environment variables with.

The contents of the target Secret's Data field will represent the key-value pairs as environment variables.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvFrom#secretRef
   */
  readonly secretRef?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvFromSecretRef;

}

/**
 * Lifecycle describes actions that the management system should take in response to container lifecycle events. For the PostStart and PreStop lifecycle handlers, management of the container blocks until the action is complete, unless the container process fails, in which case the handler is aborted.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecycle
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecycle {
  /**
   * Handler defines a specific action that should be taken
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecycle#postStart
   */
  readonly postStart?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStart;

  /**
   * Handler defines a specific action that should be taken
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecycle#preStop
   */
  readonly preStop?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStop;

}

/**
 * Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbe
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbe {
  /**
   * ExecAction describes a "run in container" action.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbe#exec
   */
  readonly exec?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * HTTPGetAction describes an action based on HTTP Get requests.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbe#httpGet
   */
  readonly httpGet?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocketAction describes an action based on opening a socket
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbe#tcpSocket
   */
  readonly tcpSocket?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeTcpSocket;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * ContainerPort represents a network port in a single container.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersPorts
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersPorts {
  /**
   * Number of port to expose on the pod's IP address. This must be a valid port number, 0 < x < 65536.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersPorts#containerPort
   */
  readonly containerPort: number;

  /**
   * What host IP to bind the external port to.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersPorts#hostIP
   */
  readonly hostIP?: string;

  /**
   * Number of port to expose on the host. If specified, this must be a valid port number, 0 < x < 65536. If HostNetwork is specified, this must match ContainerPort. Most containers do not need this.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersPorts#hostPort
   */
  readonly hostPort?: number;

  /**
   * If specified, this must be an IANA_SVC_NAME and unique within the pod. Each named port in a pod must have a unique name. Name for the port that can be referred to by services.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersPorts#name
   */
  readonly name?: string;

  /**
   * Protocol for port. Must be UDP, TCP, or SCTP. Defaults to "TCP".
   *
   * @default TCP".
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersPorts#protocol
   */
  readonly protocol?: string;

}

/**
 * Probe describes a health check to be performed against a container to determine whether it is alive or ready to receive traffic.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbe
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbe {
  /**
   * ExecAction describes a "run in container" action.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbe#exec
   */
  readonly exec?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeExec;

  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * HTTPGetAction describes an action based on HTTP Get requests.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbe#httpGet
   */
  readonly httpGet?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeHttpGet;

  /**
   * Number of seconds after the container has started before liveness probes are initiated. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * TCPSocketAction describes an action based on opening a socket
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbe#tcpSocket
   */
  readonly tcpSocket?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeTcpSocket;

  /**
   * Number of seconds after which the probe times out. Defaults to 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   *
   * @default 1 second. Minimum value is 1. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-probes
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * ResourceRequirements describes the compute resource requirements.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersResources
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersResources {
  /**
   * Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersResources#limits
   */
  readonly limits?: any;

  /**
   * Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersResources#requests
   */
  readonly requests?: any;

}

/**
 * SecurityContext holds security configuration that will be applied to a container. Some fields are present in both SecurityContext and PodSecurityContext.  When both are set, the values in SecurityContext take precedence.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersSecurityContext
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersSecurityContext {
  /**
   * AllowPrivilegeEscalation controls whether a process can gain more privileges than its parent process. This bool directly controls if the no_new_privs flag will be set on the container process. AllowPrivilegeEscalation is true always when the container is: 1) run as Privileged 2) has CAP_SYS_ADMIN
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * Adds and removes POSIX capabilities from running containers.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersSecurityContext#capabilities
   */
  readonly capabilities?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersSecurityContextCapabilities;

  /**
   * Run container in privileged mode. Processes in privileged containers are essentially equivalent to root on the host. Defaults to false.
   *
   * @default false.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * procMount denotes the type of proc mount to use for the containers. The default is DefaultProcMount which uses the container runtime defaults for readonly paths and masked paths. This requires the ProcMountType feature flag to be enabled.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * Whether this container has a read-only root filesystem. Default is false.
   *
   * @default false.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * The GID to run the entrypoint of the container process. Uses runtime default if unset. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   *
   * @default user specified in image metadata if unspecified. May also be set in PodSecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * SELinuxOptions are the labels to be applied to the container
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersSecurityContextSeLinuxOptions;

}

/**
 * volumeDevice describes a mapping of a raw block device within a container.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersVolumeDevices
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersVolumeDevices {
  /**
   * devicePath is the path inside of the container that the device will be mapped to.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersVolumeDevices#devicePath
   */
  readonly devicePath: string;

  /**
   * name must match the name of a persistentVolumeClaim in the pod
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersVolumeDevices#name
   */
  readonly name: string;

}

/**
 * VolumeMount describes a mounting of a Volume within a container.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersVolumeMounts
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersVolumeMounts {
  /**
   * Path within the container at which the volume should be mounted.  Must not contain ':'.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersVolumeMounts#mountPath
   */
  readonly mountPath: string;

  /**
   * mountPropagation determines how mounts are propagated from the host to container and the other way around. When not set, MountPropagationNone is used. This field is beta in 1.10.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersVolumeMounts#mountPropagation
   */
  readonly mountPropagation?: string;

  /**
   * This must match the Name of a Volume.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersVolumeMounts#name
   */
  readonly name: string;

  /**
   * Mounted read-only if true, read-write otherwise (false or unspecified). Defaults to false.
   *
   * @default false.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersVolumeMounts#readOnly
   */
  readonly readOnly?: boolean;

  /**
   * Path within the volume from which the container's volume should be mounted. Defaults to "" (volume's root).
   *
   * @default volume's root).
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersVolumeMounts#subPath
   */
  readonly subPath?: string;

  /**
   * Expanded path within the volume from which the container's volume should be mounted. Behaves similarly to SubPath but environment variable references $(VAR_NAME) are expanded using the container's environment. Defaults to "" (volume's root). SubPathExpr and SubPath are mutually exclusive. This field is alpha in 1.14.
   *
   * @default volume's root). SubPathExpr and SubPath are mutually exclusive. This field is alpha in 1.14.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersVolumeMounts#subPathExpr
   */
  readonly subPathExpr?: string;

}

/**
 * Handler defines a specific action that should be taken
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStart
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStart {
  /**
   * ExecAction describes a "run in container" action.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStart#exec
   */
  readonly exec?: PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartExec;

  /**
   * HTTPGetAction describes an action based on HTTP Get requests.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStart#httpGet
   */
  readonly httpGet?: PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartHttpGet;

  /**
   * TCPSocketAction describes an action based on opening a socket
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartTcpSocket;

}

/**
 * Handler defines a specific action that should be taken
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStop
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStop {
  /**
   * ExecAction describes a "run in container" action.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStop#exec
   */
  readonly exec?: PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopExec;

  /**
   * HTTPGetAction describes an action based on HTTP Get requests.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStop#httpGet
   */
  readonly httpGet?: PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopHttpGet;

  /**
   * TCPSocketAction describes an action based on opening a socket
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopTcpSocket;

}

/**
 * ExecAction describes a "run in container" action.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeExec
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeHttpGet
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeHttpGet#port
   */
  readonly port: PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * TCPSocketAction describes an action based on opening a socket
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeTcpSocket
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeTcpSocket#port
   */
  readonly port: PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeTcpSocketPort;

}

/**
 * ExecAction describes a "run in container" action.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeExec
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeHttpGet
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * @schema PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeHttpGet#port
   */
  readonly port: PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * TCPSocketAction describes an action based on opening a socket
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeTcpSocket
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeTcpSocket#port
   */
  readonly port: PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeTcpSocketPort;

}

/**
 * SELinuxOptions are the labels to be applied to the container
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecSecurityContextSeLinuxOptions
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * Sysctl defines a kernel parameter to be set
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecSecurityContextSysctls
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecSecurityContextSysctls {
  /**
   * Name of a property to set
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecSecurityContextSysctls#name
   */
  readonly name: string;

  /**
   * Value of a property to set
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecSecurityContextSysctls#value
   */
  readonly value: string;

}

/**
 * Maps a string key to a path within a volume.
 *
 * @schema PostgresSpecConfigSourceProjectedSourcesConfigMapItems
 */
export interface PostgresSpecConfigSourceProjectedSourcesConfigMapItems {
  /**
   * The key to project.
   *
   * @schema PostgresSpecConfigSourceProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PostgresSpecConfigSourceProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema PostgresSpecConfigSourceProjectedSourcesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema PostgresSpecConfigSourceProjectedSourcesDownwardApiItems
 */
export interface PostgresSpecConfigSourceProjectedSourcesDownwardApiItems {
  /**
   * ObjectFieldSelector selects an APIVersioned field of an object.
   *
   * @schema PostgresSpecConfigSourceProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: PostgresSpecConfigSourceProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PostgresSpecConfigSourceProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema PostgresSpecConfigSourceProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * ResourceFieldSelector represents container resources (cpu, memory) and their output format
   *
   * @schema PostgresSpecConfigSourceProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: PostgresSpecConfigSourceProjectedSourcesDownwardApiItemsResourceFieldRef;

}

/**
 * Maps a string key to a path within a volume.
 *
 * @schema PostgresSpecConfigSourceProjectedSourcesSecretItems
 */
export interface PostgresSpecConfigSourceProjectedSourcesSecretItems {
  /**
   * The key to project.
   *
   * @schema PostgresSpecConfigSourceProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PostgresSpecConfigSourceProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema PostgresSpecConfigSourceProjectedSourcesSecretItems#path
   */
  readonly path: string;

}

/**
 * ObjectFieldSelector selects an APIVersioned field of an object.
 *
 * @schema PostgresSpecInitScriptSourceDownwardApiItemsFieldRef
 */
export interface PostgresSpecInitScriptSourceDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema PostgresSpecInitScriptSourceDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema PostgresSpecInitScriptSourceDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * ResourceFieldSelector represents container resources (cpu, memory) and their output format
 *
 * @schema PostgresSpecInitScriptSourceDownwardApiItemsResourceFieldRef
 */
export interface PostgresSpecInitScriptSourceDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema PostgresSpecInitScriptSourceDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and Int64() accessors.

The serialization format is:

<quantity>        ::= <signedNumber><suffix>
  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
<digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
<decimalSI>       ::= m | "" | k | M | G | T | P | E
  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
<decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>

No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:
  a. No precision is lost
  b. No fractional digits will be emitted
  c. The exponent (or suffix) is as large as possible.
The sign will be omitted unless the number is negative.

Examples:
  1.5 will be serialized as "1500m"
  1.5Gi will be serialized as "1536Mi"

Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.
   *
   * @schema PostgresSpecInitScriptSourceDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: string;

  /**
   * Required: resource to select
   *
   * @schema PostgresSpecInitScriptSourceDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Adapts a ConfigMap into a projected volume.

The contents of the target ConfigMap's Data field will be presented in a projected volume as files using the keys in the Data field as the file names, unless the items element is populated with specific mappings of keys to paths. Note that this is identical to a configmap volume source without the default mode.
 *
 * @schema PostgresSpecInitScriptSourceProjectedSourcesConfigMap
 */
export interface PostgresSpecInitScriptSourceProjectedSourcesConfigMap {
  /**
   * If unspecified, each key-value pair in the Data field of the referenced ConfigMap will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the ConfigMap, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema PostgresSpecInitScriptSourceProjectedSourcesConfigMap#items
   */
  readonly items?: PostgresSpecInitScriptSourceProjectedSourcesConfigMapItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecInitScriptSourceProjectedSourcesConfigMap#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or it's keys must be defined
   *
   * @schema PostgresSpecInitScriptSourceProjectedSourcesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Represents downward API info for projecting into a projected volume. Note that this is identical to a downwardAPI volume source without the default mode.
 *
 * @schema PostgresSpecInitScriptSourceProjectedSourcesDownwardApi
 */
export interface PostgresSpecInitScriptSourceProjectedSourcesDownwardApi {
  /**
   * Items is a list of DownwardAPIVolume file
   *
   * @schema PostgresSpecInitScriptSourceProjectedSourcesDownwardApi#items
   */
  readonly items?: PostgresSpecInitScriptSourceProjectedSourcesDownwardApiItems[];

}

/**
 * Adapts a secret into a projected volume.

The contents of the target Secret's Data field will be presented in a projected volume as files using the keys in the Data field as the file names. Note that this is identical to a secret volume source without the default mode.
 *
 * @schema PostgresSpecInitScriptSourceProjectedSourcesSecret
 */
export interface PostgresSpecInitScriptSourceProjectedSourcesSecret {
  /**
   * If unspecified, each key-value pair in the Data field of the referenced Secret will be projected into the volume as a file whose name is the key and content is the value. If specified, the listed keys will be projected into the specified paths, and unlisted keys will not be present. If a key is specified which is not present in the Secret, the volume setup will error unless it is marked optional. Paths must be relative and may not contain the '..' path or start with '..'.
   *
   * @schema PostgresSpecInitScriptSourceProjectedSourcesSecret#items
   */
  readonly items?: PostgresSpecInitScriptSourceProjectedSourcesSecretItems[];

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecInitScriptSourceProjectedSourcesSecret#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or its key must be defined
   *
   * @schema PostgresSpecInitScriptSourceProjectedSourcesSecret#optional
   */
  readonly optional?: boolean;

}

/**
 * ServiceAccountTokenProjection represents a projected service account token volume. This projection can be used to insert a service account token into the pods runtime filesystem for use against APIs (Kubernetes API Server or otherwise).
 *
 * @schema PostgresSpecInitScriptSourceProjectedSourcesServiceAccountToken
 */
export interface PostgresSpecInitScriptSourceProjectedSourcesServiceAccountToken {
  /**
   * Audience is the intended audience of the token. A recipient of a token must identify itself with an identifier specified in the audience of the token, and otherwise should reject the token. The audience defaults to the identifier of the apiserver.
   *
   * @schema PostgresSpecInitScriptSourceProjectedSourcesServiceAccountToken#audience
   */
  readonly audience?: string;

  /**
   * ExpirationSeconds is the requested duration of validity of the service account token. As the token approaches expiration, the kubelet volume plugin will proactively rotate the service account token. The kubelet will start trying to rotate the token if the token is older than 80 percent of its time to live or if the token is older than 24 hours.Defaults to 1 hour and must be at least 10 minutes.
   *
   * @default 1 hour and must be at least 10 minutes.
   * @schema PostgresSpecInitScriptSourceProjectedSourcesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * Path is the path relative to the mount point of the file to project the token into.
   *
   * @schema PostgresSpecInitScriptSourceProjectedSourcesServiceAccountToken#path
   */
  readonly path: string;

}

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface PostgresSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: PostgresSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * A node selector represents the union of the results of one or more label queries over a set of nodes; that is, it represents the OR of the selectors represented by the node selector terms.
 *
 * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface PostgresSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: PostgresSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema PostgresSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface PostgresSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: PostgresSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema PostgresSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface PostgresSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: PostgresSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema PostgresSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface PostgresSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: PostgresSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema PostgresSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface PostgresSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: PostgresSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Selects a key from a ConfigMap.
 *
 * @schema PostgresSpecPodTemplateSpecEnvValueFromConfigMapKeyRef
 */
export interface PostgresSpecPodTemplateSpecEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema PostgresSpecPodTemplateSpecEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecPodTemplateSpecEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or it's key must be defined
   *
   * @schema PostgresSpecPodTemplateSpecEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * ObjectFieldSelector selects an APIVersioned field of an object.
 *
 * @schema PostgresSpecPodTemplateSpecEnvValueFromFieldRef
 */
export interface PostgresSpecPodTemplateSpecEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema PostgresSpecPodTemplateSpecEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema PostgresSpecPodTemplateSpecEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * ResourceFieldSelector represents container resources (cpu, memory) and their output format
 *
 * @schema PostgresSpecPodTemplateSpecEnvValueFromResourceFieldRef
 */
export interface PostgresSpecPodTemplateSpecEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema PostgresSpecPodTemplateSpecEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and Int64() accessors.

The serialization format is:

<quantity>        ::= <signedNumber><suffix>
  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
<digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
<decimalSI>       ::= m | "" | k | M | G | T | P | E
  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
<decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>

No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:
  a. No precision is lost
  b. No fractional digits will be emitted
  c. The exponent (or suffix) is as large as possible.
The sign will be omitted unless the number is negative.

Examples:
  1.5 will be serialized as "1500m"
  1.5Gi will be serialized as "1536Mi"

Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.
   *
   * @schema PostgresSpecPodTemplateSpecEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: string;

  /**
   * Required: resource to select
   *
   * @schema PostgresSpecPodTemplateSpecEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema PostgresSpecPodTemplateSpecEnvValueFromSecretKeyRef
 */
export interface PostgresSpecPodTemplateSpecEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PostgresSpecPodTemplateSpecEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecPodTemplateSpecEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or it's key must be defined
   *
   * @schema PostgresSpecPodTemplateSpecEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * EnvVarSource represents a source for the value of an EnvVar.
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersEnvValueFrom
 */
export interface PostgresSpecPodTemplateSpecInitContainersEnvValueFrom {
  /**
   * Selects a key from a ConfigMap.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: PostgresSpecPodTemplateSpecInitContainersEnvValueFromConfigMapKeyRef;

  /**
   * ObjectFieldSelector selects an APIVersioned field of an object.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: PostgresSpecPodTemplateSpecInitContainersEnvValueFromFieldRef;

  /**
   * ResourceFieldSelector represents container resources (cpu, memory) and their output format
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: PostgresSpecPodTemplateSpecInitContainersEnvValueFromResourceFieldRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: PostgresSpecPodTemplateSpecInitContainersEnvValueFromSecretKeyRef;

}

/**
 * ConfigMapEnvSource selects a ConfigMap to populate the environment variables with.

The contents of the target ConfigMap's Data field will represent the key-value pairs as environment variables.
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersEnvFromConfigMapRef
 */
export interface PostgresSpecPodTemplateSpecInitContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * SecretEnvSource selects a Secret to populate the environment variables with.

The contents of the target Secret's Data field will represent the key-value pairs as environment variables.
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersEnvFromSecretRef
 */
export interface PostgresSpecPodTemplateSpecInitContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Handler defines a specific action that should be taken
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePostStart
 */
export interface PostgresSpecPodTemplateSpecInitContainersLifecyclePostStart {
  /**
   * ExecAction describes a "run in container" action.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePostStart#exec
   */
  readonly exec?: PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartExec;

  /**
   * HTTPGetAction describes an action based on HTTP Get requests.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGet;

  /**
   * TCPSocketAction describes an action based on opening a socket
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartTcpSocket;

}

/**
 * Handler defines a specific action that should be taken
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePreStop
 */
export interface PostgresSpecPodTemplateSpecInitContainersLifecyclePreStop {
  /**
   * ExecAction describes a "run in container" action.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePreStop#exec
   */
  readonly exec?: PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopExec;

  /**
   * HTTPGetAction describes an action based on HTTP Get requests.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGet;

  /**
   * TCPSocketAction describes an action based on opening a socket
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopTcpSocket;

}

/**
 * ExecAction describes a "run in container" action.
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersLivenessProbeExec
 */
export interface PostgresSpecPodTemplateSpecInitContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersLivenessProbeHttpGet
 */
export interface PostgresSpecPodTemplateSpecInitContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: PostgresSpecPodTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * @schema PostgresSpecPodTemplateSpecInitContainersLivenessProbeHttpGet#port
   */
  readonly port: PostgresSpecPodTemplateSpecInitContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PostgresSpecPodTemplateSpecInitContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * TCPSocketAction describes an action based on opening a socket
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersLivenessProbeTcpSocket
 */
export interface PostgresSpecPodTemplateSpecInitContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema PostgresSpecPodTemplateSpecInitContainersLivenessProbeTcpSocket#port
   */
  readonly port: PostgresSpecPodTemplateSpecInitContainersLivenessProbeTcpSocketPort;

}

/**
 * ExecAction describes a "run in container" action.
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersReadinessProbeExec
 */
export interface PostgresSpecPodTemplateSpecInitContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersReadinessProbeHttpGet
 */
export interface PostgresSpecPodTemplateSpecInitContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: PostgresSpecPodTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * @schema PostgresSpecPodTemplateSpecInitContainersReadinessProbeHttpGet#port
   */
  readonly port: PostgresSpecPodTemplateSpecInitContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PostgresSpecPodTemplateSpecInitContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * TCPSocketAction describes an action based on opening a socket
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersReadinessProbeTcpSocket
 */
export interface PostgresSpecPodTemplateSpecInitContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema PostgresSpecPodTemplateSpecInitContainersReadinessProbeTcpSocket#port
   */
  readonly port: PostgresSpecPodTemplateSpecInitContainersReadinessProbeTcpSocketPort;

}

/**
 * Adds and removes POSIX capabilities from running containers.
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersSecurityContextCapabilities
 */
export interface PostgresSpecPodTemplateSpecInitContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * SELinuxOptions are the labels to be applied to the container
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersSecurityContextSeLinuxOptions
 */
export interface PostgresSpecPodTemplateSpecInitContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * ExecAction describes a "run in container" action.
 *
 * @schema PostgresSpecPodTemplateSpecLifecyclePostStartExec
 */
export interface PostgresSpecPodTemplateSpecLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PostgresSpecPodTemplateSpecLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 *
 * @schema PostgresSpecPodTemplateSpecLifecyclePostStartHttpGet
 */
export interface PostgresSpecPodTemplateSpecLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PostgresSpecPodTemplateSpecLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PostgresSpecPodTemplateSpecLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: PostgresSpecPodTemplateSpecLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PostgresSpecPodTemplateSpecLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * @schema PostgresSpecPodTemplateSpecLifecyclePostStartHttpGet#port
   */
  readonly port: PostgresSpecPodTemplateSpecLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PostgresSpecPodTemplateSpecLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * TCPSocketAction describes an action based on opening a socket
 *
 * @schema PostgresSpecPodTemplateSpecLifecyclePostStartTcpSocket
 */
export interface PostgresSpecPodTemplateSpecLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PostgresSpecPodTemplateSpecLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema PostgresSpecPodTemplateSpecLifecyclePostStartTcpSocket#port
   */
  readonly port: PostgresSpecPodTemplateSpecLifecyclePostStartTcpSocketPort;

}

/**
 * ExecAction describes a "run in container" action.
 *
 * @schema PostgresSpecPodTemplateSpecLifecyclePreStopExec
 */
export interface PostgresSpecPodTemplateSpecLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PostgresSpecPodTemplateSpecLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 *
 * @schema PostgresSpecPodTemplateSpecLifecyclePreStopHttpGet
 */
export interface PostgresSpecPodTemplateSpecLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PostgresSpecPodTemplateSpecLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PostgresSpecPodTemplateSpecLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: PostgresSpecPodTemplateSpecLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PostgresSpecPodTemplateSpecLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * @schema PostgresSpecPodTemplateSpecLifecyclePreStopHttpGet#port
   */
  readonly port: PostgresSpecPodTemplateSpecLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PostgresSpecPodTemplateSpecLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * TCPSocketAction describes an action based on opening a socket
 *
 * @schema PostgresSpecPodTemplateSpecLifecyclePreStopTcpSocket
 */
export interface PostgresSpecPodTemplateSpecLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PostgresSpecPodTemplateSpecLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema PostgresSpecPodTemplateSpecLifecyclePreStopTcpSocket#port
   */
  readonly port: PostgresSpecPodTemplateSpecLifecyclePreStopTcpSocketPort;

}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PostgresSpecPodTemplateSpecLivenessProbeHttpGetHttpHeaders
 */
export interface PostgresSpecPodTemplateSpecLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PostgresSpecPodTemplateSpecLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PostgresSpecPodTemplateSpecLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * @schema PostgresSpecPodTemplateSpecLivenessProbeHttpGetPort
 */
export class PostgresSpecPodTemplateSpecLivenessProbeHttpGetPort {
  public static fromString(value: string): PostgresSpecPodTemplateSpecLivenessProbeHttpGetPort {
    return new PostgresSpecPodTemplateSpecLivenessProbeHttpGetPort(value);
  }
  public static fromNumber(value: number): PostgresSpecPodTemplateSpecLivenessProbeHttpGetPort {
    return new PostgresSpecPodTemplateSpecLivenessProbeHttpGetPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * @schema PostgresSpecPodTemplateSpecLivenessProbeTcpSocketPort
 */
export class PostgresSpecPodTemplateSpecLivenessProbeTcpSocketPort {
  public static fromString(value: string): PostgresSpecPodTemplateSpecLivenessProbeTcpSocketPort {
    return new PostgresSpecPodTemplateSpecLivenessProbeTcpSocketPort(value);
  }
  public static fromNumber(value: number): PostgresSpecPodTemplateSpecLivenessProbeTcpSocketPort {
    return new PostgresSpecPodTemplateSpecLivenessProbeTcpSocketPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PostgresSpecPodTemplateSpecReadinessProbeHttpGetHttpHeaders
 */
export interface PostgresSpecPodTemplateSpecReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PostgresSpecPodTemplateSpecReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PostgresSpecPodTemplateSpecReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * @schema PostgresSpecPodTemplateSpecReadinessProbeHttpGetPort
 */
export class PostgresSpecPodTemplateSpecReadinessProbeHttpGetPort {
  public static fromString(value: string): PostgresSpecPodTemplateSpecReadinessProbeHttpGetPort {
    return new PostgresSpecPodTemplateSpecReadinessProbeHttpGetPort(value);
  }
  public static fromNumber(value: number): PostgresSpecPodTemplateSpecReadinessProbeHttpGetPort {
    return new PostgresSpecPodTemplateSpecReadinessProbeHttpGetPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * @schema PostgresSpecPodTemplateSpecReadinessProbeTcpSocketPort
 */
export class PostgresSpecPodTemplateSpecReadinessProbeTcpSocketPort {
  public static fromString(value: string): PostgresSpecPodTemplateSpecReadinessProbeTcpSocketPort {
    return new PostgresSpecPodTemplateSpecReadinessProbeTcpSocketPort(value);
  }
  public static fromNumber(value: number): PostgresSpecPodTemplateSpecReadinessProbeTcpSocketPort {
    return new PostgresSpecPodTemplateSpecReadinessProbeTcpSocketPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference: PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * A node selector represents the union of the results of one or more label queries over a set of nodes; that is, it represents the OR of the selectors represented by the node selector terms.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * Required. A list of node selector terms. The terms are ORed.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms: PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm: PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * weight associated with matching the corresponding podAffinityTerm, in the range 1-100.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight: number;

}

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * Selects a key from a ConfigMap.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecEnvValueFromConfigMapKeyRef
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or it's key must be defined
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * ObjectFieldSelector selects an APIVersioned field of an object.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecEnvValueFromFieldRef
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * ResourceFieldSelector represents container resources (cpu, memory) and their output format
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecEnvValueFromResourceFieldRef
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and Int64() accessors.

The serialization format is:

<quantity>        ::= <signedNumber><suffix>
  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
<digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
<decimalSI>       ::= m | "" | k | M | G | T | P | E
  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
<decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>

No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:
  a. No precision is lost
  b. No fractional digits will be emitted
  c. The exponent (or suffix) is as large as possible.
The sign will be omitted unless the number is negative.

Examples:
  1.5 will be serialized as "1500m"
  1.5Gi will be serialized as "1536Mi"

Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: string;

  /**
   * Required: resource to select
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecEnvValueFromSecretKeyRef
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or it's key must be defined
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * EnvVarSource represents a source for the value of an EnvVar.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFrom
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFrom {
  /**
   * Selects a key from a ConfigMap.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFromConfigMapKeyRef;

  /**
   * ObjectFieldSelector selects an APIVersioned field of an object.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFrom#fieldRef
   */
  readonly fieldRef?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFromFieldRef;

  /**
   * ResourceFieldSelector represents container resources (cpu, memory) and their output format
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFrom#resourceFieldRef
   */
  readonly resourceFieldRef?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFromResourceFieldRef;

  /**
   * SecretKeySelector selects a key of a Secret.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFromSecretKeyRef;

}

/**
 * ConfigMapEnvSource selects a ConfigMap to populate the environment variables with.

The contents of the target ConfigMap's Data field will represent the key-value pairs as environment variables.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvFromConfigMapRef
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvFromConfigMapRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvFromConfigMapRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap must be defined
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvFromConfigMapRef#optional
   */
  readonly optional?: boolean;

}

/**
 * SecretEnvSource selects a Secret to populate the environment variables with.

The contents of the target Secret's Data field will represent the key-value pairs as environment variables.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvFromSecretRef
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvFromSecretRef {
  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvFromSecretRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret must be defined
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvFromSecretRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Handler defines a specific action that should be taken
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStart
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStart {
  /**
   * ExecAction describes a "run in container" action.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStart#exec
   */
  readonly exec?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartExec;

  /**
   * HTTPGetAction describes an action based on HTTP Get requests.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStart#httpGet
   */
  readonly httpGet?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartHttpGet;

  /**
   * TCPSocketAction describes an action based on opening a socket
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStart#tcpSocket
   */
  readonly tcpSocket?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartTcpSocket;

}

/**
 * Handler defines a specific action that should be taken
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStop
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStop {
  /**
   * ExecAction describes a "run in container" action.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStop#exec
   */
  readonly exec?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopExec;

  /**
   * HTTPGetAction describes an action based on HTTP Get requests.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStop#httpGet
   */
  readonly httpGet?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopHttpGet;

  /**
   * TCPSocketAction describes an action based on opening a socket
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStop#tcpSocket
   */
  readonly tcpSocket?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopTcpSocket;

}

/**
 * ExecAction describes a "run in container" action.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeExec
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeHttpGet
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeHttpGet#port
   */
  readonly port: PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * TCPSocketAction describes an action based on opening a socket
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeTcpSocket
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeTcpSocket#port
   */
  readonly port: PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeTcpSocketPort;

}

/**
 * ExecAction describes a "run in container" action.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeExec
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeExec#command
   */
  readonly command?: string[];

}

/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeHttpGet
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeHttpGet#httpHeaders
   */
  readonly httpHeaders?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeHttpGet#path
   */
  readonly path?: string;

  /**
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeHttpGet#port
   */
  readonly port: PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * TCPSocketAction describes an action based on opening a socket
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeTcpSocket
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeTcpSocket#port
   */
  readonly port: PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeTcpSocketPort;

}

/**
 * Adds and removes POSIX capabilities from running containers.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersSecurityContextCapabilities
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersSecurityContextCapabilities {
  /**
   * Added capabilities
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * Removed capabilities
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * SELinuxOptions are the labels to be applied to the container
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersSecurityContextSeLinuxOptions
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersSecurityContextSeLinuxOptions {
  /**
   * Level is SELinux level label that applies to the container.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * Role is a SELinux role label that applies to the container.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * Type is a SELinux type label that applies to the container.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * User is a SELinux user label that applies to the container.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * ExecAction describes a "run in container" action.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartExec
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartHttpGet
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartHttpGet#port
   */
  readonly port: PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * TCPSocketAction describes an action based on opening a socket
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartTcpSocket
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartTcpSocket#port
   */
  readonly port: PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartTcpSocketPort;

}

/**
 * ExecAction describes a "run in container" action.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopExec
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopHttpGet
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopHttpGet#port
   */
  readonly port: PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * TCPSocketAction describes an action based on opening a socket
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopTcpSocket
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopTcpSocket#port
   */
  readonly port: PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopTcpSocketPort;

}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeHttpGetHttpHeaders
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * @schema PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeHttpGetPort
 */
export class PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeHttpGetPort {
  public static fromString(value: string): PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeHttpGetPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeHttpGetPort(value);
  }
  public static fromNumber(value: number): PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeHttpGetPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeHttpGetPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * @schema PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeTcpSocketPort
 */
export class PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeTcpSocketPort {
  public static fromString(value: string): PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeTcpSocketPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeTcpSocketPort(value);
  }
  public static fromNumber(value: number): PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeTcpSocketPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecLivenessProbeTcpSocketPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeHttpGetHttpHeaders
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * @schema PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeHttpGetPort
 */
export class PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeHttpGetPort {
  public static fromString(value: string): PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeHttpGetPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeHttpGetPort(value);
  }
  public static fromNumber(value: number): PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeHttpGetPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeHttpGetPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * @schema PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeTcpSocketPort
 */
export class PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeTcpSocketPort {
  public static fromString(value: string): PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeTcpSocketPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeTcpSocketPort(value);
  }
  public static fromNumber(value: number): PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeTcpSocketPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecReadinessProbeTcpSocketPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * ObjectFieldSelector selects an APIVersioned field of an object.
 *
 * @schema PostgresSpecConfigSourceProjectedSourcesDownwardApiItemsFieldRef
 */
export interface PostgresSpecConfigSourceProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema PostgresSpecConfigSourceProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema PostgresSpecConfigSourceProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * ResourceFieldSelector represents container resources (cpu, memory) and their output format
 *
 * @schema PostgresSpecConfigSourceProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface PostgresSpecConfigSourceProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema PostgresSpecConfigSourceProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and Int64() accessors.

The serialization format is:

<quantity>        ::= <signedNumber><suffix>
  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
<digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
<decimalSI>       ::= m | "" | k | M | G | T | P | E
  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
<decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>

No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:
  a. No precision is lost
  b. No fractional digits will be emitted
  c. The exponent (or suffix) is as large as possible.
The sign will be omitted unless the number is negative.

Examples:
  1.5 will be serialized as "1500m"
  1.5Gi will be serialized as "1536Mi"

Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.
   *
   * @schema PostgresSpecConfigSourceProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: string;

  /**
   * Required: resource to select
   *
   * @schema PostgresSpecConfigSourceProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * Maps a string key to a path within a volume.
 *
 * @schema PostgresSpecInitScriptSourceProjectedSourcesConfigMapItems
 */
export interface PostgresSpecInitScriptSourceProjectedSourcesConfigMapItems {
  /**
   * The key to project.
   *
   * @schema PostgresSpecInitScriptSourceProjectedSourcesConfigMapItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PostgresSpecInitScriptSourceProjectedSourcesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema PostgresSpecInitScriptSourceProjectedSourcesConfigMapItems#path
   */
  readonly path: string;

}

/**
 * DownwardAPIVolumeFile represents information to create the file containing the pod field
 *
 * @schema PostgresSpecInitScriptSourceProjectedSourcesDownwardApiItems
 */
export interface PostgresSpecInitScriptSourceProjectedSourcesDownwardApiItems {
  /**
   * ObjectFieldSelector selects an APIVersioned field of an object.
   *
   * @schema PostgresSpecInitScriptSourceProjectedSourcesDownwardApiItems#fieldRef
   */
  readonly fieldRef?: PostgresSpecInitScriptSourceProjectedSourcesDownwardApiItemsFieldRef;

  /**
   * Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PostgresSpecInitScriptSourceProjectedSourcesDownwardApiItems#mode
   */
  readonly mode?: number;

  /**
   * Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
   *
   * @schema PostgresSpecInitScriptSourceProjectedSourcesDownwardApiItems#path
   */
  readonly path: string;

  /**
   * ResourceFieldSelector represents container resources (cpu, memory) and their output format
   *
   * @schema PostgresSpecInitScriptSourceProjectedSourcesDownwardApiItems#resourceFieldRef
   */
  readonly resourceFieldRef?: PostgresSpecInitScriptSourceProjectedSourcesDownwardApiItemsResourceFieldRef;

}

/**
 * Maps a string key to a path within a volume.
 *
 * @schema PostgresSpecInitScriptSourceProjectedSourcesSecretItems
 */
export interface PostgresSpecInitScriptSourceProjectedSourcesSecretItems {
  /**
   * The key to project.
   *
   * @schema PostgresSpecInitScriptSourceProjectedSourcesSecretItems#key
   */
  readonly key: string;

  /**
   * Optional: mode bits to use on this file, must be a value between 0 and 0777. If not specified, the volume defaultMode will be used. This might be in conflict with other options that affect the file mode, like fsGroup, and the result can be other mode bits set.
   *
   * @schema PostgresSpecInitScriptSourceProjectedSourcesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * The relative path of the file to map the key to. May not be an absolute path. May not contain the path element '..'. May not start with the string '..'.
   *
   * @schema PostgresSpecInitScriptSourceProjectedSourcesSecretItems#path
   */
  readonly path: string;

}

/**
 * A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface PostgresSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: PostgresSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: PostgresSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface PostgresSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: PostgresSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: PostgresSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema PostgresSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface PostgresSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: PostgresSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema PostgresSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface PostgresSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: PostgresSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema PostgresSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface PostgresSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: PostgresSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema PostgresSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface PostgresSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: PostgresSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Selects a key from a ConfigMap.
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersEnvValueFromConfigMapKeyRef
 */
export interface PostgresSpecPodTemplateSpecInitContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or it's key must be defined
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * ObjectFieldSelector selects an APIVersioned field of an object.
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersEnvValueFromFieldRef
 */
export interface PostgresSpecPodTemplateSpecInitContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * ResourceFieldSelector represents container resources (cpu, memory) and their output format
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersEnvValueFromResourceFieldRef
 */
export interface PostgresSpecPodTemplateSpecInitContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and Int64() accessors.

The serialization format is:

<quantity>        ::= <signedNumber><suffix>
  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
<digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
<decimalSI>       ::= m | "" | k | M | G | T | P | E
  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
<decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>

No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:
  a. No precision is lost
  b. No fractional digits will be emitted
  c. The exponent (or suffix) is as large as possible.
The sign will be omitted unless the number is negative.

Examples:
  1.5 will be serialized as "1500m"
  1.5Gi will be serialized as "1536Mi"

Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: string;

  /**
   * Required: resource to select
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersEnvValueFromSecretKeyRef
 */
export interface PostgresSpecPodTemplateSpecInitContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or it's key must be defined
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * ExecAction describes a "run in container" action.
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartExec
 */
export interface PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGet
 */
export interface PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGet#port
   */
  readonly port: PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * TCPSocketAction describes an action based on opening a socket
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartTcpSocket
 */
export interface PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartTcpSocketPort;

}

/**
 * ExecAction describes a "run in container" action.
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopExec
 */
export interface PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGet
 */
export interface PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGet#port
   */
  readonly port: PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * TCPSocketAction describes an action based on opening a socket
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopTcpSocket
 */
export interface PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopTcpSocketPort;

}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders
 */
export interface PostgresSpecPodTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * @schema PostgresSpecPodTemplateSpecInitContainersLivenessProbeHttpGetPort
 */
export class PostgresSpecPodTemplateSpecInitContainersLivenessProbeHttpGetPort {
  public static fromString(value: string): PostgresSpecPodTemplateSpecInitContainersLivenessProbeHttpGetPort {
    return new PostgresSpecPodTemplateSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  public static fromNumber(value: number): PostgresSpecPodTemplateSpecInitContainersLivenessProbeHttpGetPort {
    return new PostgresSpecPodTemplateSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * @schema PostgresSpecPodTemplateSpecInitContainersLivenessProbeTcpSocketPort
 */
export class PostgresSpecPodTemplateSpecInitContainersLivenessProbeTcpSocketPort {
  public static fromString(value: string): PostgresSpecPodTemplateSpecInitContainersLivenessProbeTcpSocketPort {
    return new PostgresSpecPodTemplateSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromNumber(value: number): PostgresSpecPodTemplateSpecInitContainersLivenessProbeTcpSocketPort {
    return new PostgresSpecPodTemplateSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders
 */
export interface PostgresSpecPodTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * @schema PostgresSpecPodTemplateSpecInitContainersReadinessProbeHttpGetPort
 */
export class PostgresSpecPodTemplateSpecInitContainersReadinessProbeHttpGetPort {
  public static fromString(value: string): PostgresSpecPodTemplateSpecInitContainersReadinessProbeHttpGetPort {
    return new PostgresSpecPodTemplateSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  public static fromNumber(value: number): PostgresSpecPodTemplateSpecInitContainersReadinessProbeHttpGetPort {
    return new PostgresSpecPodTemplateSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * @schema PostgresSpecPodTemplateSpecInitContainersReadinessProbeTcpSocketPort
 */
export class PostgresSpecPodTemplateSpecInitContainersReadinessProbeTcpSocketPort {
  public static fromString(value: string): PostgresSpecPodTemplateSpecInitContainersReadinessProbeTcpSocketPort {
    return new PostgresSpecPodTemplateSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromNumber(value: number): PostgresSpecPodTemplateSpecInitContainersReadinessProbeTcpSocketPort {
    return new PostgresSpecPodTemplateSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PostgresSpecPodTemplateSpecLifecyclePostStartHttpGetHttpHeaders
 */
export interface PostgresSpecPodTemplateSpecLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PostgresSpecPodTemplateSpecLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PostgresSpecPodTemplateSpecLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * @schema PostgresSpecPodTemplateSpecLifecyclePostStartHttpGetPort
 */
export class PostgresSpecPodTemplateSpecLifecyclePostStartHttpGetPort {
  public static fromString(value: string): PostgresSpecPodTemplateSpecLifecyclePostStartHttpGetPort {
    return new PostgresSpecPodTemplateSpecLifecyclePostStartHttpGetPort(value);
  }
  public static fromNumber(value: number): PostgresSpecPodTemplateSpecLifecyclePostStartHttpGetPort {
    return new PostgresSpecPodTemplateSpecLifecyclePostStartHttpGetPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * @schema PostgresSpecPodTemplateSpecLifecyclePostStartTcpSocketPort
 */
export class PostgresSpecPodTemplateSpecLifecyclePostStartTcpSocketPort {
  public static fromString(value: string): PostgresSpecPodTemplateSpecLifecyclePostStartTcpSocketPort {
    return new PostgresSpecPodTemplateSpecLifecyclePostStartTcpSocketPort(value);
  }
  public static fromNumber(value: number): PostgresSpecPodTemplateSpecLifecyclePostStartTcpSocketPort {
    return new PostgresSpecPodTemplateSpecLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PostgresSpecPodTemplateSpecLifecyclePreStopHttpGetHttpHeaders
 */
export interface PostgresSpecPodTemplateSpecLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PostgresSpecPodTemplateSpecLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PostgresSpecPodTemplateSpecLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * @schema PostgresSpecPodTemplateSpecLifecyclePreStopHttpGetPort
 */
export class PostgresSpecPodTemplateSpecLifecyclePreStopHttpGetPort {
  public static fromString(value: string): PostgresSpecPodTemplateSpecLifecyclePreStopHttpGetPort {
    return new PostgresSpecPodTemplateSpecLifecyclePreStopHttpGetPort(value);
  }
  public static fromNumber(value: number): PostgresSpecPodTemplateSpecLifecyclePreStopHttpGetPort {
    return new PostgresSpecPodTemplateSpecLifecyclePreStopHttpGetPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * @schema PostgresSpecPodTemplateSpecLifecyclePreStopTcpSocketPort
 */
export class PostgresSpecPodTemplateSpecLifecyclePreStopTcpSocketPort {
  public static fromString(value: string): PostgresSpecPodTemplateSpecLifecyclePreStopTcpSocketPort {
    return new PostgresSpecPodTemplateSpecLifecyclePreStopTcpSocketPort(value);
  }
  public static fromNumber(value: number): PostgresSpecPodTemplateSpecLifecyclePreStopTcpSocketPort {
    return new PostgresSpecPodTemplateSpecLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * A list of node selector requirements by node's labels.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * A list of node selector requirements by node's fields.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key <topologyKey> matches that of any node on which a pod of the set of pods is running
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means "this pod's namespace"
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * Selects a key from a ConfigMap.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFromConfigMapKeyRef
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFromConfigMapKeyRef {
  /**
   * The key to select.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the ConfigMap or it's key must be defined
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * ObjectFieldSelector selects an APIVersioned field of an object.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFromFieldRef
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFromFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFromFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFromFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * ResourceFieldSelector represents container resources (cpu, memory) and their output format
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFromResourceFieldRef
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFromResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFromResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and Int64() accessors.

The serialization format is:

<quantity>        ::= <signedNumber><suffix>
  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
<digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
<decimalSI>       ::= m | "" | k | M | G | T | P | E
  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
<decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>

No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:
  a. No precision is lost
  b. No fractional digits will be emitted
  c. The exponent (or suffix) is as large as possible.
The sign will be omitted unless the number is negative.

Examples:
  1.5 will be serialized as "1500m"
  1.5Gi will be serialized as "1536Mi"

Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFromResourceFieldRef#divisor
   */
  readonly divisor?: string;

  /**
   * Required: resource to select
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFromResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * SecretKeySelector selects a key of a Secret.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFromSecretKeyRef
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFromSecretKeyRef {
  /**
   * The key of the secret to select from.  Must be a valid secret key.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFromSecretKeyRef#key
   */
  readonly key: string;

  /**
   * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * Specify whether the Secret or it's key must be defined
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * ExecAction describes a "run in container" action.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartExec
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartExec#command
   */
  readonly command?: string[];

}

/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartHttpGet
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartHttpGet#httpHeaders
   */
  readonly httpHeaders?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartHttpGet#path
   */
  readonly path?: string;

  /**
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartHttpGet#port
   */
  readonly port: PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * TCPSocketAction describes an action based on opening a socket
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartTcpSocket
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartTcpSocket#port
   */
  readonly port: PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartTcpSocketPort;

}

/**
 * ExecAction describes a "run in container" action.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopExec
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopExec {
  /**
   * Command is the command line to execute inside the container, the working directory for the command  is root ('/') in the container's filesystem. The command is simply exec'd, it is not run inside a shell, so traditional shell instructions ('|', etc) won't work. To use a shell, you need to explicitly call out to that shell. Exit status of 0 is treated as live/healthy and non-zero is unhealthy.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopExec#command
   */
  readonly command?: string[];

}

/**
 * HTTPGetAction describes an action based on HTTP Get requests.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopHttpGet
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopHttpGet {
  /**
   * Host name to connect to, defaults to the pod IP. You probably want to set "Host" in httpHeaders instead.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopHttpGet#host
   */
  readonly host?: string;

  /**
   * Custom headers to set in the request. HTTP allows repeated headers.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopHttpGet#httpHeaders
   */
  readonly httpHeaders?: PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders[];

  /**
   * Path to access on the HTTP server.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopHttpGet#path
   */
  readonly path?: string;

  /**
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopHttpGet#port
   */
  readonly port: PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopHttpGetPort;

  /**
   * Scheme to use for connecting to the host. Defaults to HTTP.
   *
   * @default HTTP.
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopHttpGet#scheme
   */
  readonly scheme?: string;

}

/**
 * TCPSocketAction describes an action based on opening a socket
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopTcpSocket
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopTcpSocket {
  /**
   * Optional: Host name to connect to, defaults to the pod IP.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopTcpSocket#host
   */
  readonly host?: string;

  /**
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopTcpSocket#port
   */
  readonly port: PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopTcpSocketPort;

}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeHttpGetPort
 */
export class PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeHttpGetPort {
  public static fromString(value: string): PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeHttpGetPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  public static fromNumber(value: number): PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeHttpGetPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeHttpGetPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeTcpSocketPort
 */
export class PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeTcpSocketPort {
  public static fromString(value: string): PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeTcpSocketPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  public static fromNumber(value: number): PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeTcpSocketPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecInitContainersLivenessProbeTcpSocketPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeHttpGetPort
 */
export class PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeHttpGetPort {
  public static fromString(value: string): PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeHttpGetPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  public static fromNumber(value: number): PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeHttpGetPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeHttpGetPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeTcpSocketPort
 */
export class PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeTcpSocketPort {
  public static fromString(value: string): PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeTcpSocketPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  public static fromNumber(value: number): PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeTcpSocketPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecInitContainersReadinessProbeTcpSocketPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartHttpGetHttpHeaders
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartHttpGetPort
 */
export class PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartHttpGetPort {
  public static fromString(value: string): PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartHttpGetPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartHttpGetPort(value);
  }
  public static fromNumber(value: number): PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartHttpGetPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartHttpGetPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartTcpSocketPort
 */
export class PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartTcpSocketPort {
  public static fromString(value: string): PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartTcpSocketPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartTcpSocketPort(value);
  }
  public static fromNumber(value: number): PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartTcpSocketPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopHttpGetHttpHeaders
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopHttpGetPort
 */
export class PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopHttpGetPort {
  public static fromString(value: string): PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopHttpGetPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopHttpGetPort(value);
  }
  public static fromNumber(value: number): PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopHttpGetPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopHttpGetPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * @schema PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopTcpSocketPort
 */
export class PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopTcpSocketPort {
  public static fromString(value: string): PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopTcpSocketPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopTcpSocketPort(value);
  }
  public static fromNumber(value: number): PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopTcpSocketPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * ObjectFieldSelector selects an APIVersioned field of an object.
 *
 * @schema PostgresSpecInitScriptSourceProjectedSourcesDownwardApiItemsFieldRef
 */
export interface PostgresSpecInitScriptSourceProjectedSourcesDownwardApiItemsFieldRef {
  /**
   * Version of the schema the FieldPath is written in terms of, defaults to "v1".
   *
   * @schema PostgresSpecInitScriptSourceProjectedSourcesDownwardApiItemsFieldRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Path of the field to select in the specified API version.
   *
   * @schema PostgresSpecInitScriptSourceProjectedSourcesDownwardApiItemsFieldRef#fieldPath
   */
  readonly fieldPath: string;

}

/**
 * ResourceFieldSelector represents container resources (cpu, memory) and their output format
 *
 * @schema PostgresSpecInitScriptSourceProjectedSourcesDownwardApiItemsResourceFieldRef
 */
export interface PostgresSpecInitScriptSourceProjectedSourcesDownwardApiItemsResourceFieldRef {
  /**
   * Container name: required for volumes, optional for env vars
   *
   * @schema PostgresSpecInitScriptSourceProjectedSourcesDownwardApiItemsResourceFieldRef#containerName
   */
  readonly containerName?: string;

  /**
   * Quantity is a fixed-point representation of a number. It provides convenient marshaling/unmarshaling in JSON and YAML, in addition to String() and Int64() accessors.

The serialization format is:

<quantity>        ::= <signedNumber><suffix>
  (Note that <suffix> may be empty, from the "" case in <decimalSI>.)
<digit>           ::= 0 | 1 | ... | 9 <digits>          ::= <digit> | <digit><digits> <number>          ::= <digits> | <digits>.<digits> | <digits>. | .<digits> <sign>            ::= "+" | "-" <signedNumber>    ::= <number> | <sign><number> <suffix>          ::= <binarySI> | <decimalExponent> | <decimalSI> <binarySI>        ::= Ki | Mi | Gi | Ti | Pi | Ei
  (International System of units; See: http://physics.nist.gov/cuu/Units/binary.html)
<decimalSI>       ::= m | "" | k | M | G | T | P | E
  (Note that 1024 = 1Ki but 1000 = 1k; I didn't choose the capitalization.)
<decimalExponent> ::= "e" <signedNumber> | "E" <signedNumber>

No matter which of the three exponent forms is used, no quantity may represent a number greater than 2^63-1 in magnitude, nor may it have more than 3 decimal places. Numbers larger or more precise will be capped or rounded up. (E.g.: 0.1m will rounded up to 1m.) This may be extended in the future if we require larger or smaller quantities.

When a Quantity is parsed from a string, it will remember the type of suffix it had, and will use the same type again when it is serialized.

Before serializing, Quantity will be put in "canonical form". This means that Exponent/suffix will be adjusted up or down (with a corresponding increase or decrease in Mantissa) such that:
  a. No precision is lost
  b. No fractional digits will be emitted
  c. The exponent (or suffix) is as large as possible.
The sign will be omitted unless the number is negative.

Examples:
  1.5 will be serialized as "1500m"
  1.5Gi will be serialized as "1536Mi"

Note that the quantity will NEVER be internally represented by a floating point number. That is the whole point of this exercise.

Non-canonical values will still parse as long as they are well formed, but will be re-emitted in their canonical form. (So always use canonical form, or don't diff.)

This format is intended to make it difficult to use these numbers without writing some sort of special handling code in the hopes that that will cause implementors to also use a fixed point implementation.
   *
   * @schema PostgresSpecInitScriptSourceProjectedSourcesDownwardApiItemsResourceFieldRef#divisor
   */
  readonly divisor?: string;

  /**
   * Required: resource to select
   *
   * @schema PostgresSpecInitScriptSourceProjectedSourcesDownwardApiItemsResourceFieldRef#resource
   */
  readonly resource: string;

}

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface PostgresSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface PostgresSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface PostgresSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface PostgresSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema PostgresSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface PostgresSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: PostgresSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PostgresSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface PostgresSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema PostgresSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface PostgresSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: PostgresSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PostgresSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface PostgresSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGetPort
 */
export class PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
  public static fromString(value: string): PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
    return new PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromNumber(value: number): PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
    return new PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartTcpSocketPort
 */
export class PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
  public static fromString(value: string): PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromNumber(value: number): PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new PostgresSpecPodTemplateSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGetPort
 */
export class PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
  public static fromString(value: string): PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
    return new PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromNumber(value: number): PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
    return new PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * @schema PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopTcpSocketPort
 */
export class PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
  public static fromString(value: string): PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromNumber(value: number): PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new PostgresSpecPodTemplateSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * The label key that the selector applies to.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * The label key that the selector applies to.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key: string;

  /**
   * Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator: string;

  /**
   * An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * A label selector is a label query over a set of resources. The result of matchLabels and matchExpressions are ANDed. An empty label selector matches all objects. A null label selector matches no objects.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartHttpGetPort
 */
export class PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
  public static fromString(value: string): PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  public static fromNumber(value: number): PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartHttpGetPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartHttpGetPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartTcpSocketPort
 */
export class PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
  public static fromString(value: string): PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  public static fromNumber(value: number): PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartTcpSocketPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePostStartTcpSocketPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * HTTPHeader describes a custom header to be used in HTTP probes
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders {
  /**
   * The header field name
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#name
   */
  readonly name: string;

  /**
   * The header field value
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopHttpGetHttpHeaders#value
   */
  readonly value: string;

}

/**
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopHttpGetPort
 */
export class PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
  public static fromString(value: string): PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  public static fromNumber(value: number): PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopHttpGetPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopHttpGetPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * @schema PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopTcpSocketPort
 */
export class PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
  public static fromString(value: string): PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  public static fromNumber(value: number): PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopTcpSocketPort {
    return new PostgresSpecBackupSchedulePodTemplateSpecInitContainersLifecyclePreStopTcpSocketPort(value);
  }
  private constructor(value: any) {
    Object.defineProperty(this, 'resolve', { value: () => value });
  }
}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PostgresSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface PostgresSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PostgresSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface PostgresSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PostgresSpecPodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema PostgresSpecBackupSchedulePodTemplateSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

