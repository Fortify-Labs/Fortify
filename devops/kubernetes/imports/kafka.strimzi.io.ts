// generated by cdk8s
import { ApiObject, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';

/**
 * 
 *
 * @schema Kafka
 */
export class Kafka extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Kafka"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kafka.strimzi.io/v1beta1',
    kind: 'Kafka',
  }

  /**
   * Renders a Kubernetes manifest for "Kafka".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KafkaProps = {}): any {
    return {
      ...Kafka.GVK,
      ...props,
    };
  }

  /**
   * Defines a "Kafka" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KafkaProps = {}) {
    super(scope, id, Kafka.manifest(props));
  }
}

/**
 * @schema Kafka
 */
export interface KafkaProps {
  /**
   * The specification of the Kafka and ZooKeeper clusters, and Topic Operator.
   *
   * @schema Kafka#spec
   */
  readonly spec?: KafkaSpec;

}

/**
 * The specification of the Kafka and ZooKeeper clusters, and Topic Operator.
 *
 * @schema KafkaSpec
 */
export interface KafkaSpec {
  /**
   * Configuration of the Kafka cluster.
   *
   * @schema KafkaSpec#kafka
   */
  readonly kafka: KafkaSpecKafka;

  /**
   * Configuration of the ZooKeeper cluster.
   *
   * @schema KafkaSpec#zookeeper
   */
  readonly zookeeper: KafkaSpecZookeeper;

  /**
   * Configuration of the Topic Operator.
   *
   * @schema KafkaSpec#topicOperator
   */
  readonly topicOperator?: KafkaSpecTopicOperator;

  /**
   * Configuration of the Entity Operator.
   *
   * @schema KafkaSpec#entityOperator
   */
  readonly entityOperator?: KafkaSpecEntityOperator;

  /**
   * Configuration of the cluster certificate authority.
   *
   * @schema KafkaSpec#clusterCa
   */
  readonly clusterCa?: KafkaSpecClusterCa;

  /**
   * Configuration of the clients certificate authority.
   *
   * @schema KafkaSpec#clientsCa
   */
  readonly clientsCa?: KafkaSpecClientsCa;

  /**
   * Configuration for Cruise Control deployment. Deploys a Cruise Control instance when specified.
   *
   * @schema KafkaSpec#cruiseControl
   */
  readonly cruiseControl?: KafkaSpecCruiseControl;

  /**
   * Configuration for JmxTrans. When the property is present a JmxTrans deployment is created for gathering JMX metrics from each Kafka broker. For more information see https://github.com/jmxtrans/jmxtrans[JmxTrans GitHub].
   *
   * @schema KafkaSpec#jmxTrans
   */
  readonly jmxTrans?: KafkaSpecJmxTrans;

  /**
   * Configuration of the Kafka Exporter. Kafka Exporter can provide additional metrics, for example lag of consumer group at topic/partition.
   *
   * @schema KafkaSpec#kafkaExporter
   */
  readonly kafkaExporter?: KafkaSpecKafkaExporter;

  /**
   * A list of time windows for maintenance tasks (that is, certificates renewal). Each time window is defined by a cron expression.
   *
   * @schema KafkaSpec#maintenanceTimeWindows
   */
  readonly maintenanceTimeWindows?: string[];

}

/**
 * Configuration of the Kafka cluster.
 *
 * @schema KafkaSpecKafka
 */
export interface KafkaSpecKafka {
  /**
   * The number of pods in the cluster.
   *
   * @schema KafkaSpecKafka#replicas
   */
  readonly replicas: number;

  /**
   * The docker image for the pods. The default value depends on the configured `Kafka.spec.kafka.version`.
   *
   * @schema KafkaSpecKafka#image
   */
  readonly image?: string;

  /**
   * Storage configuration (disk). Cannot be updated.
   *
   * @schema KafkaSpecKafka#storage
   */
  readonly storage: KafkaSpecKafkaStorage;

  /**
   * @schema KafkaSpecKafka#listeners
   */
  readonly listeners: any;

  /**
   * Authorization configuration for Kafka brokers.
   *
   * @schema KafkaSpecKafka#authorization
   */
  readonly authorization?: KafkaSpecKafkaAuthorization;

  /**
   * Kafka broker config properties with the following prefixes cannot be set: listeners, advertised., broker., listener., host.name, port, inter.broker.listener.name, sasl., ssl., security., password., principal.builder.class, log.dir, zookeeper.connect, zookeeper.set.acl, zookeeper.ssl, zookeeper.clientCnxnSocket, authorizer., super.user, cruise.control.metrics.topic, cruise.control.metrics.reporter.bootstrap.servers (with the exception of: zookeeper.connection.timeout.ms, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols,cruise.control.metrics.topic.num.partitions, cruise.control.metrics.topic.replication.factor, cruise.control.metrics.topic.retention.ms,cruise.control.metrics.topic.auto.create.retries, cruise.control.metrics.topic.auto.create.timeout.ms).
   *
   * @schema KafkaSpecKafka#config
   */
  readonly config?: any;

  /**
   * Configuration of the `broker.rack` broker config.
   *
   * @schema KafkaSpecKafka#rack
   */
  readonly rack?: KafkaSpecKafkaRack;

  /**
   * The image of the init container used for initializing the `broker.rack`.
   *
   * @schema KafkaSpecKafka#brokerRackInitImage
   */
  readonly brokerRackInitImage?: string;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaSpecKafka#affinity
   */
  readonly affinity?: KafkaSpecKafkaAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaSpecKafka#tolerations
   */
  readonly tolerations?: KafkaSpecKafkaTolerations[];

  /**
   * Pod liveness checking.
   *
   * @schema KafkaSpecKafka#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecKafkaLivenessProbe;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaSpecKafka#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecKafkaReadinessProbe;

  /**
   * JVM Options for pods.
   *
   * @schema KafkaSpecKafka#jvmOptions
   */
  readonly jvmOptions?: KafkaSpecKafkaJvmOptions;

  /**
   * JMX Options for Kafka brokers.
   *
   * @schema KafkaSpecKafka#jmxOptions
   */
  readonly jmxOptions?: KafkaSpecKafkaJmxOptions;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecKafka#resources
   */
  readonly resources?: KafkaSpecKafkaResources;

  /**
   * The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
   *
   * @schema KafkaSpecKafka#metrics
   */
  readonly metrics?: any;

  /**
   * Logging configuration for Kafka.
   *
   * @schema KafkaSpecKafka#logging
   */
  readonly logging?: KafkaSpecKafkaLogging;

  /**
   * TLS sidecar configuration.
   *
   * @schema KafkaSpecKafka#tlsSidecar
   */
  readonly tlsSidecar?: KafkaSpecKafkaTlsSidecar;

  /**
   * Template for Kafka cluster resources. The template allows users to specify how are the `StatefulSet`, `Pods` and `Services` generated.
   *
   * @schema KafkaSpecKafka#template
   */
  readonly template?: KafkaSpecKafkaTemplate;

  /**
   * The kafka broker version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
   *
   * @default DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
   * @schema KafkaSpecKafka#version
   */
  readonly version?: string;

}

/**
 * Configuration of the ZooKeeper cluster.
 *
 * @schema KafkaSpecZookeeper
 */
export interface KafkaSpecZookeeper {
  /**
   * The number of pods in the cluster.
   *
   * @schema KafkaSpecZookeeper#replicas
   */
  readonly replicas: number;

  /**
   * The docker image for the pods.
   *
   * @schema KafkaSpecZookeeper#image
   */
  readonly image?: string;

  /**
   * Storage configuration (disk). Cannot be updated.
   *
   * @schema KafkaSpecZookeeper#storage
   */
  readonly storage: KafkaSpecZookeeperStorage;

  /**
   * The ZooKeeper broker config. Properties with the following prefixes cannot be set: server., dataDir, dataLogDir, clientPort, authProvider, quorum.auth, requireClientAuthScheme, snapshot.trust.empty, standaloneEnabled, reconfigEnabled, 4lw.commands.whitelist, secureClientPort, ssl., serverCnxnFactory, sslQuorum (with the exception of: ssl.protocol, ssl.quorum.protocol, ssl.enabledProtocols, ssl.quorum.enabledProtocols, ssl.ciphersuites, ssl.quorum.ciphersuites, ssl.hostnameVerification, ssl.quorum.hostnameVerification).
   *
   * @schema KafkaSpecZookeeper#config
   */
  readonly config?: any;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaSpecZookeeper#affinity
   */
  readonly affinity?: KafkaSpecZookeeperAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaSpecZookeeper#tolerations
   */
  readonly tolerations?: KafkaSpecZookeeperTolerations[];

  /**
   * Pod liveness checking.
   *
   * @schema KafkaSpecZookeeper#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecZookeeperLivenessProbe;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaSpecZookeeper#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecZookeeperReadinessProbe;

  /**
   * JVM Options for pods.
   *
   * @schema KafkaSpecZookeeper#jvmOptions
   */
  readonly jvmOptions?: KafkaSpecZookeeperJvmOptions;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecZookeeper#resources
   */
  readonly resources?: KafkaSpecZookeeperResources;

  /**
   * The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
   *
   * @schema KafkaSpecZookeeper#metrics
   */
  readonly metrics?: any;

  /**
   * Logging configuration for ZooKeeper.
   *
   * @schema KafkaSpecZookeeper#logging
   */
  readonly logging?: KafkaSpecZookeeperLogging;

  /**
   * Template for ZooKeeper cluster resources. The template allows users to specify how are the `StatefulSet`, `Pods` and `Services` generated.
   *
   * @schema KafkaSpecZookeeper#template
   */
  readonly template?: KafkaSpecZookeeperTemplate;

  /**
   * TLS sidecar configuration. The TLS sidecar is not used anymore and this option will be ignored.
   *
   * @schema KafkaSpecZookeeper#tlsSidecar
   */
  readonly tlsSidecar?: KafkaSpecZookeeperTlsSidecar;

}

/**
 * Configuration of the Topic Operator.
 *
 * @schema KafkaSpecTopicOperator
 */
export interface KafkaSpecTopicOperator {
  /**
   * The namespace the Topic Operator should watch.
   *
   * @schema KafkaSpecTopicOperator#watchedNamespace
   */
  readonly watchedNamespace?: string;

  /**
   * The image to use for the Topic Operator.
   *
   * @schema KafkaSpecTopicOperator#image
   */
  readonly image?: string;

  /**
   * Interval between periodic reconciliations.
   *
   * @schema KafkaSpecTopicOperator#reconciliationIntervalSeconds
   */
  readonly reconciliationIntervalSeconds?: number;

  /**
   * Timeout for the ZooKeeper session.
   *
   * @schema KafkaSpecTopicOperator#zookeeperSessionTimeoutSeconds
   */
  readonly zookeeperSessionTimeoutSeconds?: number;

  /**
   * Pod affinity rules.
   *
   * @schema KafkaSpecTopicOperator#affinity
   */
  readonly affinity?: KafkaSpecTopicOperatorAffinity;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecTopicOperator#resources
   */
  readonly resources?: KafkaSpecTopicOperatorResources;

  /**
   * The number of attempts at getting topic metadata.
   *
   * @schema KafkaSpecTopicOperator#topicMetadataMaxAttempts
   */
  readonly topicMetadataMaxAttempts?: number;

  /**
   * TLS sidecar configuration.
   *
   * @schema KafkaSpecTopicOperator#tlsSidecar
   */
  readonly tlsSidecar?: KafkaSpecTopicOperatorTlsSidecar;

  /**
   * Logging configuration.
   *
   * @schema KafkaSpecTopicOperator#logging
   */
  readonly logging?: KafkaSpecTopicOperatorLogging;

  /**
   * JVM Options for pods.
   *
   * @schema KafkaSpecTopicOperator#jvmOptions
   */
  readonly jvmOptions?: KafkaSpecTopicOperatorJvmOptions;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaSpecTopicOperator#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecTopicOperatorLivenessProbe;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaSpecTopicOperator#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecTopicOperatorReadinessProbe;

}

/**
 * Configuration of the Entity Operator.
 *
 * @schema KafkaSpecEntityOperator
 */
export interface KafkaSpecEntityOperator {
  /**
   * Configuration of the Topic Operator.
   *
   * @schema KafkaSpecEntityOperator#topicOperator
   */
  readonly topicOperator?: KafkaSpecEntityOperatorTopicOperator;

  /**
   * Configuration of the User Operator.
   *
   * @schema KafkaSpecEntityOperator#userOperator
   */
  readonly userOperator?: KafkaSpecEntityOperatorUserOperator;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaSpecEntityOperator#affinity
   */
  readonly affinity?: KafkaSpecEntityOperatorAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaSpecEntityOperator#tolerations
   */
  readonly tolerations?: KafkaSpecEntityOperatorTolerations[];

  /**
   * TLS sidecar configuration.
   *
   * @schema KafkaSpecEntityOperator#tlsSidecar
   */
  readonly tlsSidecar?: KafkaSpecEntityOperatorTlsSidecar;

  /**
   * Template for Entity Operator resources. The template allows users to specify how is the `Deployment` and `Pods` generated.
   *
   * @schema KafkaSpecEntityOperator#template
   */
  readonly template?: KafkaSpecEntityOperatorTemplate;

}

/**
 * Configuration of the cluster certificate authority.
 *
 * @schema KafkaSpecClusterCa
 */
export interface KafkaSpecClusterCa {
  /**
   * If true then Certificate Authority certificates will be generated automatically. Otherwise the user will need to provide a Secret with the CA certificate. Default is true.
   *
   * @default true.
   * @schema KafkaSpecClusterCa#generateCertificateAuthority
   */
  readonly generateCertificateAuthority?: boolean;

  /**
   * The number of days generated certificates should be valid for. The default is 365.
   *
   * @schema KafkaSpecClusterCa#validityDays
   */
  readonly validityDays?: number;

  /**
   * The number of days in the certificate renewal period. This is the number of days before the a certificate expires during which renewal actions may be performed. When `generateCertificateAuthority` is true, this will cause the generation of a new certificate. When `generateCertificateAuthority` is true, this will cause extra logging at WARN level about the pending certificate expiry. Default is 30.
   *
   * @default 30.
   * @schema KafkaSpecClusterCa#renewalDays
   */
  readonly renewalDays?: number;

  /**
   * How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.
   *
   * @schema KafkaSpecClusterCa#certificateExpirationPolicy
   */
  readonly certificateExpirationPolicy?: KafkaSpecClusterCaCertificateExpirationPolicy;

}

/**
 * Configuration of the clients certificate authority.
 *
 * @schema KafkaSpecClientsCa
 */
export interface KafkaSpecClientsCa {
  /**
   * If true then Certificate Authority certificates will be generated automatically. Otherwise the user will need to provide a Secret with the CA certificate. Default is true.
   *
   * @default true.
   * @schema KafkaSpecClientsCa#generateCertificateAuthority
   */
  readonly generateCertificateAuthority?: boolean;

  /**
   * The number of days generated certificates should be valid for. The default is 365.
   *
   * @schema KafkaSpecClientsCa#validityDays
   */
  readonly validityDays?: number;

  /**
   * The number of days in the certificate renewal period. This is the number of days before the a certificate expires during which renewal actions may be performed. When `generateCertificateAuthority` is true, this will cause the generation of a new certificate. When `generateCertificateAuthority` is true, this will cause extra logging at WARN level about the pending certificate expiry. Default is 30.
   *
   * @default 30.
   * @schema KafkaSpecClientsCa#renewalDays
   */
  readonly renewalDays?: number;

  /**
   * How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.
   *
   * @schema KafkaSpecClientsCa#certificateExpirationPolicy
   */
  readonly certificateExpirationPolicy?: KafkaSpecClientsCaCertificateExpirationPolicy;

}

/**
 * Configuration for Cruise Control deployment. Deploys a Cruise Control instance when specified.
 *
 * @schema KafkaSpecCruiseControl
 */
export interface KafkaSpecCruiseControl {
  /**
   * The docker image for the pods.
   *
   * @schema KafkaSpecCruiseControl#image
   */
  readonly image?: string;

  /**
   * TLS sidecar configuration.
   *
   * @schema KafkaSpecCruiseControl#tlsSidecar
   */
  readonly tlsSidecar?: KafkaSpecCruiseControlTlsSidecar;

  /**
   * CPU and memory resources to reserve for the Cruise Control container.
   *
   * @schema KafkaSpecCruiseControl#resources
   */
  readonly resources?: KafkaSpecCruiseControlResources;

  /**
   * Pod liveness checking for the Cruise Control container.
   *
   * @schema KafkaSpecCruiseControl#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecCruiseControlLivenessProbe;

  /**
   * Pod readiness checking for the Cruise Control container.
   *
   * @schema KafkaSpecCruiseControl#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecCruiseControlReadinessProbe;

  /**
   * JVM Options for the Cruise Control container.
   *
   * @schema KafkaSpecCruiseControl#jvmOptions
   */
  readonly jvmOptions?: KafkaSpecCruiseControlJvmOptions;

  /**
   * Logging configuration (log4j1) for Cruise Control.
   *
   * @schema KafkaSpecCruiseControl#logging
   */
  readonly logging?: KafkaSpecCruiseControlLogging;

  /**
   * Template to specify how Cruise Control resources, `Deployments` and `Pods`, are generated.
   *
   * @schema KafkaSpecCruiseControl#template
   */
  readonly template?: KafkaSpecCruiseControlTemplate;

  /**
   * The Cruise Control `brokerCapacity` configuration.
   *
   * @schema KafkaSpecCruiseControl#brokerCapacity
   */
  readonly brokerCapacity?: KafkaSpecCruiseControlBrokerCapacity;

  /**
   * The Cruise Control configuration. For a full list of configuration options refer to https://github.com/linkedin/cruise-control/wiki/Configurations. Note that properties with the following prefixes cannot be set: bootstrap.servers, client.id, zookeeper., network., security., failed.brokers.zk.path,webserver.http., webserver.api.urlprefix, webserver.session.path, webserver.accesslog., two.step., request.reason.required,metric.reporter.sampler.bootstrap.servers, metric.reporter.topic, partition.metric.sample.store.topic, broker.metric.sample.store.topic,capacity.config.file, self.healing., anomaly.detection., ssl.
   *
   * @schema KafkaSpecCruiseControl#config
   */
  readonly config?: any;

  /**
   * The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
   *
   * @schema KafkaSpecCruiseControl#metrics
   */
  readonly metrics?: any;

}

/**
 * Configuration for JmxTrans. When the property is present a JmxTrans deployment is created for gathering JMX metrics from each Kafka broker. For more information see https://github.com/jmxtrans/jmxtrans[JmxTrans GitHub].
 *
 * @schema KafkaSpecJmxTrans
 */
export interface KafkaSpecJmxTrans {
  /**
   * The image to use for the JmxTrans.
   *
   * @schema KafkaSpecJmxTrans#image
   */
  readonly image?: string;

  /**
   * Defines the output hosts that will be referenced later on. For more information on these properties see, xref:type-JmxTransOutputDefinitionTemplate-reference[`JmxTransOutputDefinitionTemplate` schema reference].
   *
   * @schema KafkaSpecJmxTrans#outputDefinitions
   */
  readonly outputDefinitions: KafkaSpecJmxTransOutputDefinitions[];

  /**
   * Sets the logging level of the JmxTrans deployment.For more information see, https://github.com/jmxtrans/jmxtrans-agent/wiki/Troubleshooting[JmxTrans Logging Level].
   *
   * @schema KafkaSpecJmxTrans#logLevel
   */
  readonly logLevel?: string;

  /**
   * Queries to send to the Kafka brokers to define what data should be read from each broker. For more information on these properties see, xref:type-JmxTransQueryTemplate-reference[`JmxTransQueryTemplate` schema reference].
   *
   * @schema KafkaSpecJmxTrans#kafkaQueries
   */
  readonly kafkaQueries: KafkaSpecJmxTransKafkaQueries[];

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecJmxTrans#resources
   */
  readonly resources?: KafkaSpecJmxTransResources;

  /**
   * Template for JmxTrans resources.
   *
   * @schema KafkaSpecJmxTrans#template
   */
  readonly template?: KafkaSpecJmxTransTemplate;

}

/**
 * Configuration of the Kafka Exporter. Kafka Exporter can provide additional metrics, for example lag of consumer group at topic/partition.
 *
 * @schema KafkaSpecKafkaExporter
 */
export interface KafkaSpecKafkaExporter {
  /**
   * The docker image for the pods.
   *
   * @schema KafkaSpecKafkaExporter#image
   */
  readonly image?: string;

  /**
   * Regular expression to specify which consumer groups to collect. Default value is `.*`.
   *
   * @schema KafkaSpecKafkaExporter#groupRegex
   */
  readonly groupRegex?: string;

  /**
   * Regular expression to specify which topics to collect. Default value is `.*`.
   *
   * @schema KafkaSpecKafkaExporter#topicRegex
   */
  readonly topicRegex?: string;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecKafkaExporter#resources
   */
  readonly resources?: KafkaSpecKafkaExporterResources;

  /**
   * Only log messages with the given severity or above. Valid levels: [`debug`, `info`, `warn`, `error`, `fatal`]. Default log level is `info`.
   *
   * @schema KafkaSpecKafkaExporter#logging
   */
  readonly logging?: string;

  /**
   * Enable Sarama logging, a Go client library used by the Kafka Exporter.
   *
   * @schema KafkaSpecKafkaExporter#enableSaramaLogging
   */
  readonly enableSaramaLogging?: boolean;

  /**
   * Customization of deployment templates and pods.
   *
   * @schema KafkaSpecKafkaExporter#template
   */
  readonly template?: KafkaSpecKafkaExporterTemplate;

  /**
   * Pod liveness check.
   *
   * @schema KafkaSpecKafkaExporter#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecKafkaExporterLivenessProbe;

  /**
   * Pod readiness check.
   *
   * @schema KafkaSpecKafkaExporter#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecKafkaExporterReadinessProbe;

}

/**
 * Storage configuration (disk). Cannot be updated.
 *
 * @schema KafkaSpecKafkaStorage
 */
export interface KafkaSpecKafkaStorage {
  /**
   * The storage class to use for dynamic volume allocation.
   *
   * @schema KafkaSpecKafkaStorage#class
   */
  readonly class?: string;

  /**
   * Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
   *
   * @schema KafkaSpecKafkaStorage#deleteClaim
   */
  readonly deleteClaim?: boolean;

  /**
   * Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
   *
   * @schema KafkaSpecKafkaStorage#id
   */
  readonly id?: number;

  /**
   * Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
   *
   * @schema KafkaSpecKafkaStorage#overrides
   */
  readonly overrides?: KafkaSpecKafkaStorageOverrides[];

  /**
   * Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
   *
   * @schema KafkaSpecKafkaStorage#selector
   */
  readonly selector?: any;

  /**
   * When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
   *
   * @schema KafkaSpecKafkaStorage#size
   */
  readonly size?: string;

  /**
   * When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
   *
   * @schema KafkaSpecKafkaStorage#sizeLimit
   */
  readonly sizeLimit?: string;

  /**
   * Storage type, must be either 'ephemeral', 'persistent-claim', or 'jbod'.
   *
   * @schema KafkaSpecKafkaStorage#type
   */
  readonly type: KafkaSpecKafkaStorageType;

  /**
   * List of volumes as Storage objects representing the JBOD disks array.
   *
   * @schema KafkaSpecKafkaStorage#volumes
   */
  readonly volumes?: KafkaSpecKafkaStorageVolumes[];

}

/**
 * Authorization configuration for Kafka brokers.
 *
 * @schema KafkaSpecKafkaAuthorization
 */
export interface KafkaSpecKafkaAuthorization {
  /**
   * Defines whether a Kafka client should be allowed or denied by default when the authorizer fails to query the Open Policy Agent, for example, when it is temporarily unavailable). Defaults to `false` - all actions will be denied.
   *
   * @default false` - all actions will be denied.
   * @schema KafkaSpecKafkaAuthorization#allowOnError
   */
  readonly allowOnError?: boolean;

  /**
   * OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
   *
   * @schema KafkaSpecKafkaAuthorization#clientId
   */
  readonly clientId?: string;

  /**
   * Whether authorization decision should be delegated to the 'Simple' authorizer if DENIED by Keycloak Authorization Services policies. Default value is `false`.
   *
   * @schema KafkaSpecKafkaAuthorization#delegateToKafkaAcls
   */
  readonly delegateToKafkaAcls?: boolean;

  /**
   * Enable or disable TLS hostname verification. Default value is `false`.
   *
   * @schema KafkaSpecKafkaAuthorization#disableTlsHostnameVerification
   */
  readonly disableTlsHostnameVerification?: boolean;

  /**
   * The expiration of the records kept in the local cache to avoid querying the Open Policy Agent for every request. Defines how often the cached authorization decisions are reloaded from the Open Policy Agent server. In milliseconds. Defaults to `3600000`.
   *
   * @default 3600000`.
   * @schema KafkaSpecKafkaAuthorization#expireAfterMs
   */
  readonly expireAfterMs?: number;

  /**
   * The time between two consecutive grants refresh runs in seconds. The default value is 60.
   *
   * @schema KafkaSpecKafkaAuthorization#grantsRefreshPeriodSeconds
   */
  readonly grantsRefreshPeriodSeconds?: number;

  /**
   * The number of threads to use to refresh grants for active sessions. The more threads, the more parallelism, so the sooner the job completes. However, using more threads places a heavier load on the authorization server. The default value is 5.
   *
   * @schema KafkaSpecKafkaAuthorization#grantsRefreshPoolSize
   */
  readonly grantsRefreshPoolSize?: number;

  /**
   * Initial capacity of the local cache used by the authorizer to avoid querying the Open Policy Agent for every request Defaults to `5000`.
   *
   * @default 5000`.
   * @schema KafkaSpecKafkaAuthorization#initialCacheCapacity
   */
  readonly initialCacheCapacity?: number;

  /**
   * Maximum capacity of the local cache used by the authorizer to avoid querying the Open Policy Agent for every request. Defaults to `50000`.
   *
   * @default 50000`.
   * @schema KafkaSpecKafkaAuthorization#maximumCacheSize
   */
  readonly maximumCacheSize?: number;

  /**
   * List of super users. Should contain list of user principals which should get unlimited access rights.
   *
   * @schema KafkaSpecKafkaAuthorization#superUsers
   */
  readonly superUsers?: string[];

  /**
   * Trusted certificates for TLS connection to the OAuth server.
   *
   * @schema KafkaSpecKafkaAuthorization#tlsTrustedCertificates
   */
  readonly tlsTrustedCertificates?: KafkaSpecKafkaAuthorizationTlsTrustedCertificates[];

  /**
   * Authorization server token endpoint URI.
   *
   * @schema KafkaSpecKafkaAuthorization#tokenEndpointUri
   */
  readonly tokenEndpointUri?: string;

  /**
   * Authorization type. Currently, the supported types are `simple`, `keycloak`, and `opa`. `simple` authorization type uses Kafka's `kafka.security.authorizer.AclAuthorizer` class for authorization. `keycloak` authorization type uses Keycloak Authorization Services for authorization. `opa` authorization type uses Open Policy Agent based authorization.
   *
   * @schema KafkaSpecKafkaAuthorization#type
   */
  readonly type: KafkaSpecKafkaAuthorizationType;

  /**
   * The URL used to connect to the Open Policy Agent server. The URL has to include the policy which will be queried by the authorizer. This option is required.
   *
   * @schema KafkaSpecKafkaAuthorization#url
   */
  readonly url?: string;

}

/**
 * Configuration of the `broker.rack` broker config.
 *
 * @schema KafkaSpecKafkaRack
 */
export interface KafkaSpecKafkaRack {
  /**
   * A key that matches labels assigned to the Kubernetes cluster nodes. The value of the label is used to set the broker's `broker.rack` config.
   *
   * @schema KafkaSpecKafkaRack#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecKafkaAffinity
 */
export interface KafkaSpecKafkaAffinity {
  /**
   * @schema KafkaSpecKafkaAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaSpecKafkaAffinityNodeAffinity;

  /**
   * @schema KafkaSpecKafkaAffinity#podAffinity
   */
  readonly podAffinity?: KafkaSpecKafkaAffinityPodAffinity;

  /**
   * @schema KafkaSpecKafkaAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaSpecKafkaAffinityPodAntiAffinity;

}

/**
 * @schema KafkaSpecKafkaTolerations
 */
export interface KafkaSpecKafkaTolerations {
  /**
   * @schema KafkaSpecKafkaTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaSpecKafkaTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaSpecKafkaTolerations#value
   */
  readonly value?: string;

}

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecKafkaLivenessProbe
 */
export interface KafkaSpecKafkaLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecKafkaLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecKafkaLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecKafkaLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecKafkaLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecKafkaLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecKafkaReadinessProbe
 */
export interface KafkaSpecKafkaReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecKafkaReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecKafkaReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecKafkaReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecKafkaReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecKafkaReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * JVM Options for pods.
 *
 * @schema KafkaSpecKafkaJvmOptions
 */
export interface KafkaSpecKafkaJvmOptions {
  /**
   * A map of -XX options to the JVM.
   *
   * @schema KafkaSpecKafkaJvmOptions#-XX
   */
  readonly xx?: any;

  /**
   * -Xms option to to the JVM.
   *
   * @schema KafkaSpecKafkaJvmOptions#-Xms
   */
  readonly xms?: string;

  /**
   * -Xmx option to to the JVM.
   *
   * @schema KafkaSpecKafkaJvmOptions#-Xmx
   */
  readonly xmx?: string;

  /**
   * Specifies whether the Garbage Collection logging is enabled. The default is false.
   *
   * @schema KafkaSpecKafkaJvmOptions#gcLoggingEnabled
   */
  readonly gcLoggingEnabled?: boolean;

  /**
   * A map of additional system properties which will be passed using the `-D` option to the JVM.
   *
   * @schema KafkaSpecKafkaJvmOptions#javaSystemProperties
   */
  readonly javaSystemProperties?: KafkaSpecKafkaJvmOptionsJavaSystemProperties[];

}

/**
 * JMX Options for Kafka brokers.
 *
 * @schema KafkaSpecKafkaJmxOptions
 */
export interface KafkaSpecKafkaJmxOptions {
  /**
   * Authentication configuration for connecting to the Kafka JMX port.
   *
   * @schema KafkaSpecKafkaJmxOptions#authentication
   */
  readonly authentication?: KafkaSpecKafkaJmxOptionsAuthentication;

}

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecKafkaResources
 */
export interface KafkaSpecKafkaResources {
  /**
   * @schema KafkaSpecKafkaResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecKafkaResources#requests
   */
  readonly requests?: any;

}

/**
 * Logging configuration for Kafka.
 *
 * @schema KafkaSpecKafkaLogging
 */
export interface KafkaSpecKafkaLogging {
  /**
   * A Map from logger name to logger level.
   *
   * @schema KafkaSpecKafkaLogging#loggers
   */
  readonly loggers?: any;

  /**
   * The name of the `ConfigMap` from which to get the logging configuration.
   *
   * @schema KafkaSpecKafkaLogging#name
   */
  readonly name?: string;

  /**
   * Logging type, must be either 'inline' or 'external'.
   *
   * @schema KafkaSpecKafkaLogging#type
   */
  readonly type: KafkaSpecKafkaLoggingType;

}

/**
 * TLS sidecar configuration.
 *
 * @schema KafkaSpecKafkaTlsSidecar
 */
export interface KafkaSpecKafkaTlsSidecar {
  /**
   * The docker image for the container.
   *
   * @schema KafkaSpecKafkaTlsSidecar#image
   */
  readonly image?: string;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaSpecKafkaTlsSidecar#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecKafkaTlsSidecarLivenessProbe;

  /**
   * The log level for the TLS sidecar. Default value is `notice`.
   *
   * @schema KafkaSpecKafkaTlsSidecar#logLevel
   */
  readonly logLevel?: KafkaSpecKafkaTlsSidecarLogLevel;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaSpecKafkaTlsSidecar#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecKafkaTlsSidecarReadinessProbe;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecKafkaTlsSidecar#resources
   */
  readonly resources?: KafkaSpecKafkaTlsSidecarResources;

}

/**
 * Template for Kafka cluster resources. The template allows users to specify how are the `StatefulSet`, `Pods` and `Services` generated.
 *
 * @schema KafkaSpecKafkaTemplate
 */
export interface KafkaSpecKafkaTemplate {
  /**
   * Template for Kafka `StatefulSet`.
   *
   * @schema KafkaSpecKafkaTemplate#statefulset
   */
  readonly statefulset?: KafkaSpecKafkaTemplateStatefulset;

  /**
   * Template for Kafka `Pods`.
   *
   * @schema KafkaSpecKafkaTemplate#pod
   */
  readonly pod?: KafkaSpecKafkaTemplatePod;

  /**
   * Template for Kafka bootstrap `Service`.
   *
   * @schema KafkaSpecKafkaTemplate#bootstrapService
   */
  readonly bootstrapService?: KafkaSpecKafkaTemplateBootstrapService;

  /**
   * Template for Kafka broker `Service`.
   *
   * @schema KafkaSpecKafkaTemplate#brokersService
   */
  readonly brokersService?: KafkaSpecKafkaTemplateBrokersService;

  /**
   * Template for Kafka external bootstrap `Service`.
   *
   * @schema KafkaSpecKafkaTemplate#externalBootstrapService
   */
  readonly externalBootstrapService?: KafkaSpecKafkaTemplateExternalBootstrapService;

  /**
   * Template for Kafka per-pod `Services` used for access from outside of Kubernetes.
   *
   * @schema KafkaSpecKafkaTemplate#perPodService
   */
  readonly perPodService?: KafkaSpecKafkaTemplatePerPodService;

  /**
   * Template for Kafka external bootstrap `Route`.
   *
   * @schema KafkaSpecKafkaTemplate#externalBootstrapRoute
   */
  readonly externalBootstrapRoute?: KafkaSpecKafkaTemplateExternalBootstrapRoute;

  /**
   * Template for Kafka per-pod `Routes` used for access from outside of OpenShift.
   *
   * @schema KafkaSpecKafkaTemplate#perPodRoute
   */
  readonly perPodRoute?: KafkaSpecKafkaTemplatePerPodRoute;

  /**
   * Template for Kafka external bootstrap `Ingress`.
   *
   * @schema KafkaSpecKafkaTemplate#externalBootstrapIngress
   */
  readonly externalBootstrapIngress?: KafkaSpecKafkaTemplateExternalBootstrapIngress;

  /**
   * Template for Kafka per-pod `Ingress` used for access from outside of Kubernetes.
   *
   * @schema KafkaSpecKafkaTemplate#perPodIngress
   */
  readonly perPodIngress?: KafkaSpecKafkaTemplatePerPodIngress;

  /**
   * Template for all Kafka `PersistentVolumeClaims`.
   *
   * @schema KafkaSpecKafkaTemplate#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: KafkaSpecKafkaTemplatePersistentVolumeClaim;

  /**
   * Template for Kafka `PodDisruptionBudget`.
   *
   * @schema KafkaSpecKafkaTemplate#podDisruptionBudget
   */
  readonly podDisruptionBudget?: KafkaSpecKafkaTemplatePodDisruptionBudget;

  /**
   * Template for the Kafka broker container.
   *
   * @schema KafkaSpecKafkaTemplate#kafkaContainer
   */
  readonly kafkaContainer?: KafkaSpecKafkaTemplateKafkaContainer;

  /**
   * Template for the Kafka broker TLS sidecar container.
   *
   * @schema KafkaSpecKafkaTemplate#tlsSidecarContainer
   */
  readonly tlsSidecarContainer?: KafkaSpecKafkaTemplateTlsSidecarContainer;

  /**
   * Template for the Kafka init container.
   *
   * @schema KafkaSpecKafkaTemplate#initContainer
   */
  readonly initContainer?: KafkaSpecKafkaTemplateInitContainer;

}

/**
 * Storage configuration (disk). Cannot be updated.
 *
 * @schema KafkaSpecZookeeperStorage
 */
export interface KafkaSpecZookeeperStorage {
  /**
   * The storage class to use for dynamic volume allocation.
   *
   * @schema KafkaSpecZookeeperStorage#class
   */
  readonly class?: string;

  /**
   * Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
   *
   * @schema KafkaSpecZookeeperStorage#deleteClaim
   */
  readonly deleteClaim?: boolean;

  /**
   * Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
   *
   * @schema KafkaSpecZookeeperStorage#id
   */
  readonly id?: number;

  /**
   * Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
   *
   * @schema KafkaSpecZookeeperStorage#overrides
   */
  readonly overrides?: KafkaSpecZookeeperStorageOverrides[];

  /**
   * Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
   *
   * @schema KafkaSpecZookeeperStorage#selector
   */
  readonly selector?: any;

  /**
   * When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
   *
   * @schema KafkaSpecZookeeperStorage#size
   */
  readonly size?: string;

  /**
   * When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
   *
   * @schema KafkaSpecZookeeperStorage#sizeLimit
   */
  readonly sizeLimit?: string;

  /**
   * Storage type, must be either 'ephemeral' or 'persistent-claim'.
   *
   * @schema KafkaSpecZookeeperStorage#type
   */
  readonly type: KafkaSpecZookeeperStorageType;

}

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecZookeeperAffinity
 */
export interface KafkaSpecZookeeperAffinity {
  /**
   * @schema KafkaSpecZookeeperAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaSpecZookeeperAffinityNodeAffinity;

  /**
   * @schema KafkaSpecZookeeperAffinity#podAffinity
   */
  readonly podAffinity?: KafkaSpecZookeeperAffinityPodAffinity;

  /**
   * @schema KafkaSpecZookeeperAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaSpecZookeeperAffinityPodAntiAffinity;

}

/**
 * @schema KafkaSpecZookeeperTolerations
 */
export interface KafkaSpecZookeeperTolerations {
  /**
   * @schema KafkaSpecZookeeperTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaSpecZookeeperTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaSpecZookeeperTolerations#value
   */
  readonly value?: string;

}

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecZookeeperLivenessProbe
 */
export interface KafkaSpecZookeeperLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecZookeeperLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecZookeeperLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecZookeeperLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecZookeeperLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecZookeeperLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecZookeeperReadinessProbe
 */
export interface KafkaSpecZookeeperReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecZookeeperReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecZookeeperReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecZookeeperReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecZookeeperReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecZookeeperReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * JVM Options for pods.
 *
 * @schema KafkaSpecZookeeperJvmOptions
 */
export interface KafkaSpecZookeeperJvmOptions {
  /**
   * A map of -XX options to the JVM.
   *
   * @schema KafkaSpecZookeeperJvmOptions#-XX
   */
  readonly xx?: any;

  /**
   * -Xms option to to the JVM.
   *
   * @schema KafkaSpecZookeeperJvmOptions#-Xms
   */
  readonly xms?: string;

  /**
   * -Xmx option to to the JVM.
   *
   * @schema KafkaSpecZookeeperJvmOptions#-Xmx
   */
  readonly xmx?: string;

  /**
   * Specifies whether the Garbage Collection logging is enabled. The default is false.
   *
   * @schema KafkaSpecZookeeperJvmOptions#gcLoggingEnabled
   */
  readonly gcLoggingEnabled?: boolean;

  /**
   * A map of additional system properties which will be passed using the `-D` option to the JVM.
   *
   * @schema KafkaSpecZookeeperJvmOptions#javaSystemProperties
   */
  readonly javaSystemProperties?: KafkaSpecZookeeperJvmOptionsJavaSystemProperties[];

}

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecZookeeperResources
 */
export interface KafkaSpecZookeeperResources {
  /**
   * @schema KafkaSpecZookeeperResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecZookeeperResources#requests
   */
  readonly requests?: any;

}

/**
 * Logging configuration for ZooKeeper.
 *
 * @schema KafkaSpecZookeeperLogging
 */
export interface KafkaSpecZookeeperLogging {
  /**
   * A Map from logger name to logger level.
   *
   * @schema KafkaSpecZookeeperLogging#loggers
   */
  readonly loggers?: any;

  /**
   * The name of the `ConfigMap` from which to get the logging configuration.
   *
   * @schema KafkaSpecZookeeperLogging#name
   */
  readonly name?: string;

  /**
   * Logging type, must be either 'inline' or 'external'.
   *
   * @schema KafkaSpecZookeeperLogging#type
   */
  readonly type: KafkaSpecZookeeperLoggingType;

}

/**
 * Template for ZooKeeper cluster resources. The template allows users to specify how are the `StatefulSet`, `Pods` and `Services` generated.
 *
 * @schema KafkaSpecZookeeperTemplate
 */
export interface KafkaSpecZookeeperTemplate {
  /**
   * Template for ZooKeeper `StatefulSet`.
   *
   * @schema KafkaSpecZookeeperTemplate#statefulset
   */
  readonly statefulset?: KafkaSpecZookeeperTemplateStatefulset;

  /**
   * Template for ZooKeeper `Pods`.
   *
   * @schema KafkaSpecZookeeperTemplate#pod
   */
  readonly pod?: KafkaSpecZookeeperTemplatePod;

  /**
   * Template for ZooKeeper client `Service`.
   *
   * @schema KafkaSpecZookeeperTemplate#clientService
   */
  readonly clientService?: KafkaSpecZookeeperTemplateClientService;

  /**
   * Template for ZooKeeper nodes `Service`.
   *
   * @schema KafkaSpecZookeeperTemplate#nodesService
   */
  readonly nodesService?: KafkaSpecZookeeperTemplateNodesService;

  /**
   * Template for all ZooKeeper `PersistentVolumeClaims`.
   *
   * @schema KafkaSpecZookeeperTemplate#persistentVolumeClaim
   */
  readonly persistentVolumeClaim?: KafkaSpecZookeeperTemplatePersistentVolumeClaim;

  /**
   * Template for ZooKeeper `PodDisruptionBudget`.
   *
   * @schema KafkaSpecZookeeperTemplate#podDisruptionBudget
   */
  readonly podDisruptionBudget?: KafkaSpecZookeeperTemplatePodDisruptionBudget;

  /**
   * Template for the ZooKeeper container.
   *
   * @schema KafkaSpecZookeeperTemplate#zookeeperContainer
   */
  readonly zookeeperContainer?: KafkaSpecZookeeperTemplateZookeeperContainer;

  /**
   * Template for the Zookeeper server TLS sidecar container. The TLS sidecar is not used anymore and this option will be ignored.
   *
   * @schema KafkaSpecZookeeperTemplate#tlsSidecarContainer
   */
  readonly tlsSidecarContainer?: KafkaSpecZookeeperTemplateTlsSidecarContainer;

}

/**
 * TLS sidecar configuration. The TLS sidecar is not used anymore and this option will be ignored.
 *
 * @schema KafkaSpecZookeeperTlsSidecar
 */
export interface KafkaSpecZookeeperTlsSidecar {
  /**
   * The docker image for the container.
   *
   * @schema KafkaSpecZookeeperTlsSidecar#image
   */
  readonly image?: string;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaSpecZookeeperTlsSidecar#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecZookeeperTlsSidecarLivenessProbe;

  /**
   * The log level for the TLS sidecar. Default value is `notice`.
   *
   * @schema KafkaSpecZookeeperTlsSidecar#logLevel
   */
  readonly logLevel?: KafkaSpecZookeeperTlsSidecarLogLevel;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaSpecZookeeperTlsSidecar#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecZookeeperTlsSidecarReadinessProbe;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecZookeeperTlsSidecar#resources
   */
  readonly resources?: KafkaSpecZookeeperTlsSidecarResources;

}

/**
 * Pod affinity rules.
 *
 * @schema KafkaSpecTopicOperatorAffinity
 */
export interface KafkaSpecTopicOperatorAffinity {
  /**
   * @schema KafkaSpecTopicOperatorAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaSpecTopicOperatorAffinityNodeAffinity;

  /**
   * @schema KafkaSpecTopicOperatorAffinity#podAffinity
   */
  readonly podAffinity?: KafkaSpecTopicOperatorAffinityPodAffinity;

  /**
   * @schema KafkaSpecTopicOperatorAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaSpecTopicOperatorAffinityPodAntiAffinity;

}

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecTopicOperatorResources
 */
export interface KafkaSpecTopicOperatorResources {
  /**
   * @schema KafkaSpecTopicOperatorResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecTopicOperatorResources#requests
   */
  readonly requests?: any;

}

/**
 * TLS sidecar configuration.
 *
 * @schema KafkaSpecTopicOperatorTlsSidecar
 */
export interface KafkaSpecTopicOperatorTlsSidecar {
  /**
   * The docker image for the container.
   *
   * @schema KafkaSpecTopicOperatorTlsSidecar#image
   */
  readonly image?: string;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaSpecTopicOperatorTlsSidecar#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecTopicOperatorTlsSidecarLivenessProbe;

  /**
   * The log level for the TLS sidecar. Default value is `notice`.
   *
   * @schema KafkaSpecTopicOperatorTlsSidecar#logLevel
   */
  readonly logLevel?: KafkaSpecTopicOperatorTlsSidecarLogLevel;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaSpecTopicOperatorTlsSidecar#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecTopicOperatorTlsSidecarReadinessProbe;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecTopicOperatorTlsSidecar#resources
   */
  readonly resources?: KafkaSpecTopicOperatorTlsSidecarResources;

}

/**
 * Logging configuration.
 *
 * @schema KafkaSpecTopicOperatorLogging
 */
export interface KafkaSpecTopicOperatorLogging {
  /**
   * A Map from logger name to logger level.
   *
   * @schema KafkaSpecTopicOperatorLogging#loggers
   */
  readonly loggers?: any;

  /**
   * The name of the `ConfigMap` from which to get the logging configuration.
   *
   * @schema KafkaSpecTopicOperatorLogging#name
   */
  readonly name?: string;

  /**
   * Logging type, must be either 'inline' or 'external'.
   *
   * @schema KafkaSpecTopicOperatorLogging#type
   */
  readonly type: KafkaSpecTopicOperatorLoggingType;

}

/**
 * JVM Options for pods.
 *
 * @schema KafkaSpecTopicOperatorJvmOptions
 */
export interface KafkaSpecTopicOperatorJvmOptions {
  /**
   * A map of -XX options to the JVM.
   *
   * @schema KafkaSpecTopicOperatorJvmOptions#-XX
   */
  readonly xx?: any;

  /**
   * -Xms option to to the JVM.
   *
   * @schema KafkaSpecTopicOperatorJvmOptions#-Xms
   */
  readonly xms?: string;

  /**
   * -Xmx option to to the JVM.
   *
   * @schema KafkaSpecTopicOperatorJvmOptions#-Xmx
   */
  readonly xmx?: string;

  /**
   * Specifies whether the Garbage Collection logging is enabled. The default is false.
   *
   * @schema KafkaSpecTopicOperatorJvmOptions#gcLoggingEnabled
   */
  readonly gcLoggingEnabled?: boolean;

  /**
   * A map of additional system properties which will be passed using the `-D` option to the JVM.
   *
   * @schema KafkaSpecTopicOperatorJvmOptions#javaSystemProperties
   */
  readonly javaSystemProperties?: KafkaSpecTopicOperatorJvmOptionsJavaSystemProperties[];

}

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecTopicOperatorLivenessProbe
 */
export interface KafkaSpecTopicOperatorLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecTopicOperatorLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecTopicOperatorLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecTopicOperatorLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecTopicOperatorLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecTopicOperatorLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecTopicOperatorReadinessProbe
 */
export interface KafkaSpecTopicOperatorReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecTopicOperatorReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecTopicOperatorReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecTopicOperatorReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecTopicOperatorReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecTopicOperatorReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Configuration of the Topic Operator.
 *
 * @schema KafkaSpecEntityOperatorTopicOperator
 */
export interface KafkaSpecEntityOperatorTopicOperator {
  /**
   * The namespace the Topic Operator should watch.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#watchedNamespace
   */
  readonly watchedNamespace?: string;

  /**
   * The image to use for the Topic Operator.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#image
   */
  readonly image?: string;

  /**
   * Interval between periodic reconciliations.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#reconciliationIntervalSeconds
   */
  readonly reconciliationIntervalSeconds?: number;

  /**
   * Timeout for the ZooKeeper session.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#zookeeperSessionTimeoutSeconds
   */
  readonly zookeeperSessionTimeoutSeconds?: number;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecEntityOperatorTopicOperatorLivenessProbe;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecEntityOperatorTopicOperatorReadinessProbe;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#resources
   */
  readonly resources?: KafkaSpecEntityOperatorTopicOperatorResources;

  /**
   * The number of attempts at getting topic metadata.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#topicMetadataMaxAttempts
   */
  readonly topicMetadataMaxAttempts?: number;

  /**
   * Logging configuration.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#logging
   */
  readonly logging?: KafkaSpecEntityOperatorTopicOperatorLogging;

  /**
   * JVM Options for pods.
   *
   * @schema KafkaSpecEntityOperatorTopicOperator#jvmOptions
   */
  readonly jvmOptions?: KafkaSpecEntityOperatorTopicOperatorJvmOptions;

}

/**
 * Configuration of the User Operator.
 *
 * @schema KafkaSpecEntityOperatorUserOperator
 */
export interface KafkaSpecEntityOperatorUserOperator {
  /**
   * The namespace the User Operator should watch.
   *
   * @schema KafkaSpecEntityOperatorUserOperator#watchedNamespace
   */
  readonly watchedNamespace?: string;

  /**
   * The image to use for the User Operator.
   *
   * @schema KafkaSpecEntityOperatorUserOperator#image
   */
  readonly image?: string;

  /**
   * Interval between periodic reconciliations.
   *
   * @schema KafkaSpecEntityOperatorUserOperator#reconciliationIntervalSeconds
   */
  readonly reconciliationIntervalSeconds?: number;

  /**
   * Timeout for the ZooKeeper session.
   *
   * @schema KafkaSpecEntityOperatorUserOperator#zookeeperSessionTimeoutSeconds
   */
  readonly zookeeperSessionTimeoutSeconds?: number;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaSpecEntityOperatorUserOperator#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecEntityOperatorUserOperatorLivenessProbe;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaSpecEntityOperatorUserOperator#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecEntityOperatorUserOperatorReadinessProbe;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecEntityOperatorUserOperator#resources
   */
  readonly resources?: KafkaSpecEntityOperatorUserOperatorResources;

  /**
   * Logging configuration.
   *
   * @schema KafkaSpecEntityOperatorUserOperator#logging
   */
  readonly logging?: KafkaSpecEntityOperatorUserOperatorLogging;

  /**
   * JVM Options for pods.
   *
   * @schema KafkaSpecEntityOperatorUserOperator#jvmOptions
   */
  readonly jvmOptions?: KafkaSpecEntityOperatorUserOperatorJvmOptions;

}

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecEntityOperatorAffinity
 */
export interface KafkaSpecEntityOperatorAffinity {
  /**
   * @schema KafkaSpecEntityOperatorAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaSpecEntityOperatorAffinityNodeAffinity;

  /**
   * @schema KafkaSpecEntityOperatorAffinity#podAffinity
   */
  readonly podAffinity?: KafkaSpecEntityOperatorAffinityPodAffinity;

  /**
   * @schema KafkaSpecEntityOperatorAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaSpecEntityOperatorAffinityPodAntiAffinity;

}

/**
 * @schema KafkaSpecEntityOperatorTolerations
 */
export interface KafkaSpecEntityOperatorTolerations {
  /**
   * @schema KafkaSpecEntityOperatorTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaSpecEntityOperatorTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaSpecEntityOperatorTolerations#value
   */
  readonly value?: string;

}

/**
 * TLS sidecar configuration.
 *
 * @schema KafkaSpecEntityOperatorTlsSidecar
 */
export interface KafkaSpecEntityOperatorTlsSidecar {
  /**
   * The docker image for the container.
   *
   * @schema KafkaSpecEntityOperatorTlsSidecar#image
   */
  readonly image?: string;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaSpecEntityOperatorTlsSidecar#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecEntityOperatorTlsSidecarLivenessProbe;

  /**
   * The log level for the TLS sidecar. Default value is `notice`.
   *
   * @schema KafkaSpecEntityOperatorTlsSidecar#logLevel
   */
  readonly logLevel?: KafkaSpecEntityOperatorTlsSidecarLogLevel;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaSpecEntityOperatorTlsSidecar#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecEntityOperatorTlsSidecarReadinessProbe;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecEntityOperatorTlsSidecar#resources
   */
  readonly resources?: KafkaSpecEntityOperatorTlsSidecarResources;

}

/**
 * Template for Entity Operator resources. The template allows users to specify how is the `Deployment` and `Pods` generated.
 *
 * @schema KafkaSpecEntityOperatorTemplate
 */
export interface KafkaSpecEntityOperatorTemplate {
  /**
   * Template for Entity Operator `Deployment`.
   *
   * @schema KafkaSpecEntityOperatorTemplate#deployment
   */
  readonly deployment?: KafkaSpecEntityOperatorTemplateDeployment;

  /**
   * Template for Entity Operator `Pods`.
   *
   * @schema KafkaSpecEntityOperatorTemplate#pod
   */
  readonly pod?: KafkaSpecEntityOperatorTemplatePod;

  /**
   * Template for the Entity Operator TLS sidecar container.
   *
   * @schema KafkaSpecEntityOperatorTemplate#tlsSidecarContainer
   */
  readonly tlsSidecarContainer?: KafkaSpecEntityOperatorTemplateTlsSidecarContainer;

  /**
   * Template for the Entity Topic Operator container.
   *
   * @schema KafkaSpecEntityOperatorTemplate#topicOperatorContainer
   */
  readonly topicOperatorContainer?: KafkaSpecEntityOperatorTemplateTopicOperatorContainer;

  /**
   * Template for the Entity User Operator container.
   *
   * @schema KafkaSpecEntityOperatorTemplate#userOperatorContainer
   */
  readonly userOperatorContainer?: KafkaSpecEntityOperatorTemplateUserOperatorContainer;

}

/**
 * How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.
 *
 * @schema KafkaSpecClusterCaCertificateExpirationPolicy
 */
export enum KafkaSpecClusterCaCertificateExpirationPolicy {
  /** renew-certificate */
  RENEW_CERTIFICATE = "renew-certificate",
  /** replace-key */
  REPLACE_KEY = "replace-key",
}

/**
 * How should CA certificate expiration be handled when `generateCertificateAuthority=true`. The default is for a new CA certificate to be generated reusing the existing private key.
 *
 * @schema KafkaSpecClientsCaCertificateExpirationPolicy
 */
export enum KafkaSpecClientsCaCertificateExpirationPolicy {
  /** renew-certificate */
  RENEW_CERTIFICATE = "renew-certificate",
  /** replace-key */
  REPLACE_KEY = "replace-key",
}

/**
 * TLS sidecar configuration.
 *
 * @schema KafkaSpecCruiseControlTlsSidecar
 */
export interface KafkaSpecCruiseControlTlsSidecar {
  /**
   * The docker image for the container.
   *
   * @schema KafkaSpecCruiseControlTlsSidecar#image
   */
  readonly image?: string;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaSpecCruiseControlTlsSidecar#livenessProbe
   */
  readonly livenessProbe?: KafkaSpecCruiseControlTlsSidecarLivenessProbe;

  /**
   * The log level for the TLS sidecar. Default value is `notice`.
   *
   * @schema KafkaSpecCruiseControlTlsSidecar#logLevel
   */
  readonly logLevel?: KafkaSpecCruiseControlTlsSidecarLogLevel;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaSpecCruiseControlTlsSidecar#readinessProbe
   */
  readonly readinessProbe?: KafkaSpecCruiseControlTlsSidecarReadinessProbe;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaSpecCruiseControlTlsSidecar#resources
   */
  readonly resources?: KafkaSpecCruiseControlTlsSidecarResources;

}

/**
 * CPU and memory resources to reserve for the Cruise Control container.
 *
 * @schema KafkaSpecCruiseControlResources
 */
export interface KafkaSpecCruiseControlResources {
  /**
   * @schema KafkaSpecCruiseControlResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecCruiseControlResources#requests
   */
  readonly requests?: any;

}

/**
 * Pod liveness checking for the Cruise Control container.
 *
 * @schema KafkaSpecCruiseControlLivenessProbe
 */
export interface KafkaSpecCruiseControlLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecCruiseControlLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecCruiseControlLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecCruiseControlLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecCruiseControlLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecCruiseControlLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Pod readiness checking for the Cruise Control container.
 *
 * @schema KafkaSpecCruiseControlReadinessProbe
 */
export interface KafkaSpecCruiseControlReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecCruiseControlReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecCruiseControlReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecCruiseControlReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecCruiseControlReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecCruiseControlReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * JVM Options for the Cruise Control container.
 *
 * @schema KafkaSpecCruiseControlJvmOptions
 */
export interface KafkaSpecCruiseControlJvmOptions {
  /**
   * A map of -XX options to the JVM.
   *
   * @schema KafkaSpecCruiseControlJvmOptions#-XX
   */
  readonly xx?: any;

  /**
   * -Xms option to to the JVM.
   *
   * @schema KafkaSpecCruiseControlJvmOptions#-Xms
   */
  readonly xms?: string;

  /**
   * -Xmx option to to the JVM.
   *
   * @schema KafkaSpecCruiseControlJvmOptions#-Xmx
   */
  readonly xmx?: string;

  /**
   * Specifies whether the Garbage Collection logging is enabled. The default is false.
   *
   * @schema KafkaSpecCruiseControlJvmOptions#gcLoggingEnabled
   */
  readonly gcLoggingEnabled?: boolean;

  /**
   * A map of additional system properties which will be passed using the `-D` option to the JVM.
   *
   * @schema KafkaSpecCruiseControlJvmOptions#javaSystemProperties
   */
  readonly javaSystemProperties?: KafkaSpecCruiseControlJvmOptionsJavaSystemProperties[];

}

/**
 * Logging configuration (log4j1) for Cruise Control.
 *
 * @schema KafkaSpecCruiseControlLogging
 */
export interface KafkaSpecCruiseControlLogging {
  /**
   * A Map from logger name to logger level.
   *
   * @schema KafkaSpecCruiseControlLogging#loggers
   */
  readonly loggers?: any;

  /**
   * The name of the `ConfigMap` from which to get the logging configuration.
   *
   * @schema KafkaSpecCruiseControlLogging#name
   */
  readonly name?: string;

  /**
   * Logging type, must be either 'inline' or 'external'.
   *
   * @schema KafkaSpecCruiseControlLogging#type
   */
  readonly type: KafkaSpecCruiseControlLoggingType;

}

/**
 * Template to specify how Cruise Control resources, `Deployments` and `Pods`, are generated.
 *
 * @schema KafkaSpecCruiseControlTemplate
 */
export interface KafkaSpecCruiseControlTemplate {
  /**
   * Template for Cruise Control `Deployment`.
   *
   * @schema KafkaSpecCruiseControlTemplate#deployment
   */
  readonly deployment?: KafkaSpecCruiseControlTemplateDeployment;

  /**
   * Template for Cruise Control `Pods`.
   *
   * @schema KafkaSpecCruiseControlTemplate#pod
   */
  readonly pod?: KafkaSpecCruiseControlTemplatePod;

  /**
   * Template for Cruise Control API `Service`.
   *
   * @schema KafkaSpecCruiseControlTemplate#apiService
   */
  readonly apiService?: KafkaSpecCruiseControlTemplateApiService;

  /**
   * Template for Cruise Control `PodDisruptionBudget`.
   *
   * @schema KafkaSpecCruiseControlTemplate#podDisruptionBudget
   */
  readonly podDisruptionBudget?: KafkaSpecCruiseControlTemplatePodDisruptionBudget;

  /**
   * Template for the Cruise Control container.
   *
   * @schema KafkaSpecCruiseControlTemplate#cruiseControlContainer
   */
  readonly cruiseControlContainer?: KafkaSpecCruiseControlTemplateCruiseControlContainer;

  /**
   * Template for the Cruise Control TLS sidecar container.
   *
   * @schema KafkaSpecCruiseControlTemplate#tlsSidecarContainer
   */
  readonly tlsSidecarContainer?: KafkaSpecCruiseControlTemplateTlsSidecarContainer;

}

/**
 * The Cruise Control `brokerCapacity` configuration.
 *
 * @schema KafkaSpecCruiseControlBrokerCapacity
 */
export interface KafkaSpecCruiseControlBrokerCapacity {
  /**
   * Broker capacity for disk in bytes, for example, 100Gi.
   *
   * @schema KafkaSpecCruiseControlBrokerCapacity#disk
   */
  readonly disk?: string;

  /**
   * Broker capacity for CPU resource utilization as a percentage (0 - 100).
   *
   * @schema KafkaSpecCruiseControlBrokerCapacity#cpuUtilization
   */
  readonly cpuUtilization?: number;

  /**
   * Broker capacity for inbound network throughput in bytes per second, for example, 10000KB/s.
   *
   * @schema KafkaSpecCruiseControlBrokerCapacity#inboundNetwork
   */
  readonly inboundNetwork?: string;

  /**
   * Broker capacity for outbound network throughput in bytes per second, for example 10000KB/s.
   *
   * @schema KafkaSpecCruiseControlBrokerCapacity#outboundNetwork
   */
  readonly outboundNetwork?: string;

}

/**
 * @schema KafkaSpecJmxTransOutputDefinitions
 */
export interface KafkaSpecJmxTransOutputDefinitions {
  /**
   * Template for setting the format of the data that will be pushed.For more information see https://github.com/jmxtrans/jmxtrans/wiki/OutputWriters[JmxTrans OutputWriters].
   *
   * @schema KafkaSpecJmxTransOutputDefinitions#outputType
   */
  readonly outputType: string;

  /**
   * The DNS/hostname of the remote host that the data is pushed to.
   *
   * @schema KafkaSpecJmxTransOutputDefinitions#host
   */
  readonly host?: string;

  /**
   * The port of the remote host that the data is pushed to.
   *
   * @schema KafkaSpecJmxTransOutputDefinitions#port
   */
  readonly port?: number;

  /**
   * How many seconds the JmxTrans waits before pushing a new set of data out.
   *
   * @schema KafkaSpecJmxTransOutputDefinitions#flushDelayInSeconds
   */
  readonly flushDelayInSeconds?: number;

  /**
   * Template for filtering data to be included in response to a wildcard query. For more information see https://github.com/jmxtrans/jmxtrans/wiki/Queries[JmxTrans queries].
   *
   * @schema KafkaSpecJmxTransOutputDefinitions#typeNames
   */
  readonly typeNames?: string[];

  /**
   * Template for setting the name of the output definition. This is used to identify where to send the results of queries should be sent.
   *
   * @schema KafkaSpecJmxTransOutputDefinitions#name
   */
  readonly name: string;

}

/**
 * @schema KafkaSpecJmxTransKafkaQueries
 */
export interface KafkaSpecJmxTransKafkaQueries {
  /**
   * If using wildcards instead of a specific MBean then the data is gathered from multiple MBeans. Otherwise if specifying an MBean then data is gathered from that specified MBean.
   *
   * @schema KafkaSpecJmxTransKafkaQueries#targetMBean
   */
  readonly targetMBean: string;

  /**
   * Determine which attributes of the targeted MBean should be included.
   *
   * @schema KafkaSpecJmxTransKafkaQueries#attributes
   */
  readonly attributes: string[];

  /**
   * List of the names of output definitions specified in the spec.kafka.jmxTrans.outputDefinitions that have defined where JMX metrics are pushed to, and in which data format.
   *
   * @schema KafkaSpecJmxTransKafkaQueries#outputs
   */
  readonly outputs: string[];

}

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecJmxTransResources
 */
export interface KafkaSpecJmxTransResources {
  /**
   * @schema KafkaSpecJmxTransResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecJmxTransResources#requests
   */
  readonly requests?: any;

}

/**
 * Template for JmxTrans resources.
 *
 * @schema KafkaSpecJmxTransTemplate
 */
export interface KafkaSpecJmxTransTemplate {
  /**
   * Template for JmxTrans `Deployment`.
   *
   * @schema KafkaSpecJmxTransTemplate#deployment
   */
  readonly deployment?: KafkaSpecJmxTransTemplateDeployment;

  /**
   * Template for JmxTrans `Pods`.
   *
   * @schema KafkaSpecJmxTransTemplate#pod
   */
  readonly pod?: KafkaSpecJmxTransTemplatePod;

  /**
   * Template for JmxTrans container.
   *
   * @schema KafkaSpecJmxTransTemplate#container
   */
  readonly container?: KafkaSpecJmxTransTemplateContainer;

}

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecKafkaExporterResources
 */
export interface KafkaSpecKafkaExporterResources {
  /**
   * @schema KafkaSpecKafkaExporterResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecKafkaExporterResources#requests
   */
  readonly requests?: any;

}

/**
 * Customization of deployment templates and pods.
 *
 * @schema KafkaSpecKafkaExporterTemplate
 */
export interface KafkaSpecKafkaExporterTemplate {
  /**
   * Template for Kafka Exporter `Deployment`.
   *
   * @schema KafkaSpecKafkaExporterTemplate#deployment
   */
  readonly deployment?: KafkaSpecKafkaExporterTemplateDeployment;

  /**
   * Template for Kafka Exporter `Pods`.
   *
   * @schema KafkaSpecKafkaExporterTemplate#pod
   */
  readonly pod?: KafkaSpecKafkaExporterTemplatePod;

  /**
   * Template for Kafka Exporter `Service`.
   *
   * @schema KafkaSpecKafkaExporterTemplate#service
   */
  readonly service?: KafkaSpecKafkaExporterTemplateService;

  /**
   * Template for the Kafka Exporter container.
   *
   * @schema KafkaSpecKafkaExporterTemplate#container
   */
  readonly container?: KafkaSpecKafkaExporterTemplateContainer;

}

/**
 * Pod liveness check.
 *
 * @schema KafkaSpecKafkaExporterLivenessProbe
 */
export interface KafkaSpecKafkaExporterLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecKafkaExporterLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecKafkaExporterLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecKafkaExporterLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecKafkaExporterLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecKafkaExporterLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Pod readiness check.
 *
 * @schema KafkaSpecKafkaExporterReadinessProbe
 */
export interface KafkaSpecKafkaExporterReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecKafkaExporterReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecKafkaExporterReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecKafkaExporterReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecKafkaExporterReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecKafkaExporterReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * @schema KafkaSpecKafkaStorageOverrides
 */
export interface KafkaSpecKafkaStorageOverrides {
  /**
   * The storage class to use for dynamic volume allocation for this broker.
   *
   * @schema KafkaSpecKafkaStorageOverrides#class
   */
  readonly class?: string;

  /**
   * Id of the kafka broker (broker identifier).
   *
   * @schema KafkaSpecKafkaStorageOverrides#broker
   */
  readonly broker?: number;

}

/**
 * Storage type, must be either 'ephemeral', 'persistent-claim', or 'jbod'.
 *
 * @schema KafkaSpecKafkaStorageType
 */
export enum KafkaSpecKafkaStorageType {
  /** ephemeral */
  EPHEMERAL = "ephemeral",
  /** persistent-claim */
  PERSISTENT_CLAIM = "persistent-claim",
  /** jbod */
  JBOD = "jbod",
}

/**
 * @schema KafkaSpecKafkaStorageVolumes
 */
export interface KafkaSpecKafkaStorageVolumes {
  /**
   * The storage class to use for dynamic volume allocation.
   *
   * @schema KafkaSpecKafkaStorageVolumes#class
   */
  readonly class?: string;

  /**
   * Specifies if the persistent volume claim has to be deleted when the cluster is un-deployed.
   *
   * @schema KafkaSpecKafkaStorageVolumes#deleteClaim
   */
  readonly deleteClaim?: boolean;

  /**
   * Storage identification number. It is mandatory only for storage volumes defined in a storage of type 'jbod'.
   *
   * @schema KafkaSpecKafkaStorageVolumes#id
   */
  readonly id?: number;

  /**
   * Overrides for individual brokers. The `overrides` field allows to specify a different configuration for different brokers.
   *
   * @schema KafkaSpecKafkaStorageVolumes#overrides
   */
  readonly overrides?: KafkaSpecKafkaStorageVolumesOverrides[];

  /**
   * Specifies a specific persistent volume to use. It contains key:value pairs representing labels for selecting such a volume.
   *
   * @schema KafkaSpecKafkaStorageVolumes#selector
   */
  readonly selector?: any;

  /**
   * When type=persistent-claim, defines the size of the persistent volume claim (i.e 1Gi). Mandatory when type=persistent-claim.
   *
   * @schema KafkaSpecKafkaStorageVolumes#size
   */
  readonly size?: string;

  /**
   * When type=ephemeral, defines the total amount of local storage required for this EmptyDir volume (for example 1Gi).
   *
   * @schema KafkaSpecKafkaStorageVolumes#sizeLimit
   */
  readonly sizeLimit?: string;

  /**
   * Storage type, must be either 'ephemeral' or 'persistent-claim'.
   *
   * @schema KafkaSpecKafkaStorageVolumes#type
   */
  readonly type: KafkaSpecKafkaStorageVolumesType;

}

/**
 * @schema KafkaSpecKafkaAuthorizationTlsTrustedCertificates
 */
export interface KafkaSpecKafkaAuthorizationTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaSpecKafkaAuthorizationTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaSpecKafkaAuthorizationTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * Authorization type. Currently, the supported types are `simple`, `keycloak`, and `opa`. `simple` authorization type uses Kafka's `kafka.security.authorizer.AclAuthorizer` class for authorization. `keycloak` authorization type uses Keycloak Authorization Services for authorization. `opa` authorization type uses Open Policy Agent based authorization.
 *
 * @schema KafkaSpecKafkaAuthorizationType
 */
export enum KafkaSpecKafkaAuthorizationType {
  /** simple */
  SIMPLE = "simple",
  /** opa */
  OPA = "opa",
  /** keycloak */
  KEYCLOAK = "keycloak",
}

/**
 * @schema KafkaSpecKafkaAffinityNodeAffinity
 */
export interface KafkaSpecKafkaAffinityNodeAffinity {
  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaSpecKafkaAffinityPodAffinity
 */
export interface KafkaSpecKafkaAffinityPodAffinity {
  /**
   * @schema KafkaSpecKafkaAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecKafkaAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecKafkaAffinityPodAntiAffinity
 */
export interface KafkaSpecKafkaAffinityPodAntiAffinity {
  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecKafkaJvmOptionsJavaSystemProperties
 */
export interface KafkaSpecKafkaJvmOptionsJavaSystemProperties {
  /**
   * The system property name.
   *
   * @schema KafkaSpecKafkaJvmOptionsJavaSystemProperties#name
   */
  readonly name?: string;

  /**
   * The system property value.
   *
   * @schema KafkaSpecKafkaJvmOptionsJavaSystemProperties#value
   */
  readonly value?: string;

}

/**
 * Authentication configuration for connecting to the Kafka JMX port.
 *
 * @schema KafkaSpecKafkaJmxOptionsAuthentication
 */
export interface KafkaSpecKafkaJmxOptionsAuthentication {
  /**
   * Authentication type. Currently the only supported types are `password`.`password` type creates a username and protected port with no TLS.
   *
   * @schema KafkaSpecKafkaJmxOptionsAuthentication#type
   */
  readonly type: KafkaSpecKafkaJmxOptionsAuthenticationType;

}

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaSpecKafkaLoggingType
 */
export enum KafkaSpecKafkaLoggingType {
  /** inline */
  INLINE = "inline",
  /** external */
  EXTERNAL = "external",
}

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecKafkaTlsSidecarLivenessProbe
 */
export interface KafkaSpecKafkaTlsSidecarLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecKafkaTlsSidecarLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecKafkaTlsSidecarLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecKafkaTlsSidecarLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecKafkaTlsSidecarLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecKafkaTlsSidecarLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * The log level for the TLS sidecar. Default value is `notice`.
 *
 * @schema KafkaSpecKafkaTlsSidecarLogLevel
 */
export enum KafkaSpecKafkaTlsSidecarLogLevel {
  /** emerg */
  EMERG = "emerg",
  /** alert */
  ALERT = "alert",
  /** crit */
  CRIT = "crit",
  /** err */
  ERR = "err",
  /** warning */
  WARNING = "warning",
  /** notice */
  NOTICE = "notice",
  /** info */
  INFO = "info",
  /** debug */
  DEBUG = "debug",
}

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecKafkaTlsSidecarReadinessProbe
 */
export interface KafkaSpecKafkaTlsSidecarReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecKafkaTlsSidecarReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecKafkaTlsSidecarReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecKafkaTlsSidecarReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecKafkaTlsSidecarReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecKafkaTlsSidecarReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecKafkaTlsSidecarResources
 */
export interface KafkaSpecKafkaTlsSidecarResources {
  /**
   * @schema KafkaSpecKafkaTlsSidecarResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecKafkaTlsSidecarResources#requests
   */
  readonly requests?: any;

}

/**
 * Template for Kafka `StatefulSet`.
 *
 * @schema KafkaSpecKafkaTemplateStatefulset
 */
export interface KafkaSpecKafkaTemplateStatefulset {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplateStatefulset#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplateStatefulsetMetadata;

  /**
   * PodManagementPolicy which will be used for this StatefulSet. Valid values are `Parallel` and `OrderedReady`. Defaults to `Parallel`.
   *
   * @default Parallel`.
   * @schema KafkaSpecKafkaTemplateStatefulset#podManagementPolicy
   */
  readonly podManagementPolicy?: KafkaSpecKafkaTemplateStatefulsetPodManagementPolicy;

}

/**
 * Template for Kafka `Pods`.
 *
 * @schema KafkaSpecKafkaTemplatePod
 */
export interface KafkaSpecKafkaTemplatePod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplatePod#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplatePodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaSpecKafkaTemplatePod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaSpecKafkaTemplatePodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaSpecKafkaTemplatePod#securityContext
   */
  readonly securityContext?: KafkaSpecKafkaTemplatePodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaSpecKafkaTemplatePod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaSpecKafkaTemplatePod#affinity
   */
  readonly affinity?: KafkaSpecKafkaTemplatePodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaSpecKafkaTemplatePod#tolerations
   */
  readonly tolerations?: KafkaSpecKafkaTemplatePodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaSpecKafkaTemplatePod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaSpecKafkaTemplatePod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
   *
   * @schema KafkaSpecKafkaTemplatePod#hostAliases
   */
  readonly hostAliases?: KafkaSpecKafkaTemplatePodHostAliases[];

}

/**
 * Template for Kafka bootstrap `Service`.
 *
 * @schema KafkaSpecKafkaTemplateBootstrapService
 */
export interface KafkaSpecKafkaTemplateBootstrapService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplateBootstrapService#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplateBootstrapServiceMetadata;

}

/**
 * Template for Kafka broker `Service`.
 *
 * @schema KafkaSpecKafkaTemplateBrokersService
 */
export interface KafkaSpecKafkaTemplateBrokersService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplateBrokersService#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplateBrokersServiceMetadata;

}

/**
 * Template for Kafka external bootstrap `Service`.
 *
 * @schema KafkaSpecKafkaTemplateExternalBootstrapService
 */
export interface KafkaSpecKafkaTemplateExternalBootstrapService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapService#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata;

  /**
   * Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. `Cluster` may cause a second hop to another node and obscures the client source IP. `Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). If unspecified, Kubernetes will use `Cluster` as the default.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapService#externalTrafficPolicy
   */
  readonly externalTrafficPolicy?: KafkaSpecKafkaTemplateExternalBootstrapServiceExternalTrafficPolicy;

  /**
   * A list of CIDR ranges (for example `10.0.0.0/8` or `130.211.204.1/32`) from which clients can connect to load balancer type listeners. If supported by the platform, traffic through the loadbalancer is restricted to the specified CIDR ranges. This field is applicable only for loadbalancer type services and is ignored if the cloud provider does not support the feature. For more information, see https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/. 
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapService#loadBalancerSourceRanges
   */
  readonly loadBalancerSourceRanges?: string[];

}

/**
 * Template for Kafka per-pod `Services` used for access from outside of Kubernetes.
 *
 * @schema KafkaSpecKafkaTemplatePerPodService
 */
export interface KafkaSpecKafkaTemplatePerPodService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplatePerPodService#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplatePerPodServiceMetadata;

  /**
   * Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. `Cluster` may cause a second hop to another node and obscures the client source IP. `Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). If unspecified, Kubernetes will use `Cluster` as the default.
   *
   * @schema KafkaSpecKafkaTemplatePerPodService#externalTrafficPolicy
   */
  readonly externalTrafficPolicy?: KafkaSpecKafkaTemplatePerPodServiceExternalTrafficPolicy;

  /**
   * A list of CIDR ranges (for example `10.0.0.0/8` or `130.211.204.1/32`) from which clients can connect to load balancer type listeners. If supported by the platform, traffic through the loadbalancer is restricted to the specified CIDR ranges. This field is applicable only for loadbalancer type services and is ignored if the cloud provider does not support the feature. For more information, see https://v1-17.docs.kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/. 
   *
   * @schema KafkaSpecKafkaTemplatePerPodService#loadBalancerSourceRanges
   */
  readonly loadBalancerSourceRanges?: string[];

}

/**
 * Template for Kafka external bootstrap `Route`.
 *
 * @schema KafkaSpecKafkaTemplateExternalBootstrapRoute
 */
export interface KafkaSpecKafkaTemplateExternalBootstrapRoute {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapRoute#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata;

}

/**
 * Template for Kafka per-pod `Routes` used for access from outside of OpenShift.
 *
 * @schema KafkaSpecKafkaTemplatePerPodRoute
 */
export interface KafkaSpecKafkaTemplatePerPodRoute {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplatePerPodRoute#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplatePerPodRouteMetadata;

}

/**
 * Template for Kafka external bootstrap `Ingress`.
 *
 * @schema KafkaSpecKafkaTemplateExternalBootstrapIngress
 */
export interface KafkaSpecKafkaTemplateExternalBootstrapIngress {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapIngress#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata;

}

/**
 * Template for Kafka per-pod `Ingress` used for access from outside of Kubernetes.
 *
 * @schema KafkaSpecKafkaTemplatePerPodIngress
 */
export interface KafkaSpecKafkaTemplatePerPodIngress {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplatePerPodIngress#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplatePerPodIngressMetadata;

}

/**
 * Template for all Kafka `PersistentVolumeClaims`.
 *
 * @schema KafkaSpecKafkaTemplatePersistentVolumeClaim
 */
export interface KafkaSpecKafkaTemplatePersistentVolumeClaim {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaTemplatePersistentVolumeClaim#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata;

}

/**
 * Template for Kafka `PodDisruptionBudget`.
 *
 * @schema KafkaSpecKafkaTemplatePodDisruptionBudget
 */
export interface KafkaSpecKafkaTemplatePodDisruptionBudget {
  /**
   * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
   *
   * @schema KafkaSpecKafkaTemplatePodDisruptionBudget#metadata
   */
  readonly metadata?: KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata;

  /**
   * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
   *
   * @default 1.
   * @schema KafkaSpecKafkaTemplatePodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: number;

}

/**
 * Template for the Kafka broker container.
 *
 * @schema KafkaSpecKafkaTemplateKafkaContainer
 */
export interface KafkaSpecKafkaTemplateKafkaContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecKafkaTemplateKafkaContainer#env
   */
  readonly env?: KafkaSpecKafkaTemplateKafkaContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecKafkaTemplateKafkaContainer#securityContext
   */
  readonly securityContext?: KafkaSpecKafkaTemplateKafkaContainerSecurityContext;

}

/**
 * Template for the Kafka broker TLS sidecar container.
 *
 * @schema KafkaSpecKafkaTemplateTlsSidecarContainer
 */
export interface KafkaSpecKafkaTemplateTlsSidecarContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainer#env
   */
  readonly env?: KafkaSpecKafkaTemplateTlsSidecarContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainer#securityContext
   */
  readonly securityContext?: KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext;

}

/**
 * Template for the Kafka init container.
 *
 * @schema KafkaSpecKafkaTemplateInitContainer
 */
export interface KafkaSpecKafkaTemplateInitContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecKafkaTemplateInitContainer#env
   */
  readonly env?: KafkaSpecKafkaTemplateInitContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecKafkaTemplateInitContainer#securityContext
   */
  readonly securityContext?: KafkaSpecKafkaTemplateInitContainerSecurityContext;

}

/**
 * @schema KafkaSpecZookeeperStorageOverrides
 */
export interface KafkaSpecZookeeperStorageOverrides {
  /**
   * The storage class to use for dynamic volume allocation for this broker.
   *
   * @schema KafkaSpecZookeeperStorageOverrides#class
   */
  readonly class?: string;

  /**
   * Id of the kafka broker (broker identifier).
   *
   * @schema KafkaSpecZookeeperStorageOverrides#broker
   */
  readonly broker?: number;

}

/**
 * Storage type, must be either 'ephemeral' or 'persistent-claim'.
 *
 * @schema KafkaSpecZookeeperStorageType
 */
export enum KafkaSpecZookeeperStorageType {
  /** ephemeral */
  EPHEMERAL = "ephemeral",
  /** persistent-claim */
  PERSISTENT_CLAIM = "persistent-claim",
}

/**
 * @schema KafkaSpecZookeeperAffinityNodeAffinity
 */
export interface KafkaSpecZookeeperAffinityNodeAffinity {
  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAffinity
 */
export interface KafkaSpecZookeeperAffinityPodAffinity {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAntiAffinity
 */
export interface KafkaSpecZookeeperAffinityPodAntiAffinity {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecZookeeperJvmOptionsJavaSystemProperties
 */
export interface KafkaSpecZookeeperJvmOptionsJavaSystemProperties {
  /**
   * The system property name.
   *
   * @schema KafkaSpecZookeeperJvmOptionsJavaSystemProperties#name
   */
  readonly name?: string;

  /**
   * The system property value.
   *
   * @schema KafkaSpecZookeeperJvmOptionsJavaSystemProperties#value
   */
  readonly value?: string;

}

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaSpecZookeeperLoggingType
 */
export enum KafkaSpecZookeeperLoggingType {
  /** inline */
  INLINE = "inline",
  /** external */
  EXTERNAL = "external",
}

/**
 * Template for ZooKeeper `StatefulSet`.
 *
 * @schema KafkaSpecZookeeperTemplateStatefulset
 */
export interface KafkaSpecZookeeperTemplateStatefulset {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecZookeeperTemplateStatefulset#metadata
   */
  readonly metadata?: KafkaSpecZookeeperTemplateStatefulsetMetadata;

  /**
   * PodManagementPolicy which will be used for this StatefulSet. Valid values are `Parallel` and `OrderedReady`. Defaults to `Parallel`.
   *
   * @default Parallel`.
   * @schema KafkaSpecZookeeperTemplateStatefulset#podManagementPolicy
   */
  readonly podManagementPolicy?: KafkaSpecZookeeperTemplateStatefulsetPodManagementPolicy;

}

/**
 * Template for ZooKeeper `Pods`.
 *
 * @schema KafkaSpecZookeeperTemplatePod
 */
export interface KafkaSpecZookeeperTemplatePod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecZookeeperTemplatePod#metadata
   */
  readonly metadata?: KafkaSpecZookeeperTemplatePodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaSpecZookeeperTemplatePod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaSpecZookeeperTemplatePodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaSpecZookeeperTemplatePod#securityContext
   */
  readonly securityContext?: KafkaSpecZookeeperTemplatePodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaSpecZookeeperTemplatePod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaSpecZookeeperTemplatePod#affinity
   */
  readonly affinity?: KafkaSpecZookeeperTemplatePodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaSpecZookeeperTemplatePod#tolerations
   */
  readonly tolerations?: KafkaSpecZookeeperTemplatePodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaSpecZookeeperTemplatePod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaSpecZookeeperTemplatePod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
   *
   * @schema KafkaSpecZookeeperTemplatePod#hostAliases
   */
  readonly hostAliases?: KafkaSpecZookeeperTemplatePodHostAliases[];

}

/**
 * Template for ZooKeeper client `Service`.
 *
 * @schema KafkaSpecZookeeperTemplateClientService
 */
export interface KafkaSpecZookeeperTemplateClientService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecZookeeperTemplateClientService#metadata
   */
  readonly metadata?: KafkaSpecZookeeperTemplateClientServiceMetadata;

}

/**
 * Template for ZooKeeper nodes `Service`.
 *
 * @schema KafkaSpecZookeeperTemplateNodesService
 */
export interface KafkaSpecZookeeperTemplateNodesService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecZookeeperTemplateNodesService#metadata
   */
  readonly metadata?: KafkaSpecZookeeperTemplateNodesServiceMetadata;

}

/**
 * Template for all ZooKeeper `PersistentVolumeClaims`.
 *
 * @schema KafkaSpecZookeeperTemplatePersistentVolumeClaim
 */
export interface KafkaSpecZookeeperTemplatePersistentVolumeClaim {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecZookeeperTemplatePersistentVolumeClaim#metadata
   */
  readonly metadata?: KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata;

}

/**
 * Template for ZooKeeper `PodDisruptionBudget`.
 *
 * @schema KafkaSpecZookeeperTemplatePodDisruptionBudget
 */
export interface KafkaSpecZookeeperTemplatePodDisruptionBudget {
  /**
   * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
   *
   * @schema KafkaSpecZookeeperTemplatePodDisruptionBudget#metadata
   */
  readonly metadata?: KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata;

  /**
   * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
   *
   * @default 1.
   * @schema KafkaSpecZookeeperTemplatePodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: number;

}

/**
 * Template for the ZooKeeper container.
 *
 * @schema KafkaSpecZookeeperTemplateZookeeperContainer
 */
export interface KafkaSpecZookeeperTemplateZookeeperContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecZookeeperTemplateZookeeperContainer#env
   */
  readonly env?: KafkaSpecZookeeperTemplateZookeeperContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecZookeeperTemplateZookeeperContainer#securityContext
   */
  readonly securityContext?: KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext;

}

/**
 * Template for the Zookeeper server TLS sidecar container. The TLS sidecar is not used anymore and this option will be ignored.
 *
 * @schema KafkaSpecZookeeperTemplateTlsSidecarContainer
 */
export interface KafkaSpecZookeeperTemplateTlsSidecarContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainer#env
   */
  readonly env?: KafkaSpecZookeeperTemplateTlsSidecarContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainer#securityContext
   */
  readonly securityContext?: KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext;

}

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecZookeeperTlsSidecarLivenessProbe
 */
export interface KafkaSpecZookeeperTlsSidecarLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecZookeeperTlsSidecarLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecZookeeperTlsSidecarLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecZookeeperTlsSidecarLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecZookeeperTlsSidecarLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecZookeeperTlsSidecarLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * The log level for the TLS sidecar. Default value is `notice`.
 *
 * @schema KafkaSpecZookeeperTlsSidecarLogLevel
 */
export enum KafkaSpecZookeeperTlsSidecarLogLevel {
  /** emerg */
  EMERG = "emerg",
  /** alert */
  ALERT = "alert",
  /** crit */
  CRIT = "crit",
  /** err */
  ERR = "err",
  /** warning */
  WARNING = "warning",
  /** notice */
  NOTICE = "notice",
  /** info */
  INFO = "info",
  /** debug */
  DEBUG = "debug",
}

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecZookeeperTlsSidecarReadinessProbe
 */
export interface KafkaSpecZookeeperTlsSidecarReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecZookeeperTlsSidecarReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecZookeeperTlsSidecarReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecZookeeperTlsSidecarReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecZookeeperTlsSidecarReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecZookeeperTlsSidecarReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecZookeeperTlsSidecarResources
 */
export interface KafkaSpecZookeeperTlsSidecarResources {
  /**
   * @schema KafkaSpecZookeeperTlsSidecarResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecZookeeperTlsSidecarResources#requests
   */
  readonly requests?: any;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityNodeAffinity
 */
export interface KafkaSpecTopicOperatorAffinityNodeAffinity {
  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAffinity
 */
export interface KafkaSpecTopicOperatorAffinityPodAffinity {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinity
 */
export interface KafkaSpecTopicOperatorAffinityPodAntiAffinity {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecTopicOperatorTlsSidecarLivenessProbe
 */
export interface KafkaSpecTopicOperatorTlsSidecarLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecTopicOperatorTlsSidecarLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecTopicOperatorTlsSidecarLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecTopicOperatorTlsSidecarLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecTopicOperatorTlsSidecarLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecTopicOperatorTlsSidecarLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * The log level for the TLS sidecar. Default value is `notice`.
 *
 * @schema KafkaSpecTopicOperatorTlsSidecarLogLevel
 */
export enum KafkaSpecTopicOperatorTlsSidecarLogLevel {
  /** emerg */
  EMERG = "emerg",
  /** alert */
  ALERT = "alert",
  /** crit */
  CRIT = "crit",
  /** err */
  ERR = "err",
  /** warning */
  WARNING = "warning",
  /** notice */
  NOTICE = "notice",
  /** info */
  INFO = "info",
  /** debug */
  DEBUG = "debug",
}

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecTopicOperatorTlsSidecarReadinessProbe
 */
export interface KafkaSpecTopicOperatorTlsSidecarReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecTopicOperatorTlsSidecarReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecTopicOperatorTlsSidecarReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecTopicOperatorTlsSidecarReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecTopicOperatorTlsSidecarReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecTopicOperatorTlsSidecarReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecTopicOperatorTlsSidecarResources
 */
export interface KafkaSpecTopicOperatorTlsSidecarResources {
  /**
   * @schema KafkaSpecTopicOperatorTlsSidecarResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecTopicOperatorTlsSidecarResources#requests
   */
  readonly requests?: any;

}

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaSpecTopicOperatorLoggingType
 */
export enum KafkaSpecTopicOperatorLoggingType {
  /** inline */
  INLINE = "inline",
  /** external */
  EXTERNAL = "external",
}

/**
 * @schema KafkaSpecTopicOperatorJvmOptionsJavaSystemProperties
 */
export interface KafkaSpecTopicOperatorJvmOptionsJavaSystemProperties {
  /**
   * The system property name.
   *
   * @schema KafkaSpecTopicOperatorJvmOptionsJavaSystemProperties#name
   */
  readonly name?: string;

  /**
   * The system property value.
   *
   * @schema KafkaSpecTopicOperatorJvmOptionsJavaSystemProperties#value
   */
  readonly value?: string;

}

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorLivenessProbe
 */
export interface KafkaSpecEntityOperatorTopicOperatorLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTopicOperatorLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTopicOperatorLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTopicOperatorLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorReadinessProbe
 */
export interface KafkaSpecEntityOperatorTopicOperatorReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTopicOperatorReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTopicOperatorReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTopicOperatorReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorResources
 */
export interface KafkaSpecEntityOperatorTopicOperatorResources {
  /**
   * @schema KafkaSpecEntityOperatorTopicOperatorResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecEntityOperatorTopicOperatorResources#requests
   */
  readonly requests?: any;

}

/**
 * Logging configuration.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorLogging
 */
export interface KafkaSpecEntityOperatorTopicOperatorLogging {
  /**
   * A Map from logger name to logger level.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorLogging#loggers
   */
  readonly loggers?: any;

  /**
   * The name of the `ConfigMap` from which to get the logging configuration.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorLogging#name
   */
  readonly name?: string;

  /**
   * Logging type, must be either 'inline' or 'external'.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorLogging#type
   */
  readonly type: KafkaSpecEntityOperatorTopicOperatorLoggingType;

}

/**
 * JVM Options for pods.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptions
 */
export interface KafkaSpecEntityOperatorTopicOperatorJvmOptions {
  /**
   * A map of -XX options to the JVM.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptions#-XX
   */
  readonly xx?: any;

  /**
   * -Xms option to to the JVM.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptions#-Xms
   */
  readonly xms?: string;

  /**
   * -Xmx option to to the JVM.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptions#-Xmx
   */
  readonly xmx?: string;

  /**
   * Specifies whether the Garbage Collection logging is enabled. The default is false.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptions#gcLoggingEnabled
   */
  readonly gcLoggingEnabled?: boolean;

  /**
   * A map of additional system properties which will be passed using the `-D` option to the JVM.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptions#javaSystemProperties
   */
  readonly javaSystemProperties?: KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties[];

}

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecEntityOperatorUserOperatorLivenessProbe
 */
export interface KafkaSpecEntityOperatorUserOperatorLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorUserOperatorLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorUserOperatorLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorUserOperatorLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecEntityOperatorUserOperatorReadinessProbe
 */
export interface KafkaSpecEntityOperatorUserOperatorReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorUserOperatorReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorUserOperatorReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorUserOperatorReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecEntityOperatorUserOperatorResources
 */
export interface KafkaSpecEntityOperatorUserOperatorResources {
  /**
   * @schema KafkaSpecEntityOperatorUserOperatorResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecEntityOperatorUserOperatorResources#requests
   */
  readonly requests?: any;

}

/**
 * Logging configuration.
 *
 * @schema KafkaSpecEntityOperatorUserOperatorLogging
 */
export interface KafkaSpecEntityOperatorUserOperatorLogging {
  /**
   * A Map from logger name to logger level.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorLogging#loggers
   */
  readonly loggers?: any;

  /**
   * The name of the `ConfigMap` from which to get the logging configuration.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorLogging#name
   */
  readonly name?: string;

  /**
   * Logging type, must be either 'inline' or 'external'.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorLogging#type
   */
  readonly type: KafkaSpecEntityOperatorUserOperatorLoggingType;

}

/**
 * JVM Options for pods.
 *
 * @schema KafkaSpecEntityOperatorUserOperatorJvmOptions
 */
export interface KafkaSpecEntityOperatorUserOperatorJvmOptions {
  /**
   * A map of -XX options to the JVM.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorJvmOptions#-XX
   */
  readonly xx?: any;

  /**
   * -Xms option to to the JVM.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorJvmOptions#-Xms
   */
  readonly xms?: string;

  /**
   * -Xmx option to to the JVM.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorJvmOptions#-Xmx
   */
  readonly xmx?: string;

  /**
   * Specifies whether the Garbage Collection logging is enabled. The default is false.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorJvmOptions#gcLoggingEnabled
   */
  readonly gcLoggingEnabled?: boolean;

  /**
   * A map of additional system properties which will be passed using the `-D` option to the JVM.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorJvmOptions#javaSystemProperties
   */
  readonly javaSystemProperties?: KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties[];

}

/**
 * @schema KafkaSpecEntityOperatorAffinityNodeAffinity
 */
export interface KafkaSpecEntityOperatorAffinityNodeAffinity {
  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAffinity
 */
export interface KafkaSpecEntityOperatorAffinityPodAffinity {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinity
 */
export interface KafkaSpecEntityOperatorAffinityPodAntiAffinity {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecEntityOperatorTlsSidecarLivenessProbe
 */
export interface KafkaSpecEntityOperatorTlsSidecarLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTlsSidecarLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecEntityOperatorTlsSidecarLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTlsSidecarLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTlsSidecarLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecEntityOperatorTlsSidecarLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * The log level for the TLS sidecar. Default value is `notice`.
 *
 * @schema KafkaSpecEntityOperatorTlsSidecarLogLevel
 */
export enum KafkaSpecEntityOperatorTlsSidecarLogLevel {
  /** emerg */
  EMERG = "emerg",
  /** alert */
  ALERT = "alert",
  /** crit */
  CRIT = "crit",
  /** err */
  ERR = "err",
  /** warning */
  WARNING = "warning",
  /** notice */
  NOTICE = "notice",
  /** info */
  INFO = "info",
  /** debug */
  DEBUG = "debug",
}

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecEntityOperatorTlsSidecarReadinessProbe
 */
export interface KafkaSpecEntityOperatorTlsSidecarReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTlsSidecarReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecEntityOperatorTlsSidecarReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTlsSidecarReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecEntityOperatorTlsSidecarReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecEntityOperatorTlsSidecarReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecEntityOperatorTlsSidecarResources
 */
export interface KafkaSpecEntityOperatorTlsSidecarResources {
  /**
   * @schema KafkaSpecEntityOperatorTlsSidecarResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecEntityOperatorTlsSidecarResources#requests
   */
  readonly requests?: any;

}

/**
 * Template for Entity Operator `Deployment`.
 *
 * @schema KafkaSpecEntityOperatorTemplateDeployment
 */
export interface KafkaSpecEntityOperatorTemplateDeployment {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecEntityOperatorTemplateDeployment#metadata
   */
  readonly metadata?: KafkaSpecEntityOperatorTemplateDeploymentMetadata;

}

/**
 * Template for Entity Operator `Pods`.
 *
 * @schema KafkaSpecEntityOperatorTemplatePod
 */
export interface KafkaSpecEntityOperatorTemplatePod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecEntityOperatorTemplatePod#metadata
   */
  readonly metadata?: KafkaSpecEntityOperatorTemplatePodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaSpecEntityOperatorTemplatePod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaSpecEntityOperatorTemplatePodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaSpecEntityOperatorTemplatePod#securityContext
   */
  readonly securityContext?: KafkaSpecEntityOperatorTemplatePodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaSpecEntityOperatorTemplatePod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaSpecEntityOperatorTemplatePod#affinity
   */
  readonly affinity?: KafkaSpecEntityOperatorTemplatePodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaSpecEntityOperatorTemplatePod#tolerations
   */
  readonly tolerations?: KafkaSpecEntityOperatorTemplatePodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaSpecEntityOperatorTemplatePod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaSpecEntityOperatorTemplatePod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
   *
   * @schema KafkaSpecEntityOperatorTemplatePod#hostAliases
   */
  readonly hostAliases?: KafkaSpecEntityOperatorTemplatePodHostAliases[];

}

/**
 * Template for the Entity Operator TLS sidecar container.
 *
 * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainer
 */
export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainer#env
   */
  readonly env?: KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainer#securityContext
   */
  readonly securityContext?: KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext;

}

/**
 * Template for the Entity Topic Operator container.
 *
 * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainer
 */
export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainer#env
   */
  readonly env?: KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainer#securityContext
   */
  readonly securityContext?: KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext;

}

/**
 * Template for the Entity User Operator container.
 *
 * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainer
 */
export interface KafkaSpecEntityOperatorTemplateUserOperatorContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainer#env
   */
  readonly env?: KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainer#securityContext
   */
  readonly securityContext?: KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext;

}

/**
 * Pod liveness checking.
 *
 * @schema KafkaSpecCruiseControlTlsSidecarLivenessProbe
 */
export interface KafkaSpecCruiseControlTlsSidecarLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecCruiseControlTlsSidecarLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecCruiseControlTlsSidecarLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecCruiseControlTlsSidecarLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecCruiseControlTlsSidecarLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecCruiseControlTlsSidecarLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * The log level for the TLS sidecar. Default value is `notice`.
 *
 * @schema KafkaSpecCruiseControlTlsSidecarLogLevel
 */
export enum KafkaSpecCruiseControlTlsSidecarLogLevel {
  /** emerg */
  EMERG = "emerg",
  /** alert */
  ALERT = "alert",
  /** crit */
  CRIT = "crit",
  /** err */
  ERR = "err",
  /** warning */
  WARNING = "warning",
  /** notice */
  NOTICE = "notice",
  /** info */
  INFO = "info",
  /** debug */
  DEBUG = "debug",
}

/**
 * Pod readiness checking.
 *
 * @schema KafkaSpecCruiseControlTlsSidecarReadinessProbe
 */
export interface KafkaSpecCruiseControlTlsSidecarReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaSpecCruiseControlTlsSidecarReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaSpecCruiseControlTlsSidecarReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaSpecCruiseControlTlsSidecarReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaSpecCruiseControlTlsSidecarReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaSpecCruiseControlTlsSidecarReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaSpecCruiseControlTlsSidecarResources
 */
export interface KafkaSpecCruiseControlTlsSidecarResources {
  /**
   * @schema KafkaSpecCruiseControlTlsSidecarResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaSpecCruiseControlTlsSidecarResources#requests
   */
  readonly requests?: any;

}

/**
 * @schema KafkaSpecCruiseControlJvmOptionsJavaSystemProperties
 */
export interface KafkaSpecCruiseControlJvmOptionsJavaSystemProperties {
  /**
   * The system property name.
   *
   * @schema KafkaSpecCruiseControlJvmOptionsJavaSystemProperties#name
   */
  readonly name?: string;

  /**
   * The system property value.
   *
   * @schema KafkaSpecCruiseControlJvmOptionsJavaSystemProperties#value
   */
  readonly value?: string;

}

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaSpecCruiseControlLoggingType
 */
export enum KafkaSpecCruiseControlLoggingType {
  /** inline */
  INLINE = "inline",
  /** external */
  EXTERNAL = "external",
}

/**
 * Template for Cruise Control `Deployment`.
 *
 * @schema KafkaSpecCruiseControlTemplateDeployment
 */
export interface KafkaSpecCruiseControlTemplateDeployment {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecCruiseControlTemplateDeployment#metadata
   */
  readonly metadata?: KafkaSpecCruiseControlTemplateDeploymentMetadata;

}

/**
 * Template for Cruise Control `Pods`.
 *
 * @schema KafkaSpecCruiseControlTemplatePod
 */
export interface KafkaSpecCruiseControlTemplatePod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecCruiseControlTemplatePod#metadata
   */
  readonly metadata?: KafkaSpecCruiseControlTemplatePodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaSpecCruiseControlTemplatePod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaSpecCruiseControlTemplatePodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaSpecCruiseControlTemplatePod#securityContext
   */
  readonly securityContext?: KafkaSpecCruiseControlTemplatePodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaSpecCruiseControlTemplatePod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaSpecCruiseControlTemplatePod#affinity
   */
  readonly affinity?: KafkaSpecCruiseControlTemplatePodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaSpecCruiseControlTemplatePod#tolerations
   */
  readonly tolerations?: KafkaSpecCruiseControlTemplatePodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaSpecCruiseControlTemplatePod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaSpecCruiseControlTemplatePod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
   *
   * @schema KafkaSpecCruiseControlTemplatePod#hostAliases
   */
  readonly hostAliases?: KafkaSpecCruiseControlTemplatePodHostAliases[];

}

/**
 * Template for Cruise Control API `Service`.
 *
 * @schema KafkaSpecCruiseControlTemplateApiService
 */
export interface KafkaSpecCruiseControlTemplateApiService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecCruiseControlTemplateApiService#metadata
   */
  readonly metadata?: KafkaSpecCruiseControlTemplateApiServiceMetadata;

}

/**
 * Template for Cruise Control `PodDisruptionBudget`.
 *
 * @schema KafkaSpecCruiseControlTemplatePodDisruptionBudget
 */
export interface KafkaSpecCruiseControlTemplatePodDisruptionBudget {
  /**
   * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
   *
   * @schema KafkaSpecCruiseControlTemplatePodDisruptionBudget#metadata
   */
  readonly metadata?: KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata;

  /**
   * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
   *
   * @default 1.
   * @schema KafkaSpecCruiseControlTemplatePodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: number;

}

/**
 * Template for the Cruise Control container.
 *
 * @schema KafkaSpecCruiseControlTemplateCruiseControlContainer
 */
export interface KafkaSpecCruiseControlTemplateCruiseControlContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainer#env
   */
  readonly env?: KafkaSpecCruiseControlTemplateCruiseControlContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainer#securityContext
   */
  readonly securityContext?: KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext;

}

/**
 * Template for the Cruise Control TLS sidecar container.
 *
 * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainer
 */
export interface KafkaSpecCruiseControlTemplateTlsSidecarContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainer#env
   */
  readonly env?: KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainer#securityContext
   */
  readonly securityContext?: KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext;

}

/**
 * Template for JmxTrans `Deployment`.
 *
 * @schema KafkaSpecJmxTransTemplateDeployment
 */
export interface KafkaSpecJmxTransTemplateDeployment {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecJmxTransTemplateDeployment#metadata
   */
  readonly metadata?: KafkaSpecJmxTransTemplateDeploymentMetadata;

}

/**
 * Template for JmxTrans `Pods`.
 *
 * @schema KafkaSpecJmxTransTemplatePod
 */
export interface KafkaSpecJmxTransTemplatePod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecJmxTransTemplatePod#metadata
   */
  readonly metadata?: KafkaSpecJmxTransTemplatePodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaSpecJmxTransTemplatePod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaSpecJmxTransTemplatePodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaSpecJmxTransTemplatePod#securityContext
   */
  readonly securityContext?: KafkaSpecJmxTransTemplatePodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaSpecJmxTransTemplatePod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaSpecJmxTransTemplatePod#affinity
   */
  readonly affinity?: KafkaSpecJmxTransTemplatePodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaSpecJmxTransTemplatePod#tolerations
   */
  readonly tolerations?: KafkaSpecJmxTransTemplatePodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaSpecJmxTransTemplatePod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaSpecJmxTransTemplatePod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
   *
   * @schema KafkaSpecJmxTransTemplatePod#hostAliases
   */
  readonly hostAliases?: KafkaSpecJmxTransTemplatePodHostAliases[];

}

/**
 * Template for JmxTrans container.
 *
 * @schema KafkaSpecJmxTransTemplateContainer
 */
export interface KafkaSpecJmxTransTemplateContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecJmxTransTemplateContainer#env
   */
  readonly env?: KafkaSpecJmxTransTemplateContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecJmxTransTemplateContainer#securityContext
   */
  readonly securityContext?: KafkaSpecJmxTransTemplateContainerSecurityContext;

}

/**
 * Template for Kafka Exporter `Deployment`.
 *
 * @schema KafkaSpecKafkaExporterTemplateDeployment
 */
export interface KafkaSpecKafkaExporterTemplateDeployment {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaExporterTemplateDeployment#metadata
   */
  readonly metadata?: KafkaSpecKafkaExporterTemplateDeploymentMetadata;

}

/**
 * Template for Kafka Exporter `Pods`.
 *
 * @schema KafkaSpecKafkaExporterTemplatePod
 */
export interface KafkaSpecKafkaExporterTemplatePod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaExporterTemplatePod#metadata
   */
  readonly metadata?: KafkaSpecKafkaExporterTemplatePodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaSpecKafkaExporterTemplatePod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaSpecKafkaExporterTemplatePodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaSpecKafkaExporterTemplatePod#securityContext
   */
  readonly securityContext?: KafkaSpecKafkaExporterTemplatePodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaSpecKafkaExporterTemplatePod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaSpecKafkaExporterTemplatePod#affinity
   */
  readonly affinity?: KafkaSpecKafkaExporterTemplatePodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaSpecKafkaExporterTemplatePod#tolerations
   */
  readonly tolerations?: KafkaSpecKafkaExporterTemplatePodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaSpecKafkaExporterTemplatePod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaSpecKafkaExporterTemplatePod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
   *
   * @schema KafkaSpecKafkaExporterTemplatePod#hostAliases
   */
  readonly hostAliases?: KafkaSpecKafkaExporterTemplatePodHostAliases[];

}

/**
 * Template for Kafka Exporter `Service`.
 *
 * @schema KafkaSpecKafkaExporterTemplateService
 */
export interface KafkaSpecKafkaExporterTemplateService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaSpecKafkaExporterTemplateService#metadata
   */
  readonly metadata?: KafkaSpecKafkaExporterTemplateServiceMetadata;

}

/**
 * Template for the Kafka Exporter container.
 *
 * @schema KafkaSpecKafkaExporterTemplateContainer
 */
export interface KafkaSpecKafkaExporterTemplateContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaSpecKafkaExporterTemplateContainer#env
   */
  readonly env?: KafkaSpecKafkaExporterTemplateContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaSpecKafkaExporterTemplateContainer#securityContext
   */
  readonly securityContext?: KafkaSpecKafkaExporterTemplateContainerSecurityContext;

}

/**
 * @schema KafkaSpecKafkaStorageVolumesOverrides
 */
export interface KafkaSpecKafkaStorageVolumesOverrides {
  /**
   * The storage class to use for dynamic volume allocation for this broker.
   *
   * @schema KafkaSpecKafkaStorageVolumesOverrides#class
   */
  readonly class?: string;

  /**
   * Id of the kafka broker (broker identifier).
   *
   * @schema KafkaSpecKafkaStorageVolumesOverrides#broker
   */
  readonly broker?: number;

}

/**
 * Storage type, must be either 'ephemeral' or 'persistent-claim'.
 *
 * @schema KafkaSpecKafkaStorageVolumesType
 */
export enum KafkaSpecKafkaStorageVolumesType {
  /** ephemeral */
  EPHEMERAL = "ephemeral",
  /** persistent-claim */
  PERSISTENT_CLAIM = "persistent-claim",
}

/**
 * @schema KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Authentication type. Currently the only supported types are `password`.`password` type creates a username and protected port with no TLS.
 *
 * @schema KafkaSpecKafkaJmxOptionsAuthenticationType
 */
export enum KafkaSpecKafkaJmxOptionsAuthenticationType {
  /** password */
  PASSWORD = "password",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateStatefulsetMetadata
 */
export interface KafkaSpecKafkaTemplateStatefulsetMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateStatefulsetMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateStatefulsetMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * PodManagementPolicy which will be used for this StatefulSet. Valid values are `Parallel` and `OrderedReady`. Defaults to `Parallel`.
 *
 * @default Parallel`.
 * @schema KafkaSpecKafkaTemplateStatefulsetPodManagementPolicy
 */
export enum KafkaSpecKafkaTemplateStatefulsetPodManagementPolicy {
  /** OrderedReady */
  ORDERED_READY = "OrderedReady",
  /** Parallel */
  PARALLEL = "Parallel",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplatePodMetadata
 */
export interface KafkaSpecKafkaTemplatePodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaSpecKafkaTemplatePodImagePullSecrets
 */
export interface KafkaSpecKafkaTemplatePodImagePullSecrets {
  /**
   * @schema KafkaSpecKafkaTemplatePodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaSpecKafkaTemplatePodSecurityContext
 */
export interface KafkaSpecKafkaTemplatePodSecurityContext {
  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaSpecKafkaTemplatePodSecurityContextSysctls[];

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions;

}

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecKafkaTemplatePodAffinity
 */
export interface KafkaSpecKafkaTemplatePodAffinity {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaSpecKafkaTemplatePodAffinityNodeAffinity;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaSpecKafkaTemplatePodAffinityPodAffinity;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity;

}

/**
 * @schema KafkaSpecKafkaTemplatePodTolerations
 */
export interface KafkaSpecKafkaTemplatePodTolerations {
  /**
   * @schema KafkaSpecKafkaTemplatePodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaSpecKafkaTemplatePodTolerations#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaSpecKafkaTemplatePodHostAliases
 */
export interface KafkaSpecKafkaTemplatePodHostAliases {
  /**
   * @schema KafkaSpecKafkaTemplatePodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaSpecKafkaTemplatePodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateBootstrapServiceMetadata
 */
export interface KafkaSpecKafkaTemplateBootstrapServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateBootstrapServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateBootstrapServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateBrokersServiceMetadata
 */
export interface KafkaSpecKafkaTemplateBrokersServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateBrokersServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateBrokersServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata
 */
export interface KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. `Cluster` may cause a second hop to another node and obscures the client source IP. `Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). If unspecified, Kubernetes will use `Cluster` as the default.
 *
 * @schema KafkaSpecKafkaTemplateExternalBootstrapServiceExternalTrafficPolicy
 */
export enum KafkaSpecKafkaTemplateExternalBootstrapServiceExternalTrafficPolicy {
  /** Local */
  LOCAL = "Local",
  /** Cluster */
  CLUSTER = "Cluster",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplatePerPodServiceMetadata
 */
export interface KafkaSpecKafkaTemplatePerPodServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePerPodServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePerPodServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Specifies whether the service routes external traffic to node-local or cluster-wide endpoints. `Cluster` may cause a second hop to another node and obscures the client source IP. `Local` avoids a second hop for LoadBalancer and Nodeport type services and preserves the client source IP (when supported by the infrastructure). If unspecified, Kubernetes will use `Cluster` as the default.
 *
 * @schema KafkaSpecKafkaTemplatePerPodServiceExternalTrafficPolicy
 */
export enum KafkaSpecKafkaTemplatePerPodServiceExternalTrafficPolicy {
  /** Local */
  LOCAL = "Local",
  /** Cluster */
  CLUSTER = "Cluster",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata
 */
export interface KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapRouteMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplatePerPodRouteMetadata
 */
export interface KafkaSpecKafkaTemplatePerPodRouteMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePerPodRouteMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePerPodRouteMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata
 */
export interface KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplateExternalBootstrapIngressMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplatePerPodIngressMetadata
 */
export interface KafkaSpecKafkaTemplatePerPodIngressMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePerPodIngressMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePerPodIngressMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata
 */
export interface KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePersistentVolumeClaimMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
 *
 * @schema KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata
 */
export interface KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaTemplatePodDisruptionBudgetMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaSpecKafkaTemplateKafkaContainerEnv
 */
export interface KafkaSpecKafkaTemplateKafkaContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecKafkaTemplateKafkaContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecKafkaTemplateKafkaContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext
 */
export interface KafkaSpecKafkaTemplateKafkaContainerSecurityContext {
  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions;

}

/**
 * @schema KafkaSpecKafkaTemplateTlsSidecarContainerEnv
 */
export interface KafkaSpecKafkaTemplateTlsSidecarContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext
 */
export interface KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext {
  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextWindowsOptions;

}

/**
 * @schema KafkaSpecKafkaTemplateInitContainerEnv
 */
export interface KafkaSpecKafkaTemplateInitContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecKafkaTemplateInitContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecKafkaTemplateInitContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext
 */
export interface KafkaSpecKafkaTemplateInitContainerSecurityContext {
  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions;

}

/**
 * @schema KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecZookeeperTemplateStatefulsetMetadata
 */
export interface KafkaSpecZookeeperTemplateStatefulsetMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplateStatefulsetMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplateStatefulsetMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * PodManagementPolicy which will be used for this StatefulSet. Valid values are `Parallel` and `OrderedReady`. Defaults to `Parallel`.
 *
 * @default Parallel`.
 * @schema KafkaSpecZookeeperTemplateStatefulsetPodManagementPolicy
 */
export enum KafkaSpecZookeeperTemplateStatefulsetPodManagementPolicy {
  /** OrderedReady */
  ORDERED_READY = "OrderedReady",
  /** Parallel */
  PARALLEL = "Parallel",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecZookeeperTemplatePodMetadata
 */
export interface KafkaSpecZookeeperTemplatePodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplatePodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplatePodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodImagePullSecrets
 */
export interface KafkaSpecZookeeperTemplatePodImagePullSecrets {
  /**
   * @schema KafkaSpecZookeeperTemplatePodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaSpecZookeeperTemplatePodSecurityContext
 */
export interface KafkaSpecZookeeperTemplatePodSecurityContext {
  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaSpecZookeeperTemplatePodSecurityContextSysctls[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions;

}

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecZookeeperTemplatePodAffinity
 */
export interface KafkaSpecZookeeperTemplatePodAffinity {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinity;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaSpecZookeeperTemplatePodAffinityPodAffinity;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodTolerations
 */
export interface KafkaSpecZookeeperTemplatePodTolerations {
  /**
   * @schema KafkaSpecZookeeperTemplatePodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaSpecZookeeperTemplatePodTolerations#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodHostAliases
 */
export interface KafkaSpecZookeeperTemplatePodHostAliases {
  /**
   * @schema KafkaSpecZookeeperTemplatePodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecZookeeperTemplateClientServiceMetadata
 */
export interface KafkaSpecZookeeperTemplateClientServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplateClientServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplateClientServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecZookeeperTemplateNodesServiceMetadata
 */
export interface KafkaSpecZookeeperTemplateNodesServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplateNodesServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplateNodesServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata
 */
export interface KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplatePersistentVolumeClaimMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
 *
 * @schema KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata
 */
export interface KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecZookeeperTemplatePodDisruptionBudgetMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaSpecZookeeperTemplateZookeeperContainerEnv
 */
export interface KafkaSpecZookeeperTemplateZookeeperContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext
 */
export interface KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext {
  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions;

}

/**
 * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerEnv
 */
export interface KafkaSpecZookeeperTemplateTlsSidecarContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext
 */
export interface KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext {
  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextWindowsOptions;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaSpecEntityOperatorTopicOperatorLoggingType
 */
export enum KafkaSpecEntityOperatorTopicOperatorLoggingType {
  /** inline */
  INLINE = "inline",
  /** external */
  EXTERNAL = "external",
}

/**
 * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties
 */
export interface KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties {
  /**
   * The system property name.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties#name
   */
  readonly name?: string;

  /**
   * The system property value.
   *
   * @schema KafkaSpecEntityOperatorTopicOperatorJvmOptionsJavaSystemProperties#value
   */
  readonly value?: string;

}

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaSpecEntityOperatorUserOperatorLoggingType
 */
export enum KafkaSpecEntityOperatorUserOperatorLoggingType {
  /** inline */
  INLINE = "inline",
  /** external */
  EXTERNAL = "external",
}

/**
 * @schema KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties
 */
export interface KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties {
  /**
   * The system property name.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties#name
   */
  readonly name?: string;

  /**
   * The system property value.
   *
   * @schema KafkaSpecEntityOperatorUserOperatorJvmOptionsJavaSystemProperties#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecEntityOperatorTemplateDeploymentMetadata
 */
export interface KafkaSpecEntityOperatorTemplateDeploymentMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecEntityOperatorTemplateDeploymentMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecEntityOperatorTemplateDeploymentMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecEntityOperatorTemplatePodMetadata
 */
export interface KafkaSpecEntityOperatorTemplatePodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecEntityOperatorTemplatePodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecEntityOperatorTemplatePodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodImagePullSecrets
 */
export interface KafkaSpecEntityOperatorTemplatePodImagePullSecrets {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext
 */
export interface KafkaSpecEntityOperatorTemplatePodSecurityContext {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions;

}

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecEntityOperatorTemplatePodAffinity
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinity {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodTolerations
 */
export interface KafkaSpecEntityOperatorTemplatePodTolerations {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodTolerations#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodHostAliases
 */
export interface KafkaSpecEntityOperatorTemplatePodHostAliases {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv
 */
export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext
 */
export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext {
  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions;

}

/**
 * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv
 */
export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext
 */
export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext {
  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions;

}

/**
 * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv
 */
export interface KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext
 */
export interface KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext {
  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecCruiseControlTemplateDeploymentMetadata
 */
export interface KafkaSpecCruiseControlTemplateDeploymentMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecCruiseControlTemplateDeploymentMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecCruiseControlTemplateDeploymentMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecCruiseControlTemplatePodMetadata
 */
export interface KafkaSpecCruiseControlTemplatePodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecCruiseControlTemplatePodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecCruiseControlTemplatePodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodImagePullSecrets
 */
export interface KafkaSpecCruiseControlTemplatePodImagePullSecrets {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaSpecCruiseControlTemplatePodSecurityContext
 */
export interface KafkaSpecCruiseControlTemplatePodSecurityContext {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaSpecCruiseControlTemplatePodSecurityContextSysctls[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions;

}

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecCruiseControlTemplatePodAffinity
 */
export interface KafkaSpecCruiseControlTemplatePodAffinity {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinity;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodTolerations
 */
export interface KafkaSpecCruiseControlTemplatePodTolerations {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodTolerations#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodHostAliases
 */
export interface KafkaSpecCruiseControlTemplatePodHostAliases {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecCruiseControlTemplateApiServiceMetadata
 */
export interface KafkaSpecCruiseControlTemplateApiServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecCruiseControlTemplateApiServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecCruiseControlTemplateApiServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
 *
 * @schema KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata
 */
export interface KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecCruiseControlTemplatePodDisruptionBudgetMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerEnv
 */
export interface KafkaSpecCruiseControlTemplateCruiseControlContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext
 */
export interface KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext {
  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions;

}

/**
 * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv
 */
export interface KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext
 */
export interface KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext {
  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecJmxTransTemplateDeploymentMetadata
 */
export interface KafkaSpecJmxTransTemplateDeploymentMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecJmxTransTemplateDeploymentMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecJmxTransTemplateDeploymentMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecJmxTransTemplatePodMetadata
 */
export interface KafkaSpecJmxTransTemplatePodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecJmxTransTemplatePodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecJmxTransTemplatePodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodImagePullSecrets
 */
export interface KafkaSpecJmxTransTemplatePodImagePullSecrets {
  /**
   * @schema KafkaSpecJmxTransTemplatePodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaSpecJmxTransTemplatePodSecurityContext
 */
export interface KafkaSpecJmxTransTemplatePodSecurityContext {
  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaSpecJmxTransTemplatePodSecurityContextSysctls[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions;

}

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecJmxTransTemplatePodAffinity
 */
export interface KafkaSpecJmxTransTemplatePodAffinity {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinity;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaSpecJmxTransTemplatePodAffinityPodAffinity;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodTolerations
 */
export interface KafkaSpecJmxTransTemplatePodTolerations {
  /**
   * @schema KafkaSpecJmxTransTemplatePodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaSpecJmxTransTemplatePodTolerations#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodHostAliases
 */
export interface KafkaSpecJmxTransTemplatePodHostAliases {
  /**
   * @schema KafkaSpecJmxTransTemplatePodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * @schema KafkaSpecJmxTransTemplateContainerEnv
 */
export interface KafkaSpecJmxTransTemplateContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecJmxTransTemplateContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecJmxTransTemplateContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaSpecJmxTransTemplateContainerSecurityContext
 */
export interface KafkaSpecJmxTransTemplateContainerSecurityContext {
  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaExporterTemplateDeploymentMetadata
 */
export interface KafkaSpecKafkaExporterTemplateDeploymentMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaExporterTemplateDeploymentMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaExporterTemplateDeploymentMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaExporterTemplatePodMetadata
 */
export interface KafkaSpecKafkaExporterTemplatePodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaExporterTemplatePodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaExporterTemplatePodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodImagePullSecrets
 */
export interface KafkaSpecKafkaExporterTemplatePodImagePullSecrets {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext
 */
export interface KafkaSpecKafkaExporterTemplatePodSecurityContext {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions;

}

/**
 * The pod's affinity rules.
 *
 * @schema KafkaSpecKafkaExporterTemplatePodAffinity
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinity {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodTolerations
 */
export interface KafkaSpecKafkaExporterTemplatePodTolerations {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodTolerations#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodHostAliases
 */
export interface KafkaSpecKafkaExporterTemplatePodHostAliases {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaSpecKafkaExporterTemplateServiceMetadata
 */
export interface KafkaSpecKafkaExporterTemplateServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaExporterTemplateServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaSpecKafkaExporterTemplateServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaSpecKafkaExporterTemplateContainerEnv
 */
export interface KafkaSpecKafkaExporterTemplateContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaSpecKafkaExporterTemplateContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaSpecKafkaExporterTemplateContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext
 */
export interface KafkaSpecKafkaExporterTemplateContainerSecurityContext {
  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions;

}

/**
 * @schema KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecKafkaTemplatePodSecurityContextSysctls
 */
export interface KafkaSpecKafkaTemplatePodSecurityContextSysctls {
  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinity
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinity {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinity
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinity {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities
 */
export interface KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecKafkaTemplateKafkaContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextCapabilities
 */
export interface KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecKafkaTemplateTlsSidecarContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities
 */
export interface KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecKafkaTemplateInitContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodSecurityContextSysctls
 */
export interface KafkaSpecZookeeperTemplatePodSecurityContextSysctls {
  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinity
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinity {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinity
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinity {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities
 */
export interface KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateZookeeperContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextCapabilities
 */
export interface KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecZookeeperTemplateTlsSidecarContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls
 */
export interface KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities
 */
export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTlsSidecarContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities
 */
export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateTopicOperatorContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities
 */
export interface KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplateUserOperatorContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSysctls
 */
export interface KafkaSpecCruiseControlTemplatePodSecurityContextSysctls {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinity
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinity {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities
 */
export interface KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateCruiseControlContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities
 */
export interface KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplateTlsSidecarContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodSecurityContextSysctls
 */
export interface KafkaSpecJmxTransTemplatePodSecurityContextSysctls {
  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinity
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinity {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinity
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinity {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities
 */
export interface KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecJmxTransTemplateContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls
 */
export interface KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities
 */
export interface KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities {
  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions
 */
export interface KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions
 */
export interface KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplateContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecTopicOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecZookeeperTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecEntityOperatorTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecCruiseControlTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecJmxTransTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaSpecKafkaExporterTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * 
 *
 * @schema KafkaBridge
 */
export class KafkaBridge extends ApiObject {
  /**
   * Returns the apiVersion and kind for "KafkaBridge"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kafka.strimzi.io/v1alpha1',
    kind: 'KafkaBridge',
  }

  /**
   * Renders a Kubernetes manifest for "KafkaBridge".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KafkaBridgeProps = {}): any {
    return {
      ...KafkaBridge.GVK,
      ...props,
    };
  }

  /**
   * Defines a "KafkaBridge" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KafkaBridgeProps = {}) {
    super(scope, id, KafkaBridge.manifest(props));
  }
}

/**
 * @schema KafkaBridge
 */
export interface KafkaBridgeProps {
  /**
   * The specification of the Kafka Bridge.
   *
   * @schema KafkaBridge#spec
   */
  readonly spec?: KafkaBridgeSpec;

}

/**
 * The specification of the Kafka Bridge.
 *
 * @schema KafkaBridgeSpec
 */
export interface KafkaBridgeSpec {
  /**
   * The number of pods in the `Deployment`.
   *
   * @schema KafkaBridgeSpec#replicas
   */
  readonly replicas?: number;

  /**
   * The docker image for the pods.
   *
   * @schema KafkaBridgeSpec#image
   */
  readonly image?: string;

  /**
   * A list of host:port pairs for establishing the initial connection to the Kafka cluster.
   *
   * @schema KafkaBridgeSpec#bootstrapServers
   */
  readonly bootstrapServers: string;

  /**
   * TLS configuration for connecting Kafka Bridge to the cluster.
   *
   * @schema KafkaBridgeSpec#tls
   */
  readonly tls?: KafkaBridgeSpecTls;

  /**
   * Authentication configuration for connecting to the cluster.
   *
   * @schema KafkaBridgeSpec#authentication
   */
  readonly authentication?: KafkaBridgeSpecAuthentication;

  /**
   * The HTTP related configuration.
   *
   * @schema KafkaBridgeSpec#http
   */
  readonly http?: KafkaBridgeSpecHttp;

  /**
   * Kafka consumer related configuration.
   *
   * @schema KafkaBridgeSpec#consumer
   */
  readonly consumer?: KafkaBridgeSpecConsumer;

  /**
   * Kafka producer related configuration.
   *
   * @schema KafkaBridgeSpec#producer
   */
  readonly producer?: KafkaBridgeSpecProducer;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaBridgeSpec#resources
   */
  readonly resources?: KafkaBridgeSpecResources;

  /**
   * **Currently not supported** JVM Options for pods.
   *
   * @schema KafkaBridgeSpec#jvmOptions
   */
  readonly jvmOptions?: KafkaBridgeSpecJvmOptions;

  /**
   * Logging configuration for Kafka Bridge.
   *
   * @schema KafkaBridgeSpec#logging
   */
  readonly logging?: KafkaBridgeSpecLogging;

  /**
   * Enable the metrics for the Kafka Bridge. Default is false.
   *
   * @default false.
   * @schema KafkaBridgeSpec#enableMetrics
   */
  readonly enableMetrics?: boolean;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaBridgeSpec#livenessProbe
   */
  readonly livenessProbe?: KafkaBridgeSpecLivenessProbe;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaBridgeSpec#readinessProbe
   */
  readonly readinessProbe?: KafkaBridgeSpecReadinessProbe;

  /**
   * Template for Kafka Bridge resources. The template allows users to specify how is the `Deployment` and `Pods` generated.
   *
   * @schema KafkaBridgeSpec#template
   */
  readonly template?: KafkaBridgeSpecTemplate;

  /**
   * The configuration of tracing in Kafka Bridge.
   *
   * @schema KafkaBridgeSpec#tracing
   */
  readonly tracing?: KafkaBridgeSpecTracing;

}

/**
 * TLS configuration for connecting Kafka Bridge to the cluster.
 *
 * @schema KafkaBridgeSpecTls
 */
export interface KafkaBridgeSpecTls {
  /**
   * Trusted certificates for TLS connection.
   *
   * @schema KafkaBridgeSpecTls#trustedCertificates
   */
  readonly trustedCertificates?: KafkaBridgeSpecTlsTrustedCertificates[];

}

/**
 * Authentication configuration for connecting to the cluster.
 *
 * @schema KafkaBridgeSpecAuthentication
 */
export interface KafkaBridgeSpecAuthentication {
  /**
   * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
   *
   * @schema KafkaBridgeSpecAuthentication#accessToken
   */
  readonly accessToken?: KafkaBridgeSpecAuthenticationAccessToken;

  /**
   * Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
   *
   * @default true`.
   * @schema KafkaBridgeSpecAuthentication#accessTokenIsJwt
   */
  readonly accessTokenIsJwt?: boolean;

  /**
   * Reference to the `Secret` which holds the certificate and private key pair.
   *
   * @schema KafkaBridgeSpecAuthentication#certificateAndKey
   */
  readonly certificateAndKey?: KafkaBridgeSpecAuthenticationCertificateAndKey;

  /**
   * OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
   *
   * @schema KafkaBridgeSpecAuthentication#clientId
   */
  readonly clientId?: string;

  /**
   * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
   *
   * @schema KafkaBridgeSpecAuthentication#clientSecret
   */
  readonly clientSecret?: KafkaBridgeSpecAuthenticationClientSecret;

  /**
   * Enable or disable TLS hostname verification. Default value is `false`.
   *
   * @schema KafkaBridgeSpecAuthentication#disableTlsHostnameVerification
   */
  readonly disableTlsHostnameVerification?: boolean;

  /**
   * Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
   *
   * @schema KafkaBridgeSpecAuthentication#maxTokenExpirySeconds
   */
  readonly maxTokenExpirySeconds?: number;

  /**
   * Reference to the `Secret` which holds the password.
   *
   * @schema KafkaBridgeSpecAuthentication#passwordSecret
   */
  readonly passwordSecret?: KafkaBridgeSpecAuthenticationPasswordSecret;

  /**
   * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
   *
   * @schema KafkaBridgeSpecAuthentication#refreshToken
   */
  readonly refreshToken?: KafkaBridgeSpecAuthenticationRefreshToken;

  /**
   * OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
   *
   * @schema KafkaBridgeSpecAuthentication#scope
   */
  readonly scope?: string;

  /**
   * Trusted certificates for TLS connection to the OAuth server.
   *
   * @schema KafkaBridgeSpecAuthentication#tlsTrustedCertificates
   */
  readonly tlsTrustedCertificates?: KafkaBridgeSpecAuthenticationTlsTrustedCertificates[];

  /**
   * Authorization server token endpoint URI.
   *
   * @schema KafkaBridgeSpecAuthentication#tokenEndpointUri
   */
  readonly tokenEndpointUri?: string;

  /**
   * Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
   *
   * @schema KafkaBridgeSpecAuthentication#type
   */
  readonly type: KafkaBridgeSpecAuthenticationType;

  /**
   * Username used for the authentication.
   *
   * @schema KafkaBridgeSpecAuthentication#username
   */
  readonly username?: string;

}

/**
 * The HTTP related configuration.
 *
 * @schema KafkaBridgeSpecHttp
 */
export interface KafkaBridgeSpecHttp {
  /**
   * The port which is the server listening on.
   *
   * @schema KafkaBridgeSpecHttp#port
   */
  readonly port?: number;

  /**
   * CORS configuration for the HTTP Bridge.
   *
   * @schema KafkaBridgeSpecHttp#cors
   */
  readonly cors?: KafkaBridgeSpecHttpCors;

}

/**
 * Kafka consumer related configuration.
 *
 * @schema KafkaBridgeSpecConsumer
 */
export interface KafkaBridgeSpecConsumer {
  /**
   * The Kafka consumer configuration used for consumer instances created by the bridge. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, group.id, sasl., security. (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
   *
   * @schema KafkaBridgeSpecConsumer#config
   */
  readonly config?: any;

}

/**
 * Kafka producer related configuration.
 *
 * @schema KafkaBridgeSpecProducer
 */
export interface KafkaBridgeSpecProducer {
  /**
   * The Kafka producer configuration used for producer instances created by the bridge. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, sasl., security. (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
   *
   * @schema KafkaBridgeSpecProducer#config
   */
  readonly config?: any;

}

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaBridgeSpecResources
 */
export interface KafkaBridgeSpecResources {
  /**
   * @schema KafkaBridgeSpecResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaBridgeSpecResources#requests
   */
  readonly requests?: any;

}

/**
 * **Currently not supported** JVM Options for pods.
 *
 * @schema KafkaBridgeSpecJvmOptions
 */
export interface KafkaBridgeSpecJvmOptions {
  /**
   * A map of -XX options to the JVM.
   *
   * @schema KafkaBridgeSpecJvmOptions#-XX
   */
  readonly xx?: any;

  /**
   * -Xms option to to the JVM.
   *
   * @schema KafkaBridgeSpecJvmOptions#-Xms
   */
  readonly xms?: string;

  /**
   * -Xmx option to to the JVM.
   *
   * @schema KafkaBridgeSpecJvmOptions#-Xmx
   */
  readonly xmx?: string;

  /**
   * Specifies whether the Garbage Collection logging is enabled. The default is false.
   *
   * @schema KafkaBridgeSpecJvmOptions#gcLoggingEnabled
   */
  readonly gcLoggingEnabled?: boolean;

  /**
   * A map of additional system properties which will be passed using the `-D` option to the JVM.
   *
   * @schema KafkaBridgeSpecJvmOptions#javaSystemProperties
   */
  readonly javaSystemProperties?: KafkaBridgeSpecJvmOptionsJavaSystemProperties[];

}

/**
 * Logging configuration for Kafka Bridge.
 *
 * @schema KafkaBridgeSpecLogging
 */
export interface KafkaBridgeSpecLogging {
  /**
   * A Map from logger name to logger level.
   *
   * @schema KafkaBridgeSpecLogging#loggers
   */
  readonly loggers?: any;

  /**
   * The name of the `ConfigMap` from which to get the logging configuration.
   *
   * @schema KafkaBridgeSpecLogging#name
   */
  readonly name?: string;

  /**
   * Logging type, must be either 'inline' or 'external'.
   *
   * @schema KafkaBridgeSpecLogging#type
   */
  readonly type: KafkaBridgeSpecLoggingType;

}

/**
 * Pod liveness checking.
 *
 * @schema KafkaBridgeSpecLivenessProbe
 */
export interface KafkaBridgeSpecLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaBridgeSpecLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaBridgeSpecLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaBridgeSpecLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaBridgeSpecLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaBridgeSpecLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Pod readiness checking.
 *
 * @schema KafkaBridgeSpecReadinessProbe
 */
export interface KafkaBridgeSpecReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaBridgeSpecReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaBridgeSpecReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaBridgeSpecReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaBridgeSpecReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaBridgeSpecReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Template for Kafka Bridge resources. The template allows users to specify how is the `Deployment` and `Pods` generated.
 *
 * @schema KafkaBridgeSpecTemplate
 */
export interface KafkaBridgeSpecTemplate {
  /**
   * Template for Kafka Bridge `Deployment`.
   *
   * @schema KafkaBridgeSpecTemplate#deployment
   */
  readonly deployment?: KafkaBridgeSpecTemplateDeployment;

  /**
   * Template for Kafka Bridge `Pods`.
   *
   * @schema KafkaBridgeSpecTemplate#pod
   */
  readonly pod?: KafkaBridgeSpecTemplatePod;

  /**
   * Template for Kafka Bridge API `Service`.
   *
   * @schema KafkaBridgeSpecTemplate#apiService
   */
  readonly apiService?: KafkaBridgeSpecTemplateApiService;

  /**
   * Template for the Kafka Bridge container.
   *
   * @schema KafkaBridgeSpecTemplate#bridgeContainer
   */
  readonly bridgeContainer?: KafkaBridgeSpecTemplateBridgeContainer;

  /**
   * Template for Kafka Bridge `PodDisruptionBudget`.
   *
   * @schema KafkaBridgeSpecTemplate#podDisruptionBudget
   */
  readonly podDisruptionBudget?: KafkaBridgeSpecTemplatePodDisruptionBudget;

}

/**
 * The configuration of tracing in Kafka Bridge.
 *
 * @schema KafkaBridgeSpecTracing
 */
export interface KafkaBridgeSpecTracing {
  /**
   * Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
   *
   * @schema KafkaBridgeSpecTracing#type
   */
  readonly type: KafkaBridgeSpecTracingType;

}

/**
 * @schema KafkaBridgeSpecTlsTrustedCertificates
 */
export interface KafkaBridgeSpecTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaBridgeSpecTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaBridgeSpecTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
 *
 * @schema KafkaBridgeSpecAuthenticationAccessToken
 */
export interface KafkaBridgeSpecAuthenticationAccessToken {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaBridgeSpecAuthenticationAccessToken#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaBridgeSpecAuthenticationAccessToken#secretName
   */
  readonly secretName: string;

}

/**
 * Reference to the `Secret` which holds the certificate and private key pair.
 *
 * @schema KafkaBridgeSpecAuthenticationCertificateAndKey
 */
export interface KafkaBridgeSpecAuthenticationCertificateAndKey {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaBridgeSpecAuthenticationCertificateAndKey#certificate
   */
  readonly certificate: string;

  /**
   * The name of the private key in the Secret.
   *
   * @schema KafkaBridgeSpecAuthenticationCertificateAndKey#key
   */
  readonly key: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaBridgeSpecAuthenticationCertificateAndKey#secretName
   */
  readonly secretName: string;

}

/**
 * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
 *
 * @schema KafkaBridgeSpecAuthenticationClientSecret
 */
export interface KafkaBridgeSpecAuthenticationClientSecret {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaBridgeSpecAuthenticationClientSecret#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaBridgeSpecAuthenticationClientSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Reference to the `Secret` which holds the password.
 *
 * @schema KafkaBridgeSpecAuthenticationPasswordSecret
 */
export interface KafkaBridgeSpecAuthenticationPasswordSecret {
  /**
   * The name of the key in the Secret under which the password is stored.
   *
   * @schema KafkaBridgeSpecAuthenticationPasswordSecret#password
   */
  readonly password: string;

  /**
   * The name of the Secret containing the password.
   *
   * @schema KafkaBridgeSpecAuthenticationPasswordSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
 *
 * @schema KafkaBridgeSpecAuthenticationRefreshToken
 */
export interface KafkaBridgeSpecAuthenticationRefreshToken {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaBridgeSpecAuthenticationRefreshToken#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaBridgeSpecAuthenticationRefreshToken#secretName
   */
  readonly secretName: string;

}

/**
 * @schema KafkaBridgeSpecAuthenticationTlsTrustedCertificates
 */
export interface KafkaBridgeSpecAuthenticationTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaBridgeSpecAuthenticationTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaBridgeSpecAuthenticationTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
 *
 * @schema KafkaBridgeSpecAuthenticationType
 */
export enum KafkaBridgeSpecAuthenticationType {
  /** tls */
  TLS = "tls",
  /** scram-sha-512 */
  SCRAM_SHA_512 = "scram-sha-512",
  /** plain */
  PLAIN = "plain",
  /** oauth */
  OAUTH = "oauth",
}

/**
 * CORS configuration for the HTTP Bridge.
 *
 * @schema KafkaBridgeSpecHttpCors
 */
export interface KafkaBridgeSpecHttpCors {
  /**
   * List of allowed origins. Java regular expressions can be used.
   *
   * @schema KafkaBridgeSpecHttpCors#allowedOrigins
   */
  readonly allowedOrigins: string[];

  /**
   * List of allowed HTTP methods.
   *
   * @schema KafkaBridgeSpecHttpCors#allowedMethods
   */
  readonly allowedMethods: string[];

}

/**
 * @schema KafkaBridgeSpecJvmOptionsJavaSystemProperties
 */
export interface KafkaBridgeSpecJvmOptionsJavaSystemProperties {
  /**
   * The system property name.
   *
   * @schema KafkaBridgeSpecJvmOptionsJavaSystemProperties#name
   */
  readonly name?: string;

  /**
   * The system property value.
   *
   * @schema KafkaBridgeSpecJvmOptionsJavaSystemProperties#value
   */
  readonly value?: string;

}

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaBridgeSpecLoggingType
 */
export enum KafkaBridgeSpecLoggingType {
  /** inline */
  INLINE = "inline",
  /** external */
  EXTERNAL = "external",
}

/**
 * Template for Kafka Bridge `Deployment`.
 *
 * @schema KafkaBridgeSpecTemplateDeployment
 */
export interface KafkaBridgeSpecTemplateDeployment {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaBridgeSpecTemplateDeployment#metadata
   */
  readonly metadata?: KafkaBridgeSpecTemplateDeploymentMetadata;

}

/**
 * Template for Kafka Bridge `Pods`.
 *
 * @schema KafkaBridgeSpecTemplatePod
 */
export interface KafkaBridgeSpecTemplatePod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaBridgeSpecTemplatePod#metadata
   */
  readonly metadata?: KafkaBridgeSpecTemplatePodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaBridgeSpecTemplatePod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaBridgeSpecTemplatePodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaBridgeSpecTemplatePod#securityContext
   */
  readonly securityContext?: KafkaBridgeSpecTemplatePodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaBridgeSpecTemplatePod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaBridgeSpecTemplatePod#affinity
   */
  readonly affinity?: KafkaBridgeSpecTemplatePodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaBridgeSpecTemplatePod#tolerations
   */
  readonly tolerations?: KafkaBridgeSpecTemplatePodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaBridgeSpecTemplatePod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaBridgeSpecTemplatePod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
   *
   * @schema KafkaBridgeSpecTemplatePod#hostAliases
   */
  readonly hostAliases?: KafkaBridgeSpecTemplatePodHostAliases[];

}

/**
 * Template for Kafka Bridge API `Service`.
 *
 * @schema KafkaBridgeSpecTemplateApiService
 */
export interface KafkaBridgeSpecTemplateApiService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaBridgeSpecTemplateApiService#metadata
   */
  readonly metadata?: KafkaBridgeSpecTemplateApiServiceMetadata;

}

/**
 * Template for the Kafka Bridge container.
 *
 * @schema KafkaBridgeSpecTemplateBridgeContainer
 */
export interface KafkaBridgeSpecTemplateBridgeContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaBridgeSpecTemplateBridgeContainer#env
   */
  readonly env?: KafkaBridgeSpecTemplateBridgeContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaBridgeSpecTemplateBridgeContainer#securityContext
   */
  readonly securityContext?: KafkaBridgeSpecTemplateBridgeContainerSecurityContext;

}

/**
 * Template for Kafka Bridge `PodDisruptionBudget`.
 *
 * @schema KafkaBridgeSpecTemplatePodDisruptionBudget
 */
export interface KafkaBridgeSpecTemplatePodDisruptionBudget {
  /**
   * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
   *
   * @schema KafkaBridgeSpecTemplatePodDisruptionBudget#metadata
   */
  readonly metadata?: KafkaBridgeSpecTemplatePodDisruptionBudgetMetadata;

  /**
   * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
   *
   * @default 1.
   * @schema KafkaBridgeSpecTemplatePodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: number;

}

/**
 * Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
 *
 * @schema KafkaBridgeSpecTracingType
 */
export enum KafkaBridgeSpecTracingType {
  /** jaeger */
  JAEGER = "jaeger",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaBridgeSpecTemplateDeploymentMetadata
 */
export interface KafkaBridgeSpecTemplateDeploymentMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaBridgeSpecTemplateDeploymentMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaBridgeSpecTemplateDeploymentMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaBridgeSpecTemplatePodMetadata
 */
export interface KafkaBridgeSpecTemplatePodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaBridgeSpecTemplatePodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaBridgeSpecTemplatePodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaBridgeSpecTemplatePodImagePullSecrets
 */
export interface KafkaBridgeSpecTemplatePodImagePullSecrets {
  /**
   * @schema KafkaBridgeSpecTemplatePodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaBridgeSpecTemplatePodSecurityContext
 */
export interface KafkaBridgeSpecTemplatePodSecurityContext {
  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaBridgeSpecTemplatePodSecurityContextSysctls[];

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions;

}

/**
 * The pod's affinity rules.
 *
 * @schema KafkaBridgeSpecTemplatePodAffinity
 */
export interface KafkaBridgeSpecTemplatePodAffinity {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaBridgeSpecTemplatePodAffinityNodeAffinity;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaBridgeSpecTemplatePodAffinityPodAffinity;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinity;

}

/**
 * @schema KafkaBridgeSpecTemplatePodTolerations
 */
export interface KafkaBridgeSpecTemplatePodTolerations {
  /**
   * @schema KafkaBridgeSpecTemplatePodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaBridgeSpecTemplatePodTolerations#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaBridgeSpecTemplatePodHostAliases
 */
export interface KafkaBridgeSpecTemplatePodHostAliases {
  /**
   * @schema KafkaBridgeSpecTemplatePodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaBridgeSpecTemplatePodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaBridgeSpecTemplateApiServiceMetadata
 */
export interface KafkaBridgeSpecTemplateApiServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaBridgeSpecTemplateApiServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaBridgeSpecTemplateApiServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaBridgeSpecTemplateBridgeContainerEnv
 */
export interface KafkaBridgeSpecTemplateBridgeContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaBridgeSpecTemplateBridgeContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaBridgeSpecTemplateBridgeContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext
 */
export interface KafkaBridgeSpecTemplateBridgeContainerSecurityContext {
  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaBridgeSpecTemplateBridgeContainerSecurityContextCapabilities;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions;

}

/**
 * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
 *
 * @schema KafkaBridgeSpecTemplatePodDisruptionBudgetMetadata
 */
export interface KafkaBridgeSpecTemplatePodDisruptionBudgetMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaBridgeSpecTemplatePodDisruptionBudgetMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaBridgeSpecTemplatePodDisruptionBudgetMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaBridgeSpecTemplatePodSecurityContextSysctls
 */
export interface KafkaBridgeSpecTemplatePodSecurityContextSysctls {
  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions {
  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinity
 */
export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinity {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinity
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAffinity {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinity {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextCapabilities
 */
export interface KafkaBridgeSpecTemplateBridgeContainerSecurityContextCapabilities {
  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions
 */
export interface KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions
 */
export interface KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaBridgeSpecTemplateBridgeContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaBridgeSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * 
 *
 * @schema KafkaConnect
 */
export class KafkaConnect extends ApiObject {
  /**
   * Returns the apiVersion and kind for "KafkaConnect"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kafka.strimzi.io/v1beta1',
    kind: 'KafkaConnect',
  }

  /**
   * Renders a Kubernetes manifest for "KafkaConnect".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KafkaConnectProps = {}): any {
    return {
      ...KafkaConnect.GVK,
      ...props,
    };
  }

  /**
   * Defines a "KafkaConnect" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KafkaConnectProps = {}) {
    super(scope, id, KafkaConnect.manifest(props));
  }
}

/**
 * @schema KafkaConnect
 */
export interface KafkaConnectProps {
  /**
   * The specification of the Kafka Connect cluster.
   *
   * @schema KafkaConnect#spec
   */
  readonly spec?: KafkaConnectSpec;

}

/**
 * The specification of the Kafka Connect cluster.
 *
 * @schema KafkaConnectSpec
 */
export interface KafkaConnectSpec {
  /**
   * The number of pods in the Kafka Connect group.
   *
   * @schema KafkaConnectSpec#replicas
   */
  readonly replicas?: number;

  /**
   * The Kafka Connect version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
   *
   * @default DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
   * @schema KafkaConnectSpec#version
   */
  readonly version?: string;

  /**
   * The docker image for the pods.
   *
   * @schema KafkaConnectSpec#image
   */
  readonly image?: string;

  /**
   * Bootstrap servers to connect to. This should be given as a comma separated list of _<hostname>_:_<port>_ pairs.
   *
   * @schema KafkaConnectSpec#bootstrapServers
   */
  readonly bootstrapServers: string;

  /**
   * TLS configuration.
   *
   * @schema KafkaConnectSpec#tls
   */
  readonly tls?: KafkaConnectSpecTls;

  /**
   * Authentication configuration for Kafka Connect.
   *
   * @schema KafkaConnectSpec#authentication
   */
  readonly authentication?: KafkaConnectSpecAuthentication;

  /**
   * The Kafka Connect configuration. Properties with the following prefixes cannot be set: ssl., sasl., security., listeners, plugin.path, rest., bootstrap.servers, consumer.interceptor.classes, producer.interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
   *
   * @schema KafkaConnectSpec#config
   */
  readonly config?: any;

  /**
   * The maximum limits for CPU and memory resources and the requested initial resources.
   *
   * @schema KafkaConnectSpec#resources
   */
  readonly resources?: KafkaConnectSpecResources;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaConnectSpec#livenessProbe
   */
  readonly livenessProbe?: KafkaConnectSpecLivenessProbe;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaConnectSpec#readinessProbe
   */
  readonly readinessProbe?: KafkaConnectSpecReadinessProbe;

  /**
   * JVM Options for pods.
   *
   * @schema KafkaConnectSpec#jvmOptions
   */
  readonly jvmOptions?: KafkaConnectSpecJvmOptions;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaConnectSpec#affinity
   */
  readonly affinity?: KafkaConnectSpecAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaConnectSpec#tolerations
   */
  readonly tolerations?: KafkaConnectSpecTolerations[];

  /**
   * Logging configuration for Kafka Connect.
   *
   * @schema KafkaConnectSpec#logging
   */
  readonly logging?: KafkaConnectSpecLogging;

  /**
   * The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
   *
   * @schema KafkaConnectSpec#metrics
   */
  readonly metrics?: any;

  /**
   * The configuration of tracing in Kafka Connect.
   *
   * @schema KafkaConnectSpec#tracing
   */
  readonly tracing?: KafkaConnectSpecTracing;

  /**
   * Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
   *
   * @schema KafkaConnectSpec#template
   */
  readonly template?: KafkaConnectSpecTemplate;

  /**
   * Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
   *
   * @schema KafkaConnectSpec#externalConfiguration
   */
  readonly externalConfiguration?: KafkaConnectSpecExternalConfiguration;

  /**
   * The image of the init container used for initializing the `client.rack`.
   *
   * @schema KafkaConnectSpec#clientRackInitImage
   */
  readonly clientRackInitImage?: string;

  /**
   * Configuration of the node label which will be used as the client.rack consumer configuration.
   *
   * @schema KafkaConnectSpec#rack
   */
  readonly rack?: KafkaConnectSpecRack;

}

/**
 * TLS configuration.
 *
 * @schema KafkaConnectSpecTls
 */
export interface KafkaConnectSpecTls {
  /**
   * Trusted certificates for TLS connection.
   *
   * @schema KafkaConnectSpecTls#trustedCertificates
   */
  readonly trustedCertificates?: KafkaConnectSpecTlsTrustedCertificates[];

}

/**
 * Authentication configuration for Kafka Connect.
 *
 * @schema KafkaConnectSpecAuthentication
 */
export interface KafkaConnectSpecAuthentication {
  /**
   * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
   *
   * @schema KafkaConnectSpecAuthentication#accessToken
   */
  readonly accessToken?: KafkaConnectSpecAuthenticationAccessToken;

  /**
   * Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
   *
   * @default true`.
   * @schema KafkaConnectSpecAuthentication#accessTokenIsJwt
   */
  readonly accessTokenIsJwt?: boolean;

  /**
   * Reference to the `Secret` which holds the certificate and private key pair.
   *
   * @schema KafkaConnectSpecAuthentication#certificateAndKey
   */
  readonly certificateAndKey?: KafkaConnectSpecAuthenticationCertificateAndKey;

  /**
   * OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
   *
   * @schema KafkaConnectSpecAuthentication#clientId
   */
  readonly clientId?: string;

  /**
   * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
   *
   * @schema KafkaConnectSpecAuthentication#clientSecret
   */
  readonly clientSecret?: KafkaConnectSpecAuthenticationClientSecret;

  /**
   * Enable or disable TLS hostname verification. Default value is `false`.
   *
   * @schema KafkaConnectSpecAuthentication#disableTlsHostnameVerification
   */
  readonly disableTlsHostnameVerification?: boolean;

  /**
   * Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
   *
   * @schema KafkaConnectSpecAuthentication#maxTokenExpirySeconds
   */
  readonly maxTokenExpirySeconds?: number;

  /**
   * Reference to the `Secret` which holds the password.
   *
   * @schema KafkaConnectSpecAuthentication#passwordSecret
   */
  readonly passwordSecret?: KafkaConnectSpecAuthenticationPasswordSecret;

  /**
   * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
   *
   * @schema KafkaConnectSpecAuthentication#refreshToken
   */
  readonly refreshToken?: KafkaConnectSpecAuthenticationRefreshToken;

  /**
   * OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
   *
   * @schema KafkaConnectSpecAuthentication#scope
   */
  readonly scope?: string;

  /**
   * Trusted certificates for TLS connection to the OAuth server.
   *
   * @schema KafkaConnectSpecAuthentication#tlsTrustedCertificates
   */
  readonly tlsTrustedCertificates?: KafkaConnectSpecAuthenticationTlsTrustedCertificates[];

  /**
   * Authorization server token endpoint URI.
   *
   * @schema KafkaConnectSpecAuthentication#tokenEndpointUri
   */
  readonly tokenEndpointUri?: string;

  /**
   * Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
   *
   * @schema KafkaConnectSpecAuthentication#type
   */
  readonly type: KafkaConnectSpecAuthenticationType;

  /**
   * Username used for the authentication.
   *
   * @schema KafkaConnectSpecAuthentication#username
   */
  readonly username?: string;

}

/**
 * The maximum limits for CPU and memory resources and the requested initial resources.
 *
 * @schema KafkaConnectSpecResources
 */
export interface KafkaConnectSpecResources {
  /**
   * @schema KafkaConnectSpecResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaConnectSpecResources#requests
   */
  readonly requests?: any;

}

/**
 * Pod liveness checking.
 *
 * @schema KafkaConnectSpecLivenessProbe
 */
export interface KafkaConnectSpecLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaConnectSpecLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaConnectSpecLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaConnectSpecLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaConnectSpecLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaConnectSpecLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Pod readiness checking.
 *
 * @schema KafkaConnectSpecReadinessProbe
 */
export interface KafkaConnectSpecReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaConnectSpecReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaConnectSpecReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaConnectSpecReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaConnectSpecReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaConnectSpecReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * JVM Options for pods.
 *
 * @schema KafkaConnectSpecJvmOptions
 */
export interface KafkaConnectSpecJvmOptions {
  /**
   * A map of -XX options to the JVM.
   *
   * @schema KafkaConnectSpecJvmOptions#-XX
   */
  readonly xx?: any;

  /**
   * -Xms option to to the JVM.
   *
   * @schema KafkaConnectSpecJvmOptions#-Xms
   */
  readonly xms?: string;

  /**
   * -Xmx option to to the JVM.
   *
   * @schema KafkaConnectSpecJvmOptions#-Xmx
   */
  readonly xmx?: string;

  /**
   * Specifies whether the Garbage Collection logging is enabled. The default is false.
   *
   * @schema KafkaConnectSpecJvmOptions#gcLoggingEnabled
   */
  readonly gcLoggingEnabled?: boolean;

  /**
   * A map of additional system properties which will be passed using the `-D` option to the JVM.
   *
   * @schema KafkaConnectSpecJvmOptions#javaSystemProperties
   */
  readonly javaSystemProperties?: KafkaConnectSpecJvmOptionsJavaSystemProperties[];

}

/**
 * The pod's affinity rules.
 *
 * @schema KafkaConnectSpecAffinity
 */
export interface KafkaConnectSpecAffinity {
  /**
   * @schema KafkaConnectSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaConnectSpecAffinityNodeAffinity;

  /**
   * @schema KafkaConnectSpecAffinity#podAffinity
   */
  readonly podAffinity?: KafkaConnectSpecAffinityPodAffinity;

  /**
   * @schema KafkaConnectSpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaConnectSpecAffinityPodAntiAffinity;

}

/**
 * @schema KafkaConnectSpecTolerations
 */
export interface KafkaConnectSpecTolerations {
  /**
   * @schema KafkaConnectSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaConnectSpecTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaConnectSpecTolerations#value
   */
  readonly value?: string;

}

/**
 * Logging configuration for Kafka Connect.
 *
 * @schema KafkaConnectSpecLogging
 */
export interface KafkaConnectSpecLogging {
  /**
   * A Map from logger name to logger level.
   *
   * @schema KafkaConnectSpecLogging#loggers
   */
  readonly loggers?: any;

  /**
   * The name of the `ConfigMap` from which to get the logging configuration.
   *
   * @schema KafkaConnectSpecLogging#name
   */
  readonly name?: string;

  /**
   * Logging type, must be either 'inline' or 'external'.
   *
   * @schema KafkaConnectSpecLogging#type
   */
  readonly type: KafkaConnectSpecLoggingType;

}

/**
 * The configuration of tracing in Kafka Connect.
 *
 * @schema KafkaConnectSpecTracing
 */
export interface KafkaConnectSpecTracing {
  /**
   * Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
   *
   * @schema KafkaConnectSpecTracing#type
   */
  readonly type: KafkaConnectSpecTracingType;

}

/**
 * Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
 *
 * @schema KafkaConnectSpecTemplate
 */
export interface KafkaConnectSpecTemplate {
  /**
   * Template for Kafka Connect `Deployment`.
   *
   * @schema KafkaConnectSpecTemplate#deployment
   */
  readonly deployment?: KafkaConnectSpecTemplateDeployment;

  /**
   * Template for Kafka Connect `Pods`.
   *
   * @schema KafkaConnectSpecTemplate#pod
   */
  readonly pod?: KafkaConnectSpecTemplatePod;

  /**
   * Template for Kafka Connect API `Service`.
   *
   * @schema KafkaConnectSpecTemplate#apiService
   */
  readonly apiService?: KafkaConnectSpecTemplateApiService;

  /**
   * Template for the Kafka Connect container.
   *
   * @schema KafkaConnectSpecTemplate#connectContainer
   */
  readonly connectContainer?: KafkaConnectSpecTemplateConnectContainer;

  /**
   * Template for the Kafka init container.
   *
   * @schema KafkaConnectSpecTemplate#initContainer
   */
  readonly initContainer?: KafkaConnectSpecTemplateInitContainer;

  /**
   * Template for Kafka Connect `PodDisruptionBudget`.
   *
   * @schema KafkaConnectSpecTemplate#podDisruptionBudget
   */
  readonly podDisruptionBudget?: KafkaConnectSpecTemplatePodDisruptionBudget;

}

/**
 * Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
 *
 * @schema KafkaConnectSpecExternalConfiguration
 */
export interface KafkaConnectSpecExternalConfiguration {
  /**
   * Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as environment variables.
   *
   * @schema KafkaConnectSpecExternalConfiguration#env
   */
  readonly env?: KafkaConnectSpecExternalConfigurationEnv[];

  /**
   * Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as volumes.
   *
   * @schema KafkaConnectSpecExternalConfiguration#volumes
   */
  readonly volumes?: KafkaConnectSpecExternalConfigurationVolumes[];

}

/**
 * Configuration of the node label which will be used as the client.rack consumer configuration.
 *
 * @schema KafkaConnectSpecRack
 */
export interface KafkaConnectSpecRack {
  /**
   * A key that matches labels assigned to the Kubernetes cluster nodes. The value of the label is used to set the broker's `broker.rack` config.
   *
   * @schema KafkaConnectSpecRack#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * @schema KafkaConnectSpecTlsTrustedCertificates
 */
export interface KafkaConnectSpecTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaConnectSpecTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaConnectSpecTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
 *
 * @schema KafkaConnectSpecAuthenticationAccessToken
 */
export interface KafkaConnectSpecAuthenticationAccessToken {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaConnectSpecAuthenticationAccessToken#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaConnectSpecAuthenticationAccessToken#secretName
   */
  readonly secretName: string;

}

/**
 * Reference to the `Secret` which holds the certificate and private key pair.
 *
 * @schema KafkaConnectSpecAuthenticationCertificateAndKey
 */
export interface KafkaConnectSpecAuthenticationCertificateAndKey {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaConnectSpecAuthenticationCertificateAndKey#certificate
   */
  readonly certificate: string;

  /**
   * The name of the private key in the Secret.
   *
   * @schema KafkaConnectSpecAuthenticationCertificateAndKey#key
   */
  readonly key: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaConnectSpecAuthenticationCertificateAndKey#secretName
   */
  readonly secretName: string;

}

/**
 * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
 *
 * @schema KafkaConnectSpecAuthenticationClientSecret
 */
export interface KafkaConnectSpecAuthenticationClientSecret {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaConnectSpecAuthenticationClientSecret#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaConnectSpecAuthenticationClientSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Reference to the `Secret` which holds the password.
 *
 * @schema KafkaConnectSpecAuthenticationPasswordSecret
 */
export interface KafkaConnectSpecAuthenticationPasswordSecret {
  /**
   * The name of the key in the Secret under which the password is stored.
   *
   * @schema KafkaConnectSpecAuthenticationPasswordSecret#password
   */
  readonly password: string;

  /**
   * The name of the Secret containing the password.
   *
   * @schema KafkaConnectSpecAuthenticationPasswordSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
 *
 * @schema KafkaConnectSpecAuthenticationRefreshToken
 */
export interface KafkaConnectSpecAuthenticationRefreshToken {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaConnectSpecAuthenticationRefreshToken#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaConnectSpecAuthenticationRefreshToken#secretName
   */
  readonly secretName: string;

}

/**
 * @schema KafkaConnectSpecAuthenticationTlsTrustedCertificates
 */
export interface KafkaConnectSpecAuthenticationTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaConnectSpecAuthenticationTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaConnectSpecAuthenticationTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
 *
 * @schema KafkaConnectSpecAuthenticationType
 */
export enum KafkaConnectSpecAuthenticationType {
  /** tls */
  TLS = "tls",
  /** scram-sha-512 */
  SCRAM_SHA_512 = "scram-sha-512",
  /** plain */
  PLAIN = "plain",
  /** oauth */
  OAUTH = "oauth",
}

/**
 * @schema KafkaConnectSpecJvmOptionsJavaSystemProperties
 */
export interface KafkaConnectSpecJvmOptionsJavaSystemProperties {
  /**
   * The system property name.
   *
   * @schema KafkaConnectSpecJvmOptionsJavaSystemProperties#name
   */
  readonly name?: string;

  /**
   * The system property value.
   *
   * @schema KafkaConnectSpecJvmOptionsJavaSystemProperties#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaConnectSpecAffinityNodeAffinity
 */
export interface KafkaConnectSpecAffinityNodeAffinity {
  /**
   * @schema KafkaConnectSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaConnectSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaConnectSpecAffinityPodAffinity
 */
export interface KafkaConnectSpecAffinityPodAffinity {
  /**
   * @schema KafkaConnectSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaConnectSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaConnectSpecAffinityPodAntiAffinity
 */
export interface KafkaConnectSpecAffinityPodAntiAffinity {
  /**
   * @schema KafkaConnectSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaConnectSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaConnectSpecLoggingType
 */
export enum KafkaConnectSpecLoggingType {
  /** inline */
  INLINE = "inline",
  /** external */
  EXTERNAL = "external",
}

/**
 * Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
 *
 * @schema KafkaConnectSpecTracingType
 */
export enum KafkaConnectSpecTracingType {
  /** jaeger */
  JAEGER = "jaeger",
}

/**
 * Template for Kafka Connect `Deployment`.
 *
 * @schema KafkaConnectSpecTemplateDeployment
 */
export interface KafkaConnectSpecTemplateDeployment {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaConnectSpecTemplateDeployment#metadata
   */
  readonly metadata?: KafkaConnectSpecTemplateDeploymentMetadata;

}

/**
 * Template for Kafka Connect `Pods`.
 *
 * @schema KafkaConnectSpecTemplatePod
 */
export interface KafkaConnectSpecTemplatePod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaConnectSpecTemplatePod#metadata
   */
  readonly metadata?: KafkaConnectSpecTemplatePodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaConnectSpecTemplatePod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaConnectSpecTemplatePodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaConnectSpecTemplatePod#securityContext
   */
  readonly securityContext?: KafkaConnectSpecTemplatePodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaConnectSpecTemplatePod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaConnectSpecTemplatePod#affinity
   */
  readonly affinity?: KafkaConnectSpecTemplatePodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaConnectSpecTemplatePod#tolerations
   */
  readonly tolerations?: KafkaConnectSpecTemplatePodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaConnectSpecTemplatePod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaConnectSpecTemplatePod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
   *
   * @schema KafkaConnectSpecTemplatePod#hostAliases
   */
  readonly hostAliases?: KafkaConnectSpecTemplatePodHostAliases[];

}

/**
 * Template for Kafka Connect API `Service`.
 *
 * @schema KafkaConnectSpecTemplateApiService
 */
export interface KafkaConnectSpecTemplateApiService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaConnectSpecTemplateApiService#metadata
   */
  readonly metadata?: KafkaConnectSpecTemplateApiServiceMetadata;

}

/**
 * Template for the Kafka Connect container.
 *
 * @schema KafkaConnectSpecTemplateConnectContainer
 */
export interface KafkaConnectSpecTemplateConnectContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaConnectSpecTemplateConnectContainer#env
   */
  readonly env?: KafkaConnectSpecTemplateConnectContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaConnectSpecTemplateConnectContainer#securityContext
   */
  readonly securityContext?: KafkaConnectSpecTemplateConnectContainerSecurityContext;

}

/**
 * Template for the Kafka init container.
 *
 * @schema KafkaConnectSpecTemplateInitContainer
 */
export interface KafkaConnectSpecTemplateInitContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaConnectSpecTemplateInitContainer#env
   */
  readonly env?: KafkaConnectSpecTemplateInitContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaConnectSpecTemplateInitContainer#securityContext
   */
  readonly securityContext?: KafkaConnectSpecTemplateInitContainerSecurityContext;

}

/**
 * Template for Kafka Connect `PodDisruptionBudget`.
 *
 * @schema KafkaConnectSpecTemplatePodDisruptionBudget
 */
export interface KafkaConnectSpecTemplatePodDisruptionBudget {
  /**
   * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
   *
   * @schema KafkaConnectSpecTemplatePodDisruptionBudget#metadata
   */
  readonly metadata?: KafkaConnectSpecTemplatePodDisruptionBudgetMetadata;

  /**
   * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
   *
   * @default 1.
   * @schema KafkaConnectSpecTemplatePodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: number;

}

/**
 * @schema KafkaConnectSpecExternalConfigurationEnv
 */
export interface KafkaConnectSpecExternalConfigurationEnv {
  /**
   * Name of the environment variable which will be passed to the Kafka Connect pods. The name of the environment variable cannot start with `KAFKA_` or `STRIMZI_`.
   *
   * @schema KafkaConnectSpecExternalConfigurationEnv#name
   */
  readonly name: string;

  /**
   * Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
   *
   * @schema KafkaConnectSpecExternalConfigurationEnv#valueFrom
   */
  readonly valueFrom: KafkaConnectSpecExternalConfigurationEnvValueFrom;

}

/**
 * @schema KafkaConnectSpecExternalConfigurationVolumes
 */
export interface KafkaConnectSpecExternalConfigurationVolumes {
  /**
   * Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
   *
   * @schema KafkaConnectSpecExternalConfigurationVolumes#configMap
   */
  readonly configMap?: KafkaConnectSpecExternalConfigurationVolumesConfigMap;

  /**
   * Name of the volume which will be added to the Kafka Connect pods.
   *
   * @schema KafkaConnectSpecExternalConfigurationVolumes#name
   */
  readonly name: string;

  /**
   * Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
   *
   * @schema KafkaConnectSpecExternalConfigurationVolumes#secret
   */
  readonly secret?: KafkaConnectSpecExternalConfigurationVolumesSecret;

}

/**
 * @schema KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaConnectSpecTemplateDeploymentMetadata
 */
export interface KafkaConnectSpecTemplateDeploymentMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectSpecTemplateDeploymentMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectSpecTemplateDeploymentMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaConnectSpecTemplatePodMetadata
 */
export interface KafkaConnectSpecTemplatePodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectSpecTemplatePodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectSpecTemplatePodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaConnectSpecTemplatePodImagePullSecrets
 */
export interface KafkaConnectSpecTemplatePodImagePullSecrets {
  /**
   * @schema KafkaConnectSpecTemplatePodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaConnectSpecTemplatePodSecurityContext
 */
export interface KafkaConnectSpecTemplatePodSecurityContext {
  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaConnectSpecTemplatePodSecurityContextSysctls[];

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaConnectSpecTemplatePodSecurityContextWindowsOptions;

}

/**
 * The pod's affinity rules.
 *
 * @schema KafkaConnectSpecTemplatePodAffinity
 */
export interface KafkaConnectSpecTemplatePodAffinity {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaConnectSpecTemplatePodAffinityNodeAffinity;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaConnectSpecTemplatePodAffinityPodAffinity;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinity;

}

/**
 * @schema KafkaConnectSpecTemplatePodTolerations
 */
export interface KafkaConnectSpecTemplatePodTolerations {
  /**
   * @schema KafkaConnectSpecTemplatePodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaConnectSpecTemplatePodTolerations#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaConnectSpecTemplatePodHostAliases
 */
export interface KafkaConnectSpecTemplatePodHostAliases {
  /**
   * @schema KafkaConnectSpecTemplatePodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaConnectSpecTemplatePodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaConnectSpecTemplateApiServiceMetadata
 */
export interface KafkaConnectSpecTemplateApiServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectSpecTemplateApiServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectSpecTemplateApiServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaConnectSpecTemplateConnectContainerEnv
 */
export interface KafkaConnectSpecTemplateConnectContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaConnectSpecTemplateConnectContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaConnectSpecTemplateConnectContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext
 */
export interface KafkaConnectSpecTemplateConnectContainerSecurityContext {
  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions;

}

/**
 * @schema KafkaConnectSpecTemplateInitContainerEnv
 */
export interface KafkaConnectSpecTemplateInitContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaConnectSpecTemplateInitContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaConnectSpecTemplateInitContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaConnectSpecTemplateInitContainerSecurityContext
 */
export interface KafkaConnectSpecTemplateInitContainerSecurityContext {
  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions;

}

/**
 * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
 *
 * @schema KafkaConnectSpecTemplatePodDisruptionBudgetMetadata
 */
export interface KafkaConnectSpecTemplatePodDisruptionBudgetMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectSpecTemplatePodDisruptionBudgetMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectSpecTemplatePodDisruptionBudgetMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
 *
 * @schema KafkaConnectSpecExternalConfigurationEnvValueFrom
 */
export interface KafkaConnectSpecExternalConfigurationEnvValueFrom {
  /**
   * Refernce to a key in a ConfigMap.
   *
   * @schema KafkaConnectSpecExternalConfigurationEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef;

  /**
   * Reference to a key in a Secret.
   *
   * @schema KafkaConnectSpecExternalConfigurationEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef;

}

/**
 * Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
 *
 * @schema KafkaConnectSpecExternalConfigurationVolumesConfigMap
 */
export interface KafkaConnectSpecExternalConfigurationVolumesConfigMap {
  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesConfigMap#items
   */
  readonly items?: KafkaConnectSpecExternalConfigurationVolumesConfigMapItems[];

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
 *
 * @schema KafkaConnectSpecExternalConfigurationVolumesSecret
 */
export interface KafkaConnectSpecExternalConfigurationVolumesSecret {
  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesSecret#items
   */
  readonly items?: KafkaConnectSpecExternalConfigurationVolumesSecretItems[];

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesSecret#secretName
   */
  readonly secretName?: string;

}

/**
 * @schema KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaConnectSpecTemplatePodSecurityContextSysctls
 */
export interface KafkaConnectSpecTemplatePodSecurityContextSysctls {
  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaConnectSpecTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaConnectSpecTemplatePodSecurityContextWindowsOptions {
  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinity
 */
export interface KafkaConnectSpecTemplatePodAffinityNodeAffinity {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinity
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinity {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinity {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities
 */
export interface KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities {
  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions
 */
export interface KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions
 */
export interface KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaConnectSpecTemplateConnectContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities
 */
export interface KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities {
  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions
 */
export interface KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions
 */
export interface KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaConnectSpecTemplateInitContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Refernce to a key in a ConfigMap.
 *
 * @schema KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef
 */
export interface KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef {
  /**
   * @schema KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaConnectSpecExternalConfigurationEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Reference to a key in a Secret.
 *
 * @schema KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef
 */
export interface KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef {
  /**
   * @schema KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaConnectSpecExternalConfigurationEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * @schema KafkaConnectSpecExternalConfigurationVolumesConfigMapItems
 */
export interface KafkaConnectSpecExternalConfigurationVolumesConfigMapItems {
  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesConfigMapItems#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesConfigMapItems#path
   */
  readonly path?: string;

}

/**
 * @schema KafkaConnectSpecExternalConfigurationVolumesSecretItems
 */
export interface KafkaConnectSpecExternalConfigurationVolumesSecretItems {
  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesSecretItems#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * @schema KafkaConnectSpecExternalConfigurationVolumesSecretItems#path
   */
  readonly path?: string;

}

/**
 * @schema KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * 
 *
 * @schema KafkaConnector
 */
export class KafkaConnector extends ApiObject {
  /**
   * Returns the apiVersion and kind for "KafkaConnector"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kafka.strimzi.io/v1alpha1',
    kind: 'KafkaConnector',
  }

  /**
   * Renders a Kubernetes manifest for "KafkaConnector".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KafkaConnectorProps = {}): any {
    return {
      ...KafkaConnector.GVK,
      ...props,
    };
  }

  /**
   * Defines a "KafkaConnector" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KafkaConnectorProps = {}) {
    super(scope, id, KafkaConnector.manifest(props));
  }
}

/**
 * @schema KafkaConnector
 */
export interface KafkaConnectorProps {
  /**
   * The specification of the Kafka Connector.
   *
   * @schema KafkaConnector#spec
   */
  readonly spec?: KafkaConnectorSpec;

}

/**
 * The specification of the Kafka Connector.
 *
 * @schema KafkaConnectorSpec
 */
export interface KafkaConnectorSpec {
  /**
   * The Class for the Kafka Connector.
   *
   * @schema KafkaConnectorSpec#class
   */
  readonly class?: string;

  /**
   * The maximum number of tasks for the Kafka Connector.
   *
   * @schema KafkaConnectorSpec#tasksMax
   */
  readonly tasksMax?: number;

  /**
   * The Kafka Connector configuration. The following properties cannot be set: connector.class, tasks.max.
   *
   * @schema KafkaConnectorSpec#config
   */
  readonly config?: any;

  /**
   * Whether the connector should be paused. Defaults to false.
   *
   * @default false.
   * @schema KafkaConnectorSpec#pause
   */
  readonly pause?: boolean;

}

/**
 * 
 *
 * @schema KafkaConnectS2I
 */
export class KafkaConnectS2I extends ApiObject {
  /**
   * Returns the apiVersion and kind for "KafkaConnectS2I"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kafka.strimzi.io/v1beta1',
    kind: 'KafkaConnectS2I',
  }

  /**
   * Renders a Kubernetes manifest for "KafkaConnectS2I".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KafkaConnectS2IProps = {}): any {
    return {
      ...KafkaConnectS2I.GVK,
      ...props,
    };
  }

  /**
   * Defines a "KafkaConnectS2I" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KafkaConnectS2IProps = {}) {
    super(scope, id, KafkaConnectS2I.manifest(props));
  }
}

/**
 * @schema KafkaConnectS2I
 */
export interface KafkaConnectS2IProps {
  /**
   * The specification of the Kafka Connect Source-to-Image (S2I) cluster.
   *
   * @schema KafkaConnectS2I#spec
   */
  readonly spec?: KafkaConnectS2ISpec;

}

/**
 * The specification of the Kafka Connect Source-to-Image (S2I) cluster.
 *
 * @schema KafkaConnectS2ISpec
 */
export interface KafkaConnectS2ISpec {
  /**
   * The number of pods in the Kafka Connect group.
   *
   * @schema KafkaConnectS2ISpec#replicas
   */
  readonly replicas?: number;

  /**
   * The docker image for the pods.
   *
   * @schema KafkaConnectS2ISpec#image
   */
  readonly image?: string;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaConnectS2ISpec#buildResources
   */
  readonly buildResources?: KafkaConnectS2ISpecBuildResources;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaConnectS2ISpec#livenessProbe
   */
  readonly livenessProbe?: KafkaConnectS2ISpecLivenessProbe;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaConnectS2ISpec#readinessProbe
   */
  readonly readinessProbe?: KafkaConnectS2ISpecReadinessProbe;

  /**
   * JVM Options for pods.
   *
   * @schema KafkaConnectS2ISpec#jvmOptions
   */
  readonly jvmOptions?: KafkaConnectS2ISpecJvmOptions;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaConnectS2ISpec#affinity
   */
  readonly affinity?: KafkaConnectS2ISpecAffinity;

  /**
   * Logging configuration for Kafka Connect.
   *
   * @schema KafkaConnectS2ISpec#logging
   */
  readonly logging?: KafkaConnectS2ISpecLogging;

  /**
   * The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
   *
   * @schema KafkaConnectS2ISpec#metrics
   */
  readonly metrics?: any;

  /**
   * Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
   *
   * @schema KafkaConnectS2ISpec#template
   */
  readonly template?: KafkaConnectS2ISpecTemplate;

  /**
   * Authentication configuration for Kafka Connect.
   *
   * @schema KafkaConnectS2ISpec#authentication
   */
  readonly authentication?: KafkaConnectS2ISpecAuthentication;

  /**
   * Bootstrap servers to connect to. This should be given as a comma separated list of _<hostname>_:_<port>_ pairs.
   *
   * @schema KafkaConnectS2ISpec#bootstrapServers
   */
  readonly bootstrapServers: string;

  /**
   * The image of the init container used for initializing the `client.rack`.
   *
   * @schema KafkaConnectS2ISpec#clientRackInitImage
   */
  readonly clientRackInitImage?: string;

  /**
   * The Kafka Connect configuration. Properties with the following prefixes cannot be set: ssl., sasl., security., listeners, plugin.path, rest., bootstrap.servers, consumer.interceptor.classes, producer.interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
   *
   * @schema KafkaConnectS2ISpec#config
   */
  readonly config?: any;

  /**
   * Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
   *
   * @schema KafkaConnectS2ISpec#externalConfiguration
   */
  readonly externalConfiguration?: KafkaConnectS2ISpecExternalConfiguration;

  /**
   * When true this configures the source repository with the 'Local' reference policy and an import policy that accepts insecure source tags.
   *
   * @schema KafkaConnectS2ISpec#insecureSourceRepository
   */
  readonly insecureSourceRepository?: boolean;

  /**
   * Configuration of the node label which will be used as the client.rack consumer configuration.
   *
   * @schema KafkaConnectS2ISpec#rack
   */
  readonly rack?: KafkaConnectS2ISpecRack;

  /**
   * The maximum limits for CPU and memory resources and the requested initial resources.
   *
   * @schema KafkaConnectS2ISpec#resources
   */
  readonly resources?: KafkaConnectS2ISpecResources;

  /**
   * TLS configuration.
   *
   * @schema KafkaConnectS2ISpec#tls
   */
  readonly tls?: KafkaConnectS2ISpecTls;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaConnectS2ISpec#tolerations
   */
  readonly tolerations?: KafkaConnectS2ISpecTolerations[];

  /**
   * The configuration of tracing in Kafka Connect.
   *
   * @schema KafkaConnectS2ISpec#tracing
   */
  readonly tracing?: KafkaConnectS2ISpecTracing;

  /**
   * The Kafka Connect version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
   *
   * @default DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
   * @schema KafkaConnectS2ISpec#version
   */
  readonly version?: string;

}

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaConnectS2ISpecBuildResources
 */
export interface KafkaConnectS2ISpecBuildResources {
  /**
   * @schema KafkaConnectS2ISpecBuildResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaConnectS2ISpecBuildResources#requests
   */
  readonly requests?: any;

}

/**
 * Pod liveness checking.
 *
 * @schema KafkaConnectS2ISpecLivenessProbe
 */
export interface KafkaConnectS2ISpecLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaConnectS2ISpecLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaConnectS2ISpecLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaConnectS2ISpecLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaConnectS2ISpecLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaConnectS2ISpecLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Pod readiness checking.
 *
 * @schema KafkaConnectS2ISpecReadinessProbe
 */
export interface KafkaConnectS2ISpecReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaConnectS2ISpecReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaConnectS2ISpecReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaConnectS2ISpecReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaConnectS2ISpecReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaConnectS2ISpecReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * JVM Options for pods.
 *
 * @schema KafkaConnectS2ISpecJvmOptions
 */
export interface KafkaConnectS2ISpecJvmOptions {
  /**
   * A map of -XX options to the JVM.
   *
   * @schema KafkaConnectS2ISpecJvmOptions#-XX
   */
  readonly xx?: any;

  /**
   * -Xms option to to the JVM.
   *
   * @schema KafkaConnectS2ISpecJvmOptions#-Xms
   */
  readonly xms?: string;

  /**
   * -Xmx option to to the JVM.
   *
   * @schema KafkaConnectS2ISpecJvmOptions#-Xmx
   */
  readonly xmx?: string;

  /**
   * Specifies whether the Garbage Collection logging is enabled. The default is false.
   *
   * @schema KafkaConnectS2ISpecJvmOptions#gcLoggingEnabled
   */
  readonly gcLoggingEnabled?: boolean;

  /**
   * A map of additional system properties which will be passed using the `-D` option to the JVM.
   *
   * @schema KafkaConnectS2ISpecJvmOptions#javaSystemProperties
   */
  readonly javaSystemProperties?: KafkaConnectS2ISpecJvmOptionsJavaSystemProperties[];

}

/**
 * The pod's affinity rules.
 *
 * @schema KafkaConnectS2ISpecAffinity
 */
export interface KafkaConnectS2ISpecAffinity {
  /**
   * @schema KafkaConnectS2ISpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaConnectS2ISpecAffinityNodeAffinity;

  /**
   * @schema KafkaConnectS2ISpecAffinity#podAffinity
   */
  readonly podAffinity?: KafkaConnectS2ISpecAffinityPodAffinity;

  /**
   * @schema KafkaConnectS2ISpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaConnectS2ISpecAffinityPodAntiAffinity;

}

/**
 * Logging configuration for Kafka Connect.
 *
 * @schema KafkaConnectS2ISpecLogging
 */
export interface KafkaConnectS2ISpecLogging {
  /**
   * A Map from logger name to logger level.
   *
   * @schema KafkaConnectS2ISpecLogging#loggers
   */
  readonly loggers?: any;

  /**
   * The name of the `ConfigMap` from which to get the logging configuration.
   *
   * @schema KafkaConnectS2ISpecLogging#name
   */
  readonly name?: string;

  /**
   * Logging type, must be either 'inline' or 'external'.
   *
   * @schema KafkaConnectS2ISpecLogging#type
   */
  readonly type: KafkaConnectS2ISpecLoggingType;

}

/**
 * Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
 *
 * @schema KafkaConnectS2ISpecTemplate
 */
export interface KafkaConnectS2ISpecTemplate {
  /**
   * Template for Kafka Connect `Deployment`.
   *
   * @schema KafkaConnectS2ISpecTemplate#deployment
   */
  readonly deployment?: KafkaConnectS2ISpecTemplateDeployment;

  /**
   * Template for Kafka Connect `Pods`.
   *
   * @schema KafkaConnectS2ISpecTemplate#pod
   */
  readonly pod?: KafkaConnectS2ISpecTemplatePod;

  /**
   * Template for Kafka Connect API `Service`.
   *
   * @schema KafkaConnectS2ISpecTemplate#apiService
   */
  readonly apiService?: KafkaConnectS2ISpecTemplateApiService;

  /**
   * Template for the Kafka Connect container.
   *
   * @schema KafkaConnectS2ISpecTemplate#connectContainer
   */
  readonly connectContainer?: KafkaConnectS2ISpecTemplateConnectContainer;

  /**
   * Template for the Kafka init container.
   *
   * @schema KafkaConnectS2ISpecTemplate#initContainer
   */
  readonly initContainer?: KafkaConnectS2ISpecTemplateInitContainer;

  /**
   * Template for Kafka Connect `PodDisruptionBudget`.
   *
   * @schema KafkaConnectS2ISpecTemplate#podDisruptionBudget
   */
  readonly podDisruptionBudget?: KafkaConnectS2ISpecTemplatePodDisruptionBudget;

}

/**
 * Authentication configuration for Kafka Connect.
 *
 * @schema KafkaConnectS2ISpecAuthentication
 */
export interface KafkaConnectS2ISpecAuthentication {
  /**
   * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
   *
   * @schema KafkaConnectS2ISpecAuthentication#accessToken
   */
  readonly accessToken?: KafkaConnectS2ISpecAuthenticationAccessToken;

  /**
   * Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
   *
   * @default true`.
   * @schema KafkaConnectS2ISpecAuthentication#accessTokenIsJwt
   */
  readonly accessTokenIsJwt?: boolean;

  /**
   * Reference to the `Secret` which holds the certificate and private key pair.
   *
   * @schema KafkaConnectS2ISpecAuthentication#certificateAndKey
   */
  readonly certificateAndKey?: KafkaConnectS2ISpecAuthenticationCertificateAndKey;

  /**
   * OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
   *
   * @schema KafkaConnectS2ISpecAuthentication#clientId
   */
  readonly clientId?: string;

  /**
   * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
   *
   * @schema KafkaConnectS2ISpecAuthentication#clientSecret
   */
  readonly clientSecret?: KafkaConnectS2ISpecAuthenticationClientSecret;

  /**
   * Enable or disable TLS hostname verification. Default value is `false`.
   *
   * @schema KafkaConnectS2ISpecAuthentication#disableTlsHostnameVerification
   */
  readonly disableTlsHostnameVerification?: boolean;

  /**
   * Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
   *
   * @schema KafkaConnectS2ISpecAuthentication#maxTokenExpirySeconds
   */
  readonly maxTokenExpirySeconds?: number;

  /**
   * Reference to the `Secret` which holds the password.
   *
   * @schema KafkaConnectS2ISpecAuthentication#passwordSecret
   */
  readonly passwordSecret?: KafkaConnectS2ISpecAuthenticationPasswordSecret;

  /**
   * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
   *
   * @schema KafkaConnectS2ISpecAuthentication#refreshToken
   */
  readonly refreshToken?: KafkaConnectS2ISpecAuthenticationRefreshToken;

  /**
   * OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
   *
   * @schema KafkaConnectS2ISpecAuthentication#scope
   */
  readonly scope?: string;

  /**
   * Trusted certificates for TLS connection to the OAuth server.
   *
   * @schema KafkaConnectS2ISpecAuthentication#tlsTrustedCertificates
   */
  readonly tlsTrustedCertificates?: KafkaConnectS2ISpecAuthenticationTlsTrustedCertificates[];

  /**
   * Authorization server token endpoint URI.
   *
   * @schema KafkaConnectS2ISpecAuthentication#tokenEndpointUri
   */
  readonly tokenEndpointUri?: string;

  /**
   * Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
   *
   * @schema KafkaConnectS2ISpecAuthentication#type
   */
  readonly type: KafkaConnectS2ISpecAuthenticationType;

  /**
   * Username used for the authentication.
   *
   * @schema KafkaConnectS2ISpecAuthentication#username
   */
  readonly username?: string;

}

/**
 * Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
 *
 * @schema KafkaConnectS2ISpecExternalConfiguration
 */
export interface KafkaConnectS2ISpecExternalConfiguration {
  /**
   * Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as environment variables.
   *
   * @schema KafkaConnectS2ISpecExternalConfiguration#env
   */
  readonly env?: KafkaConnectS2ISpecExternalConfigurationEnv[];

  /**
   * Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as volumes.
   *
   * @schema KafkaConnectS2ISpecExternalConfiguration#volumes
   */
  readonly volumes?: KafkaConnectS2ISpecExternalConfigurationVolumes[];

}

/**
 * Configuration of the node label which will be used as the client.rack consumer configuration.
 *
 * @schema KafkaConnectS2ISpecRack
 */
export interface KafkaConnectS2ISpecRack {
  /**
   * A key that matches labels assigned to the Kubernetes cluster nodes. The value of the label is used to set the broker's `broker.rack` config.
   *
   * @schema KafkaConnectS2ISpecRack#topologyKey
   */
  readonly topologyKey: string;

}

/**
 * The maximum limits for CPU and memory resources and the requested initial resources.
 *
 * @schema KafkaConnectS2ISpecResources
 */
export interface KafkaConnectS2ISpecResources {
  /**
   * @schema KafkaConnectS2ISpecResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaConnectS2ISpecResources#requests
   */
  readonly requests?: any;

}

/**
 * TLS configuration.
 *
 * @schema KafkaConnectS2ISpecTls
 */
export interface KafkaConnectS2ISpecTls {
  /**
   * Trusted certificates for TLS connection.
   *
   * @schema KafkaConnectS2ISpecTls#trustedCertificates
   */
  readonly trustedCertificates?: KafkaConnectS2ISpecTlsTrustedCertificates[];

}

/**
 * @schema KafkaConnectS2ISpecTolerations
 */
export interface KafkaConnectS2ISpecTolerations {
  /**
   * @schema KafkaConnectS2ISpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaConnectS2ISpecTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectS2ISpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectS2ISpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaConnectS2ISpecTolerations#value
   */
  readonly value?: string;

}

/**
 * The configuration of tracing in Kafka Connect.
 *
 * @schema KafkaConnectS2ISpecTracing
 */
export interface KafkaConnectS2ISpecTracing {
  /**
   * Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
   *
   * @schema KafkaConnectS2ISpecTracing#type
   */
  readonly type: KafkaConnectS2ISpecTracingType;

}

/**
 * @schema KafkaConnectS2ISpecJvmOptionsJavaSystemProperties
 */
export interface KafkaConnectS2ISpecJvmOptionsJavaSystemProperties {
  /**
   * The system property name.
   *
   * @schema KafkaConnectS2ISpecJvmOptionsJavaSystemProperties#name
   */
  readonly name?: string;

  /**
   * The system property value.
   *
   * @schema KafkaConnectS2ISpecJvmOptionsJavaSystemProperties#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaConnectS2ISpecAffinityNodeAffinity
 */
export interface KafkaConnectS2ISpecAffinityNodeAffinity {
  /**
   * @schema KafkaConnectS2ISpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaConnectS2ISpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaConnectS2ISpecAffinityPodAffinity
 */
export interface KafkaConnectS2ISpecAffinityPodAffinity {
  /**
   * @schema KafkaConnectS2ISpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaConnectS2ISpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaConnectS2ISpecAffinityPodAntiAffinity
 */
export interface KafkaConnectS2ISpecAffinityPodAntiAffinity {
  /**
   * @schema KafkaConnectS2ISpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaConnectS2ISpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaConnectS2ISpecLoggingType
 */
export enum KafkaConnectS2ISpecLoggingType {
  /** inline */
  INLINE = "inline",
  /** external */
  EXTERNAL = "external",
}

/**
 * Template for Kafka Connect `Deployment`.
 *
 * @schema KafkaConnectS2ISpecTemplateDeployment
 */
export interface KafkaConnectS2ISpecTemplateDeployment {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaConnectS2ISpecTemplateDeployment#metadata
   */
  readonly metadata?: KafkaConnectS2ISpecTemplateDeploymentMetadata;

}

/**
 * Template for Kafka Connect `Pods`.
 *
 * @schema KafkaConnectS2ISpecTemplatePod
 */
export interface KafkaConnectS2ISpecTemplatePod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaConnectS2ISpecTemplatePod#metadata
   */
  readonly metadata?: KafkaConnectS2ISpecTemplatePodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaConnectS2ISpecTemplatePod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaConnectS2ISpecTemplatePodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaConnectS2ISpecTemplatePod#securityContext
   */
  readonly securityContext?: KafkaConnectS2ISpecTemplatePodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaConnectS2ISpecTemplatePod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaConnectS2ISpecTemplatePod#affinity
   */
  readonly affinity?: KafkaConnectS2ISpecTemplatePodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaConnectS2ISpecTemplatePod#tolerations
   */
  readonly tolerations?: KafkaConnectS2ISpecTemplatePodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaConnectS2ISpecTemplatePod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaConnectS2ISpecTemplatePod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
   *
   * @schema KafkaConnectS2ISpecTemplatePod#hostAliases
   */
  readonly hostAliases?: KafkaConnectS2ISpecTemplatePodHostAliases[];

}

/**
 * Template for Kafka Connect API `Service`.
 *
 * @schema KafkaConnectS2ISpecTemplateApiService
 */
export interface KafkaConnectS2ISpecTemplateApiService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaConnectS2ISpecTemplateApiService#metadata
   */
  readonly metadata?: KafkaConnectS2ISpecTemplateApiServiceMetadata;

}

/**
 * Template for the Kafka Connect container.
 *
 * @schema KafkaConnectS2ISpecTemplateConnectContainer
 */
export interface KafkaConnectS2ISpecTemplateConnectContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaConnectS2ISpecTemplateConnectContainer#env
   */
  readonly env?: KafkaConnectS2ISpecTemplateConnectContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaConnectS2ISpecTemplateConnectContainer#securityContext
   */
  readonly securityContext?: KafkaConnectS2ISpecTemplateConnectContainerSecurityContext;

}

/**
 * Template for the Kafka init container.
 *
 * @schema KafkaConnectS2ISpecTemplateInitContainer
 */
export interface KafkaConnectS2ISpecTemplateInitContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaConnectS2ISpecTemplateInitContainer#env
   */
  readonly env?: KafkaConnectS2ISpecTemplateInitContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaConnectS2ISpecTemplateInitContainer#securityContext
   */
  readonly securityContext?: KafkaConnectS2ISpecTemplateInitContainerSecurityContext;

}

/**
 * Template for Kafka Connect `PodDisruptionBudget`.
 *
 * @schema KafkaConnectS2ISpecTemplatePodDisruptionBudget
 */
export interface KafkaConnectS2ISpecTemplatePodDisruptionBudget {
  /**
   * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
   *
   * @schema KafkaConnectS2ISpecTemplatePodDisruptionBudget#metadata
   */
  readonly metadata?: KafkaConnectS2ISpecTemplatePodDisruptionBudgetMetadata;

  /**
   * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
   *
   * @default 1.
   * @schema KafkaConnectS2ISpecTemplatePodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: number;

}

/**
 * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
 *
 * @schema KafkaConnectS2ISpecAuthenticationAccessToken
 */
export interface KafkaConnectS2ISpecAuthenticationAccessToken {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaConnectS2ISpecAuthenticationAccessToken#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaConnectS2ISpecAuthenticationAccessToken#secretName
   */
  readonly secretName: string;

}

/**
 * Reference to the `Secret` which holds the certificate and private key pair.
 *
 * @schema KafkaConnectS2ISpecAuthenticationCertificateAndKey
 */
export interface KafkaConnectS2ISpecAuthenticationCertificateAndKey {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaConnectS2ISpecAuthenticationCertificateAndKey#certificate
   */
  readonly certificate: string;

  /**
   * The name of the private key in the Secret.
   *
   * @schema KafkaConnectS2ISpecAuthenticationCertificateAndKey#key
   */
  readonly key: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaConnectS2ISpecAuthenticationCertificateAndKey#secretName
   */
  readonly secretName: string;

}

/**
 * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
 *
 * @schema KafkaConnectS2ISpecAuthenticationClientSecret
 */
export interface KafkaConnectS2ISpecAuthenticationClientSecret {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaConnectS2ISpecAuthenticationClientSecret#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaConnectS2ISpecAuthenticationClientSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Reference to the `Secret` which holds the password.
 *
 * @schema KafkaConnectS2ISpecAuthenticationPasswordSecret
 */
export interface KafkaConnectS2ISpecAuthenticationPasswordSecret {
  /**
   * The name of the key in the Secret under which the password is stored.
   *
   * @schema KafkaConnectS2ISpecAuthenticationPasswordSecret#password
   */
  readonly password: string;

  /**
   * The name of the Secret containing the password.
   *
   * @schema KafkaConnectS2ISpecAuthenticationPasswordSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
 *
 * @schema KafkaConnectS2ISpecAuthenticationRefreshToken
 */
export interface KafkaConnectS2ISpecAuthenticationRefreshToken {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaConnectS2ISpecAuthenticationRefreshToken#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaConnectS2ISpecAuthenticationRefreshToken#secretName
   */
  readonly secretName: string;

}

/**
 * @schema KafkaConnectS2ISpecAuthenticationTlsTrustedCertificates
 */
export interface KafkaConnectS2ISpecAuthenticationTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaConnectS2ISpecAuthenticationTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaConnectS2ISpecAuthenticationTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
 *
 * @schema KafkaConnectS2ISpecAuthenticationType
 */
export enum KafkaConnectS2ISpecAuthenticationType {
  /** tls */
  TLS = "tls",
  /** scram-sha-512 */
  SCRAM_SHA_512 = "scram-sha-512",
  /** plain */
  PLAIN = "plain",
  /** oauth */
  OAUTH = "oauth",
}

/**
 * @schema KafkaConnectS2ISpecExternalConfigurationEnv
 */
export interface KafkaConnectS2ISpecExternalConfigurationEnv {
  /**
   * Name of the environment variable which will be passed to the Kafka Connect pods. The name of the environment variable cannot start with `KAFKA_` or `STRIMZI_`.
   *
   * @schema KafkaConnectS2ISpecExternalConfigurationEnv#name
   */
  readonly name: string;

  /**
   * Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
   *
   * @schema KafkaConnectS2ISpecExternalConfigurationEnv#valueFrom
   */
  readonly valueFrom: KafkaConnectS2ISpecExternalConfigurationEnvValueFrom;

}

/**
 * @schema KafkaConnectS2ISpecExternalConfigurationVolumes
 */
export interface KafkaConnectS2ISpecExternalConfigurationVolumes {
  /**
   * Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
   *
   * @schema KafkaConnectS2ISpecExternalConfigurationVolumes#configMap
   */
  readonly configMap?: KafkaConnectS2ISpecExternalConfigurationVolumesConfigMap;

  /**
   * Name of the volume which will be added to the Kafka Connect pods.
   *
   * @schema KafkaConnectS2ISpecExternalConfigurationVolumes#name
   */
  readonly name: string;

  /**
   * Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
   *
   * @schema KafkaConnectS2ISpecExternalConfigurationVolumes#secret
   */
  readonly secret?: KafkaConnectS2ISpecExternalConfigurationVolumesSecret;

}

/**
 * @schema KafkaConnectS2ISpecTlsTrustedCertificates
 */
export interface KafkaConnectS2ISpecTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaConnectS2ISpecTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaConnectS2ISpecTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
 *
 * @schema KafkaConnectS2ISpecTracingType
 */
export enum KafkaConnectS2ISpecTracingType {
  /** jaeger */
  JAEGER = "jaeger",
}

/**
 * @schema KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaConnectS2ISpecTemplateDeploymentMetadata
 */
export interface KafkaConnectS2ISpecTemplateDeploymentMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectS2ISpecTemplateDeploymentMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectS2ISpecTemplateDeploymentMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaConnectS2ISpecTemplatePodMetadata
 */
export interface KafkaConnectS2ISpecTemplatePodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectS2ISpecTemplatePodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectS2ISpecTemplatePodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodImagePullSecrets
 */
export interface KafkaConnectS2ISpecTemplatePodImagePullSecrets {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaConnectS2ISpecTemplatePodSecurityContext
 */
export interface KafkaConnectS2ISpecTemplatePodSecurityContext {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaConnectS2ISpecTemplatePodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaConnectS2ISpecTemplatePodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaConnectS2ISpecTemplatePodSecurityContextSysctls[];

  /**
   * @schema KafkaConnectS2ISpecTemplatePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaConnectS2ISpecTemplatePodSecurityContextWindowsOptions;

}

/**
 * The pod's affinity rules.
 *
 * @schema KafkaConnectS2ISpecTemplatePodAffinity
 */
export interface KafkaConnectS2ISpecTemplatePodAffinity {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaConnectS2ISpecTemplatePodAffinityNodeAffinity;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaConnectS2ISpecTemplatePodAffinityPodAffinity;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinity;

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodTolerations
 */
export interface KafkaConnectS2ISpecTemplatePodTolerations {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodTolerations#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodHostAliases
 */
export interface KafkaConnectS2ISpecTemplatePodHostAliases {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaConnectS2ISpecTemplatePodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaConnectS2ISpecTemplateApiServiceMetadata
 */
export interface KafkaConnectS2ISpecTemplateApiServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectS2ISpecTemplateApiServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectS2ISpecTemplateApiServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaConnectS2ISpecTemplateConnectContainerEnv
 */
export interface KafkaConnectS2ISpecTemplateConnectContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaConnectS2ISpecTemplateConnectContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaConnectS2ISpecTemplateConnectContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaConnectS2ISpecTemplateConnectContainerSecurityContext
 */
export interface KafkaConnectS2ISpecTemplateConnectContainerSecurityContext {
  /**
   * @schema KafkaConnectS2ISpecTemplateConnectContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaConnectS2ISpecTemplateConnectContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaConnectS2ISpecTemplateConnectContainerSecurityContextCapabilities;

  /**
   * @schema KafkaConnectS2ISpecTemplateConnectContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaConnectS2ISpecTemplateConnectContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplateConnectContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaConnectS2ISpecTemplateConnectContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaConnectS2ISpecTemplateConnectContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaConnectS2ISpecTemplateConnectContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaConnectS2ISpecTemplateConnectContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaConnectS2ISpecTemplateConnectContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaConnectS2ISpecTemplateConnectContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaConnectS2ISpecTemplateConnectContainerSecurityContextWindowsOptions;

}

/**
 * @schema KafkaConnectS2ISpecTemplateInitContainerEnv
 */
export interface KafkaConnectS2ISpecTemplateInitContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaConnectS2ISpecTemplateInitContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaConnectS2ISpecTemplateInitContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaConnectS2ISpecTemplateInitContainerSecurityContext
 */
export interface KafkaConnectS2ISpecTemplateInitContainerSecurityContext {
  /**
   * @schema KafkaConnectS2ISpecTemplateInitContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaConnectS2ISpecTemplateInitContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaConnectS2ISpecTemplateInitContainerSecurityContextCapabilities;

  /**
   * @schema KafkaConnectS2ISpecTemplateInitContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaConnectS2ISpecTemplateInitContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplateInitContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaConnectS2ISpecTemplateInitContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaConnectS2ISpecTemplateInitContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaConnectS2ISpecTemplateInitContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaConnectS2ISpecTemplateInitContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaConnectS2ISpecTemplateInitContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaConnectS2ISpecTemplateInitContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaConnectS2ISpecTemplateInitContainerSecurityContextWindowsOptions;

}

/**
 * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
 *
 * @schema KafkaConnectS2ISpecTemplatePodDisruptionBudgetMetadata
 */
export interface KafkaConnectS2ISpecTemplatePodDisruptionBudgetMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectS2ISpecTemplatePodDisruptionBudgetMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaConnectS2ISpecTemplatePodDisruptionBudgetMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
 *
 * @schema KafkaConnectS2ISpecExternalConfigurationEnvValueFrom
 */
export interface KafkaConnectS2ISpecExternalConfigurationEnvValueFrom {
  /**
   * Refernce to a key in a ConfigMap.
   *
   * @schema KafkaConnectS2ISpecExternalConfigurationEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: KafkaConnectS2ISpecExternalConfigurationEnvValueFromConfigMapKeyRef;

  /**
   * Reference to a key in a Secret.
   *
   * @schema KafkaConnectS2ISpecExternalConfigurationEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: KafkaConnectS2ISpecExternalConfigurationEnvValueFromSecretKeyRef;

}

/**
 * Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
 *
 * @schema KafkaConnectS2ISpecExternalConfigurationVolumesConfigMap
 */
export interface KafkaConnectS2ISpecExternalConfigurationVolumesConfigMap {
  /**
   * @schema KafkaConnectS2ISpecExternalConfigurationVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * @schema KafkaConnectS2ISpecExternalConfigurationVolumesConfigMap#items
   */
  readonly items?: KafkaConnectS2ISpecExternalConfigurationVolumesConfigMapItems[];

  /**
   * @schema KafkaConnectS2ISpecExternalConfigurationVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * @schema KafkaConnectS2ISpecExternalConfigurationVolumesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
 *
 * @schema KafkaConnectS2ISpecExternalConfigurationVolumesSecret
 */
export interface KafkaConnectS2ISpecExternalConfigurationVolumesSecret {
  /**
   * @schema KafkaConnectS2ISpecExternalConfigurationVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * @schema KafkaConnectS2ISpecExternalConfigurationVolumesSecret#items
   */
  readonly items?: KafkaConnectS2ISpecExternalConfigurationVolumesSecretItems[];

  /**
   * @schema KafkaConnectS2ISpecExternalConfigurationVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * @schema KafkaConnectS2ISpecExternalConfigurationVolumesSecret#secretName
   */
  readonly secretName?: string;

}

/**
 * @schema KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaConnectS2ISpecTemplatePodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodSecurityContextSysctls
 */
export interface KafkaConnectS2ISpecTemplatePodSecurityContextSysctls {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaConnectS2ISpecTemplatePodSecurityContextWindowsOptions {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinity
 */
export interface KafkaConnectS2ISpecTemplatePodAffinityNodeAffinity {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAffinity
 */
export interface KafkaConnectS2ISpecTemplatePodAffinityPodAffinity {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinity {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaConnectS2ISpecTemplateConnectContainerSecurityContextCapabilities
 */
export interface KafkaConnectS2ISpecTemplateConnectContainerSecurityContextCapabilities {
  /**
   * @schema KafkaConnectS2ISpecTemplateConnectContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaConnectS2ISpecTemplateConnectContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaConnectS2ISpecTemplateConnectContainerSecurityContextSeLinuxOptions
 */
export interface KafkaConnectS2ISpecTemplateConnectContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaConnectS2ISpecTemplateConnectContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplateConnectContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplateConnectContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplateConnectContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaConnectS2ISpecTemplateConnectContainerSecurityContextWindowsOptions
 */
export interface KafkaConnectS2ISpecTemplateConnectContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaConnectS2ISpecTemplateConnectContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplateConnectContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplateConnectContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaConnectS2ISpecTemplateInitContainerSecurityContextCapabilities
 */
export interface KafkaConnectS2ISpecTemplateInitContainerSecurityContextCapabilities {
  /**
   * @schema KafkaConnectS2ISpecTemplateInitContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaConnectS2ISpecTemplateInitContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaConnectS2ISpecTemplateInitContainerSecurityContextSeLinuxOptions
 */
export interface KafkaConnectS2ISpecTemplateInitContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaConnectS2ISpecTemplateInitContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplateInitContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplateInitContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplateInitContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaConnectS2ISpecTemplateInitContainerSecurityContextWindowsOptions
 */
export interface KafkaConnectS2ISpecTemplateInitContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaConnectS2ISpecTemplateInitContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplateInitContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplateInitContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Refernce to a key in a ConfigMap.
 *
 * @schema KafkaConnectS2ISpecExternalConfigurationEnvValueFromConfigMapKeyRef
 */
export interface KafkaConnectS2ISpecExternalConfigurationEnvValueFromConfigMapKeyRef {
  /**
   * @schema KafkaConnectS2ISpecExternalConfigurationEnvValueFromConfigMapKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectS2ISpecExternalConfigurationEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaConnectS2ISpecExternalConfigurationEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Reference to a key in a Secret.
 *
 * @schema KafkaConnectS2ISpecExternalConfigurationEnvValueFromSecretKeyRef
 */
export interface KafkaConnectS2ISpecExternalConfigurationEnvValueFromSecretKeyRef {
  /**
   * @schema KafkaConnectS2ISpecExternalConfigurationEnvValueFromSecretKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectS2ISpecExternalConfigurationEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaConnectS2ISpecExternalConfigurationEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * @schema KafkaConnectS2ISpecExternalConfigurationVolumesConfigMapItems
 */
export interface KafkaConnectS2ISpecExternalConfigurationVolumesConfigMapItems {
  /**
   * @schema KafkaConnectS2ISpecExternalConfigurationVolumesConfigMapItems#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectS2ISpecExternalConfigurationVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * @schema KafkaConnectS2ISpecExternalConfigurationVolumesConfigMapItems#path
   */
  readonly path?: string;

}

/**
 * @schema KafkaConnectS2ISpecExternalConfigurationVolumesSecretItems
 */
export interface KafkaConnectS2ISpecExternalConfigurationVolumesSecretItems {
  /**
   * @schema KafkaConnectS2ISpecExternalConfigurationVolumesSecretItems#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectS2ISpecExternalConfigurationVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * @schema KafkaConnectS2ISpecExternalConfigurationVolumesSecretItems#path
   */
  readonly path?: string;

}

/**
 * @schema KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectS2ISpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectS2ISpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectS2ISpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectS2ISpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectS2ISpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectS2ISpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaConnectS2ISpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * 
 *
 * @schema KafkaMirrorMaker
 */
export class KafkaMirrorMaker extends ApiObject {
  /**
   * Returns the apiVersion and kind for "KafkaMirrorMaker"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kafka.strimzi.io/v1beta1',
    kind: 'KafkaMirrorMaker',
  }

  /**
   * Renders a Kubernetes manifest for "KafkaMirrorMaker".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KafkaMirrorMakerProps = {}): any {
    return {
      ...KafkaMirrorMaker.GVK,
      ...props,
    };
  }

  /**
   * Defines a "KafkaMirrorMaker" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KafkaMirrorMakerProps = {}) {
    super(scope, id, KafkaMirrorMaker.manifest(props));
  }
}

/**
 * @schema KafkaMirrorMaker
 */
export interface KafkaMirrorMakerProps {
  /**
   * The specification of Kafka MirrorMaker.
   *
   * @schema KafkaMirrorMaker#spec
   */
  readonly spec?: KafkaMirrorMakerSpec;

}

/**
 * The specification of Kafka MirrorMaker.
 *
 * @schema KafkaMirrorMakerSpec
 */
export interface KafkaMirrorMakerSpec {
  /**
   * The number of pods in the `Deployment`.
   *
   * @schema KafkaMirrorMakerSpec#replicas
   */
  readonly replicas: number;

  /**
   * The docker image for the pods.
   *
   * @schema KafkaMirrorMakerSpec#image
   */
  readonly image?: string;

  /**
   * List of topics which are included for mirroring. This option allows any regular expression using Java-style regular expressions. Mirroring two topics named A and B is achieved by using the whitelist `'A\|B'`. Or, as a special case, you can mirror all topics using the whitelist '*'. You can also specify multiple regular expressions separated by commas.
   *
   * @schema KafkaMirrorMakerSpec#whitelist
   */
  readonly whitelist: string;

  /**
   * Configuration of source cluster.
   *
   * @schema KafkaMirrorMakerSpec#consumer
   */
  readonly consumer: KafkaMirrorMakerSpecConsumer;

  /**
   * Configuration of target cluster.
   *
   * @schema KafkaMirrorMakerSpec#producer
   */
  readonly producer: KafkaMirrorMakerSpecProducer;

  /**
   * CPU and memory resources to reserve.
   *
   * @schema KafkaMirrorMakerSpec#resources
   */
  readonly resources?: KafkaMirrorMakerSpecResources;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaMirrorMakerSpec#affinity
   */
  readonly affinity?: KafkaMirrorMakerSpecAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaMirrorMakerSpec#tolerations
   */
  readonly tolerations?: KafkaMirrorMakerSpecTolerations[];

  /**
   * JVM Options for pods.
   *
   * @schema KafkaMirrorMakerSpec#jvmOptions
   */
  readonly jvmOptions?: KafkaMirrorMakerSpecJvmOptions;

  /**
   * Logging configuration for MirrorMaker.
   *
   * @schema KafkaMirrorMakerSpec#logging
   */
  readonly logging?: KafkaMirrorMakerSpecLogging;

  /**
   * The Prometheus JMX Exporter configuration. See {JMXExporter} for details of the structure of this configuration.
   *
   * @schema KafkaMirrorMakerSpec#metrics
   */
  readonly metrics?: any;

  /**
   * The configuration of tracing in Kafka MirrorMaker.
   *
   * @schema KafkaMirrorMakerSpec#tracing
   */
  readonly tracing?: KafkaMirrorMakerSpecTracing;

  /**
   * Template to specify how Kafka MirrorMaker resources, `Deployments` and `Pods`, are generated.
   *
   * @schema KafkaMirrorMakerSpec#template
   */
  readonly template?: KafkaMirrorMakerSpecTemplate;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaMirrorMakerSpec#livenessProbe
   */
  readonly livenessProbe?: KafkaMirrorMakerSpecLivenessProbe;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaMirrorMakerSpec#readinessProbe
   */
  readonly readinessProbe?: KafkaMirrorMakerSpecReadinessProbe;

  /**
   * The Kafka MirrorMaker version. Defaults to {DefaultKafkaVersion}. Consult the documentation to understand the process required to upgrade or downgrade the version.
   *
   * @default DefaultKafkaVersion}. Consult the documentation to understand the process required to upgrade or downgrade the version.
   * @schema KafkaMirrorMakerSpec#version
   */
  readonly version?: string;

}

/**
 * Configuration of source cluster.
 *
 * @schema KafkaMirrorMakerSpecConsumer
 */
export interface KafkaMirrorMakerSpecConsumer {
  /**
   * Specifies the number of consumer stream threads to create.
   *
   * @schema KafkaMirrorMakerSpecConsumer#numStreams
   */
  readonly numStreams?: number;

  /**
   * Specifies the offset auto-commit interval in ms. Default value is 60000.
   *
   * @schema KafkaMirrorMakerSpecConsumer#offsetCommitInterval
   */
  readonly offsetCommitInterval?: number;

  /**
   * A unique string that identifies the consumer group this consumer belongs to.
   *
   * @schema KafkaMirrorMakerSpecConsumer#groupId
   */
  readonly groupId: string;

  /**
   * A list of host:port pairs for establishing the initial connection to the Kafka cluster.
   *
   * @schema KafkaMirrorMakerSpecConsumer#bootstrapServers
   */
  readonly bootstrapServers: string;

  /**
   * Authentication configuration for connecting to the cluster.
   *
   * @schema KafkaMirrorMakerSpecConsumer#authentication
   */
  readonly authentication?: KafkaMirrorMakerSpecConsumerAuthentication;

  /**
   * The MirrorMaker consumer config. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, group.id, sasl., security., interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
   *
   * @schema KafkaMirrorMakerSpecConsumer#config
   */
  readonly config?: any;

  /**
   * TLS configuration for connecting MirrorMaker to the cluster.
   *
   * @schema KafkaMirrorMakerSpecConsumer#tls
   */
  readonly tls?: KafkaMirrorMakerSpecConsumerTls;

}

/**
 * Configuration of target cluster.
 *
 * @schema KafkaMirrorMakerSpecProducer
 */
export interface KafkaMirrorMakerSpecProducer {
  /**
   * A list of host:port pairs for establishing the initial connection to the Kafka cluster.
   *
   * @schema KafkaMirrorMakerSpecProducer#bootstrapServers
   */
  readonly bootstrapServers: string;

  /**
   * Flag to set the MirrorMaker to exit on a failed send. Default value is `true`.
   *
   * @schema KafkaMirrorMakerSpecProducer#abortOnSendFailure
   */
  readonly abortOnSendFailure?: boolean;

  /**
   * Authentication configuration for connecting to the cluster.
   *
   * @schema KafkaMirrorMakerSpecProducer#authentication
   */
  readonly authentication?: KafkaMirrorMakerSpecProducerAuthentication;

  /**
   * The MirrorMaker producer config. Properties with the following prefixes cannot be set: ssl., bootstrap.servers, sasl., security., interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
   *
   * @schema KafkaMirrorMakerSpecProducer#config
   */
  readonly config?: any;

  /**
   * TLS configuration for connecting MirrorMaker to the cluster.
   *
   * @schema KafkaMirrorMakerSpecProducer#tls
   */
  readonly tls?: KafkaMirrorMakerSpecProducerTls;

}

/**
 * CPU and memory resources to reserve.
 *
 * @schema KafkaMirrorMakerSpecResources
 */
export interface KafkaMirrorMakerSpecResources {
  /**
   * @schema KafkaMirrorMakerSpecResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaMirrorMakerSpecResources#requests
   */
  readonly requests?: any;

}

/**
 * The pod's affinity rules.
 *
 * @schema KafkaMirrorMakerSpecAffinity
 */
export interface KafkaMirrorMakerSpecAffinity {
  /**
   * @schema KafkaMirrorMakerSpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaMirrorMakerSpecAffinityNodeAffinity;

  /**
   * @schema KafkaMirrorMakerSpecAffinity#podAffinity
   */
  readonly podAffinity?: KafkaMirrorMakerSpecAffinityPodAffinity;

  /**
   * @schema KafkaMirrorMakerSpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaMirrorMakerSpecAffinityPodAntiAffinity;

}

/**
 * @schema KafkaMirrorMakerSpecTolerations
 */
export interface KafkaMirrorMakerSpecTolerations {
  /**
   * @schema KafkaMirrorMakerSpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaMirrorMakerSpecTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaMirrorMakerSpecTolerations#value
   */
  readonly value?: string;

}

/**
 * JVM Options for pods.
 *
 * @schema KafkaMirrorMakerSpecJvmOptions
 */
export interface KafkaMirrorMakerSpecJvmOptions {
  /**
   * A map of -XX options to the JVM.
   *
   * @schema KafkaMirrorMakerSpecJvmOptions#-XX
   */
  readonly xx?: any;

  /**
   * -Xms option to to the JVM.
   *
   * @schema KafkaMirrorMakerSpecJvmOptions#-Xms
   */
  readonly xms?: string;

  /**
   * -Xmx option to to the JVM.
   *
   * @schema KafkaMirrorMakerSpecJvmOptions#-Xmx
   */
  readonly xmx?: string;

  /**
   * Specifies whether the Garbage Collection logging is enabled. The default is false.
   *
   * @schema KafkaMirrorMakerSpecJvmOptions#gcLoggingEnabled
   */
  readonly gcLoggingEnabled?: boolean;

  /**
   * A map of additional system properties which will be passed using the `-D` option to the JVM.
   *
   * @schema KafkaMirrorMakerSpecJvmOptions#javaSystemProperties
   */
  readonly javaSystemProperties?: KafkaMirrorMakerSpecJvmOptionsJavaSystemProperties[];

}

/**
 * Logging configuration for MirrorMaker.
 *
 * @schema KafkaMirrorMakerSpecLogging
 */
export interface KafkaMirrorMakerSpecLogging {
  /**
   * A Map from logger name to logger level.
   *
   * @schema KafkaMirrorMakerSpecLogging#loggers
   */
  readonly loggers?: any;

  /**
   * The name of the `ConfigMap` from which to get the logging configuration.
   *
   * @schema KafkaMirrorMakerSpecLogging#name
   */
  readonly name?: string;

  /**
   * Logging type, must be either 'inline' or 'external'.
   *
   * @schema KafkaMirrorMakerSpecLogging#type
   */
  readonly type: KafkaMirrorMakerSpecLoggingType;

}

/**
 * The configuration of tracing in Kafka MirrorMaker.
 *
 * @schema KafkaMirrorMakerSpecTracing
 */
export interface KafkaMirrorMakerSpecTracing {
  /**
   * Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
   *
   * @schema KafkaMirrorMakerSpecTracing#type
   */
  readonly type: KafkaMirrorMakerSpecTracingType;

}

/**
 * Template to specify how Kafka MirrorMaker resources, `Deployments` and `Pods`, are generated.
 *
 * @schema KafkaMirrorMakerSpecTemplate
 */
export interface KafkaMirrorMakerSpecTemplate {
  /**
   * Template for Kafka MirrorMaker `Deployment`.
   *
   * @schema KafkaMirrorMakerSpecTemplate#deployment
   */
  readonly deployment?: KafkaMirrorMakerSpecTemplateDeployment;

  /**
   * Template for Kafka MirrorMaker `Pods`.
   *
   * @schema KafkaMirrorMakerSpecTemplate#pod
   */
  readonly pod?: KafkaMirrorMakerSpecTemplatePod;

  /**
   * Template for Kafka MirrorMaker container.
   *
   * @schema KafkaMirrorMakerSpecTemplate#mirrorMakerContainer
   */
  readonly mirrorMakerContainer?: KafkaMirrorMakerSpecTemplateMirrorMakerContainer;

  /**
   * Template for Kafka MirrorMaker `PodDisruptionBudget`.
   *
   * @schema KafkaMirrorMakerSpecTemplate#podDisruptionBudget
   */
  readonly podDisruptionBudget?: KafkaMirrorMakerSpecTemplatePodDisruptionBudget;

}

/**
 * Pod liveness checking.
 *
 * @schema KafkaMirrorMakerSpecLivenessProbe
 */
export interface KafkaMirrorMakerSpecLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaMirrorMakerSpecLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaMirrorMakerSpecLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaMirrorMakerSpecLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaMirrorMakerSpecLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaMirrorMakerSpecLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Pod readiness checking.
 *
 * @schema KafkaMirrorMakerSpecReadinessProbe
 */
export interface KafkaMirrorMakerSpecReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaMirrorMakerSpecReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaMirrorMakerSpecReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaMirrorMakerSpecReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaMirrorMakerSpecReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaMirrorMakerSpecReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Authentication configuration for connecting to the cluster.
 *
 * @schema KafkaMirrorMakerSpecConsumerAuthentication
 */
export interface KafkaMirrorMakerSpecConsumerAuthentication {
  /**
   * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#accessToken
   */
  readonly accessToken?: KafkaMirrorMakerSpecConsumerAuthenticationAccessToken;

  /**
   * Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
   *
   * @default true`.
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#accessTokenIsJwt
   */
  readonly accessTokenIsJwt?: boolean;

  /**
   * Reference to the `Secret` which holds the certificate and private key pair.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#certificateAndKey
   */
  readonly certificateAndKey?: KafkaMirrorMakerSpecConsumerAuthenticationCertificateAndKey;

  /**
   * OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#clientId
   */
  readonly clientId?: string;

  /**
   * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#clientSecret
   */
  readonly clientSecret?: KafkaMirrorMakerSpecConsumerAuthenticationClientSecret;

  /**
   * Enable or disable TLS hostname verification. Default value is `false`.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#disableTlsHostnameVerification
   */
  readonly disableTlsHostnameVerification?: boolean;

  /**
   * Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#maxTokenExpirySeconds
   */
  readonly maxTokenExpirySeconds?: number;

  /**
   * Reference to the `Secret` which holds the password.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#passwordSecret
   */
  readonly passwordSecret?: KafkaMirrorMakerSpecConsumerAuthenticationPasswordSecret;

  /**
   * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#refreshToken
   */
  readonly refreshToken?: KafkaMirrorMakerSpecConsumerAuthenticationRefreshToken;

  /**
   * OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#scope
   */
  readonly scope?: string;

  /**
   * Trusted certificates for TLS connection to the OAuth server.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#tlsTrustedCertificates
   */
  readonly tlsTrustedCertificates?: KafkaMirrorMakerSpecConsumerAuthenticationTlsTrustedCertificates[];

  /**
   * Authorization server token endpoint URI.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#tokenEndpointUri
   */
  readonly tokenEndpointUri?: string;

  /**
   * Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#type
   */
  readonly type: KafkaMirrorMakerSpecConsumerAuthenticationType;

  /**
   * Username used for the authentication.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthentication#username
   */
  readonly username?: string;

}

/**
 * TLS configuration for connecting MirrorMaker to the cluster.
 *
 * @schema KafkaMirrorMakerSpecConsumerTls
 */
export interface KafkaMirrorMakerSpecConsumerTls {
  /**
   * Trusted certificates for TLS connection.
   *
   * @schema KafkaMirrorMakerSpecConsumerTls#trustedCertificates
   */
  readonly trustedCertificates?: KafkaMirrorMakerSpecConsumerTlsTrustedCertificates[];

}

/**
 * Authentication configuration for connecting to the cluster.
 *
 * @schema KafkaMirrorMakerSpecProducerAuthentication
 */
export interface KafkaMirrorMakerSpecProducerAuthentication {
  /**
   * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#accessToken
   */
  readonly accessToken?: KafkaMirrorMakerSpecProducerAuthenticationAccessToken;

  /**
   * Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
   *
   * @default true`.
   * @schema KafkaMirrorMakerSpecProducerAuthentication#accessTokenIsJwt
   */
  readonly accessTokenIsJwt?: boolean;

  /**
   * Reference to the `Secret` which holds the certificate and private key pair.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#certificateAndKey
   */
  readonly certificateAndKey?: KafkaMirrorMakerSpecProducerAuthenticationCertificateAndKey;

  /**
   * OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#clientId
   */
  readonly clientId?: string;

  /**
   * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#clientSecret
   */
  readonly clientSecret?: KafkaMirrorMakerSpecProducerAuthenticationClientSecret;

  /**
   * Enable or disable TLS hostname verification. Default value is `false`.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#disableTlsHostnameVerification
   */
  readonly disableTlsHostnameVerification?: boolean;

  /**
   * Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#maxTokenExpirySeconds
   */
  readonly maxTokenExpirySeconds?: number;

  /**
   * Reference to the `Secret` which holds the password.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#passwordSecret
   */
  readonly passwordSecret?: KafkaMirrorMakerSpecProducerAuthenticationPasswordSecret;

  /**
   * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#refreshToken
   */
  readonly refreshToken?: KafkaMirrorMakerSpecProducerAuthenticationRefreshToken;

  /**
   * OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#scope
   */
  readonly scope?: string;

  /**
   * Trusted certificates for TLS connection to the OAuth server.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#tlsTrustedCertificates
   */
  readonly tlsTrustedCertificates?: KafkaMirrorMakerSpecProducerAuthenticationTlsTrustedCertificates[];

  /**
   * Authorization server token endpoint URI.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#tokenEndpointUri
   */
  readonly tokenEndpointUri?: string;

  /**
   * Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#type
   */
  readonly type: KafkaMirrorMakerSpecProducerAuthenticationType;

  /**
   * Username used for the authentication.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthentication#username
   */
  readonly username?: string;

}

/**
 * TLS configuration for connecting MirrorMaker to the cluster.
 *
 * @schema KafkaMirrorMakerSpecProducerTls
 */
export interface KafkaMirrorMakerSpecProducerTls {
  /**
   * Trusted certificates for TLS connection.
   *
   * @schema KafkaMirrorMakerSpecProducerTls#trustedCertificates
   */
  readonly trustedCertificates?: KafkaMirrorMakerSpecProducerTlsTrustedCertificates[];

}

/**
 * @schema KafkaMirrorMakerSpecAffinityNodeAffinity
 */
export interface KafkaMirrorMakerSpecAffinityNodeAffinity {
  /**
   * @schema KafkaMirrorMakerSpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaMirrorMakerSpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaMirrorMakerSpecAffinityPodAffinity
 */
export interface KafkaMirrorMakerSpecAffinityPodAffinity {
  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaMirrorMakerSpecAffinityPodAntiAffinity
 */
export interface KafkaMirrorMakerSpecAffinityPodAntiAffinity {
  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaMirrorMakerSpecJvmOptionsJavaSystemProperties
 */
export interface KafkaMirrorMakerSpecJvmOptionsJavaSystemProperties {
  /**
   * The system property name.
   *
   * @schema KafkaMirrorMakerSpecJvmOptionsJavaSystemProperties#name
   */
  readonly name?: string;

  /**
   * The system property value.
   *
   * @schema KafkaMirrorMakerSpecJvmOptionsJavaSystemProperties#value
   */
  readonly value?: string;

}

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaMirrorMakerSpecLoggingType
 */
export enum KafkaMirrorMakerSpecLoggingType {
  /** inline */
  INLINE = "inline",
  /** external */
  EXTERNAL = "external",
}

/**
 * Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
 *
 * @schema KafkaMirrorMakerSpecTracingType
 */
export enum KafkaMirrorMakerSpecTracingType {
  /** jaeger */
  JAEGER = "jaeger",
}

/**
 * Template for Kafka MirrorMaker `Deployment`.
 *
 * @schema KafkaMirrorMakerSpecTemplateDeployment
 */
export interface KafkaMirrorMakerSpecTemplateDeployment {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaMirrorMakerSpecTemplateDeployment#metadata
   */
  readonly metadata?: KafkaMirrorMakerSpecTemplateDeploymentMetadata;

}

/**
 * Template for Kafka MirrorMaker `Pods`.
 *
 * @schema KafkaMirrorMakerSpecTemplatePod
 */
export interface KafkaMirrorMakerSpecTemplatePod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaMirrorMakerSpecTemplatePod#metadata
   */
  readonly metadata?: KafkaMirrorMakerSpecTemplatePodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaMirrorMakerSpecTemplatePod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaMirrorMakerSpecTemplatePodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaMirrorMakerSpecTemplatePod#securityContext
   */
  readonly securityContext?: KafkaMirrorMakerSpecTemplatePodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaMirrorMakerSpecTemplatePod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaMirrorMakerSpecTemplatePod#affinity
   */
  readonly affinity?: KafkaMirrorMakerSpecTemplatePodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaMirrorMakerSpecTemplatePod#tolerations
   */
  readonly tolerations?: KafkaMirrorMakerSpecTemplatePodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaMirrorMakerSpecTemplatePod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaMirrorMakerSpecTemplatePod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
   *
   * @schema KafkaMirrorMakerSpecTemplatePod#hostAliases
   */
  readonly hostAliases?: KafkaMirrorMakerSpecTemplatePodHostAliases[];

}

/**
 * Template for Kafka MirrorMaker container.
 *
 * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainer
 */
export interface KafkaMirrorMakerSpecTemplateMirrorMakerContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainer#env
   */
  readonly env?: KafkaMirrorMakerSpecTemplateMirrorMakerContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainer#securityContext
   */
  readonly securityContext?: KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext;

}

/**
 * Template for Kafka MirrorMaker `PodDisruptionBudget`.
 *
 * @schema KafkaMirrorMakerSpecTemplatePodDisruptionBudget
 */
export interface KafkaMirrorMakerSpecTemplatePodDisruptionBudget {
  /**
   * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
   *
   * @schema KafkaMirrorMakerSpecTemplatePodDisruptionBudget#metadata
   */
  readonly metadata?: KafkaMirrorMakerSpecTemplatePodDisruptionBudgetMetadata;

  /**
   * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
   *
   * @default 1.
   * @schema KafkaMirrorMakerSpecTemplatePodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: number;

}

/**
 * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
 *
 * @schema KafkaMirrorMakerSpecConsumerAuthenticationAccessToken
 */
export interface KafkaMirrorMakerSpecConsumerAuthenticationAccessToken {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthenticationAccessToken#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthenticationAccessToken#secretName
   */
  readonly secretName: string;

}

/**
 * Reference to the `Secret` which holds the certificate and private key pair.
 *
 * @schema KafkaMirrorMakerSpecConsumerAuthenticationCertificateAndKey
 */
export interface KafkaMirrorMakerSpecConsumerAuthenticationCertificateAndKey {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthenticationCertificateAndKey#certificate
   */
  readonly certificate: string;

  /**
   * The name of the private key in the Secret.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthenticationCertificateAndKey#key
   */
  readonly key: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthenticationCertificateAndKey#secretName
   */
  readonly secretName: string;

}

/**
 * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
 *
 * @schema KafkaMirrorMakerSpecConsumerAuthenticationClientSecret
 */
export interface KafkaMirrorMakerSpecConsumerAuthenticationClientSecret {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthenticationClientSecret#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthenticationClientSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Reference to the `Secret` which holds the password.
 *
 * @schema KafkaMirrorMakerSpecConsumerAuthenticationPasswordSecret
 */
export interface KafkaMirrorMakerSpecConsumerAuthenticationPasswordSecret {
  /**
   * The name of the key in the Secret under which the password is stored.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthenticationPasswordSecret#password
   */
  readonly password: string;

  /**
   * The name of the Secret containing the password.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthenticationPasswordSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
 *
 * @schema KafkaMirrorMakerSpecConsumerAuthenticationRefreshToken
 */
export interface KafkaMirrorMakerSpecConsumerAuthenticationRefreshToken {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthenticationRefreshToken#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthenticationRefreshToken#secretName
   */
  readonly secretName: string;

}

/**
 * @schema KafkaMirrorMakerSpecConsumerAuthenticationTlsTrustedCertificates
 */
export interface KafkaMirrorMakerSpecConsumerAuthenticationTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthenticationTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaMirrorMakerSpecConsumerAuthenticationTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
 *
 * @schema KafkaMirrorMakerSpecConsumerAuthenticationType
 */
export enum KafkaMirrorMakerSpecConsumerAuthenticationType {
  /** tls */
  TLS = "tls",
  /** scram-sha-512 */
  SCRAM_SHA_512 = "scram-sha-512",
  /** plain */
  PLAIN = "plain",
  /** oauth */
  OAUTH = "oauth",
}

/**
 * @schema KafkaMirrorMakerSpecConsumerTlsTrustedCertificates
 */
export interface KafkaMirrorMakerSpecConsumerTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaMirrorMakerSpecConsumerTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaMirrorMakerSpecConsumerTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
 *
 * @schema KafkaMirrorMakerSpecProducerAuthenticationAccessToken
 */
export interface KafkaMirrorMakerSpecProducerAuthenticationAccessToken {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthenticationAccessToken#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthenticationAccessToken#secretName
   */
  readonly secretName: string;

}

/**
 * Reference to the `Secret` which holds the certificate and private key pair.
 *
 * @schema KafkaMirrorMakerSpecProducerAuthenticationCertificateAndKey
 */
export interface KafkaMirrorMakerSpecProducerAuthenticationCertificateAndKey {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthenticationCertificateAndKey#certificate
   */
  readonly certificate: string;

  /**
   * The name of the private key in the Secret.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthenticationCertificateAndKey#key
   */
  readonly key: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthenticationCertificateAndKey#secretName
   */
  readonly secretName: string;

}

/**
 * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
 *
 * @schema KafkaMirrorMakerSpecProducerAuthenticationClientSecret
 */
export interface KafkaMirrorMakerSpecProducerAuthenticationClientSecret {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthenticationClientSecret#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthenticationClientSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Reference to the `Secret` which holds the password.
 *
 * @schema KafkaMirrorMakerSpecProducerAuthenticationPasswordSecret
 */
export interface KafkaMirrorMakerSpecProducerAuthenticationPasswordSecret {
  /**
   * The name of the key in the Secret under which the password is stored.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthenticationPasswordSecret#password
   */
  readonly password: string;

  /**
   * The name of the Secret containing the password.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthenticationPasswordSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
 *
 * @schema KafkaMirrorMakerSpecProducerAuthenticationRefreshToken
 */
export interface KafkaMirrorMakerSpecProducerAuthenticationRefreshToken {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthenticationRefreshToken#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthenticationRefreshToken#secretName
   */
  readonly secretName: string;

}

/**
 * @schema KafkaMirrorMakerSpecProducerAuthenticationTlsTrustedCertificates
 */
export interface KafkaMirrorMakerSpecProducerAuthenticationTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthenticationTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaMirrorMakerSpecProducerAuthenticationTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
 *
 * @schema KafkaMirrorMakerSpecProducerAuthenticationType
 */
export enum KafkaMirrorMakerSpecProducerAuthenticationType {
  /** tls */
  TLS = "tls",
  /** scram-sha-512 */
  SCRAM_SHA_512 = "scram-sha-512",
  /** plain */
  PLAIN = "plain",
  /** oauth */
  OAUTH = "oauth",
}

/**
 * @schema KafkaMirrorMakerSpecProducerTlsTrustedCertificates
 */
export interface KafkaMirrorMakerSpecProducerTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaMirrorMakerSpecProducerTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaMirrorMakerSpecProducerTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * @schema KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaMirrorMakerSpecTemplateDeploymentMetadata
 */
export interface KafkaMirrorMakerSpecTemplateDeploymentMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMakerSpecTemplateDeploymentMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMakerSpecTemplateDeploymentMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaMirrorMakerSpecTemplatePodMetadata
 */
export interface KafkaMirrorMakerSpecTemplatePodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMakerSpecTemplatePodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMakerSpecTemplatePodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodImagePullSecrets
 */
export interface KafkaMirrorMakerSpecTemplatePodImagePullSecrets {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaMirrorMakerSpecTemplatePodSecurityContext
 */
export interface KafkaMirrorMakerSpecTemplatePodSecurityContext {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaMirrorMakerSpecTemplatePodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaMirrorMakerSpecTemplatePodSecurityContextSysctls[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaMirrorMakerSpecTemplatePodSecurityContextWindowsOptions;

}

/**
 * The pod's affinity rules.
 *
 * @schema KafkaMirrorMakerSpecTemplatePodAffinity
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinity {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinity;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinity;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinity;

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodTolerations
 */
export interface KafkaMirrorMakerSpecTemplatePodTolerations {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodTolerations#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodHostAliases
 */
export interface KafkaMirrorMakerSpecTemplatePodHostAliases {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerEnv
 */
export interface KafkaMirrorMakerSpecTemplateMirrorMakerContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext
 */
export interface KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext {
  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextCapabilities;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextWindowsOptions;

}

/**
 * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
 *
 * @schema KafkaMirrorMakerSpecTemplatePodDisruptionBudgetMetadata
 */
export interface KafkaMirrorMakerSpecTemplatePodDisruptionBudgetMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMakerSpecTemplatePodDisruptionBudgetMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMakerSpecTemplatePodDisruptionBudgetMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaMirrorMakerSpecTemplatePodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodSecurityContextSysctls
 */
export interface KafkaMirrorMakerSpecTemplatePodSecurityContextSysctls {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaMirrorMakerSpecTemplatePodSecurityContextWindowsOptions {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinity
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinity {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinity
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAffinity {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinity {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextCapabilities
 */
export interface KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextCapabilities {
  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeLinuxOptions
 */
export interface KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextWindowsOptions
 */
export interface KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplateMirrorMakerContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMakerSpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * 
 *
 * @schema KafkaMirrorMaker2
 */
export class KafkaMirrorMaker2 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "KafkaMirrorMaker2"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kafka.strimzi.io/v1alpha1',
    kind: 'KafkaMirrorMaker2',
  }

  /**
   * Renders a Kubernetes manifest for "KafkaMirrorMaker2".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KafkaMirrorMaker2Props = {}): any {
    return {
      ...KafkaMirrorMaker2.GVK,
      ...props,
    };
  }

  /**
   * Defines a "KafkaMirrorMaker2" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KafkaMirrorMaker2Props = {}) {
    super(scope, id, KafkaMirrorMaker2.manifest(props));
  }
}

/**
 * @schema KafkaMirrorMaker2
 */
export interface KafkaMirrorMaker2Props {
  /**
   * The specification of the Kafka MirrorMaker 2.0 cluster.
   *
   * @schema KafkaMirrorMaker2#spec
   */
  readonly spec?: KafkaMirrorMaker2Spec;

}

/**
 * The specification of the Kafka MirrorMaker 2.0 cluster.
 *
 * @schema KafkaMirrorMaker2Spec
 */
export interface KafkaMirrorMaker2Spec {
  /**
   * The number of pods in the Kafka Connect group.
   *
   * @schema KafkaMirrorMaker2Spec#replicas
   */
  readonly replicas?: number;

  /**
   * The Kafka Connect version. Defaults to {DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
   *
   * @default DefaultKafkaVersion}. Consult the user documentation to understand the process required to upgrade or downgrade the version.
   * @schema KafkaMirrorMaker2Spec#version
   */
  readonly version?: string;

  /**
   * The docker image for the pods.
   *
   * @schema KafkaMirrorMaker2Spec#image
   */
  readonly image?: string;

  /**
   * The cluster alias used for Kafka Connect. The alias must match a cluster in the list at `spec.clusters`.
   *
   * @schema KafkaMirrorMaker2Spec#connectCluster
   */
  readonly connectCluster: string;

  /**
   * Kafka clusters for mirroring.
   *
   * @schema KafkaMirrorMaker2Spec#clusters
   */
  readonly clusters?: KafkaMirrorMaker2SpecClusters[];

  /**
   * Configuration of the MirrorMaker 2.0 connectors.
   *
   * @schema KafkaMirrorMaker2Spec#mirrors
   */
  readonly mirrors?: KafkaMirrorMaker2SpecMirrors[];

  /**
   * The maximum limits for CPU and memory resources and the requested initial resources.
   *
   * @schema KafkaMirrorMaker2Spec#resources
   */
  readonly resources?: KafkaMirrorMaker2SpecResources;

  /**
   * Pod liveness checking.
   *
   * @schema KafkaMirrorMaker2Spec#livenessProbe
   */
  readonly livenessProbe?: KafkaMirrorMaker2SpecLivenessProbe;

  /**
   * Pod readiness checking.
   *
   * @schema KafkaMirrorMaker2Spec#readinessProbe
   */
  readonly readinessProbe?: KafkaMirrorMaker2SpecReadinessProbe;

  /**
   * JVM Options for pods.
   *
   * @schema KafkaMirrorMaker2Spec#jvmOptions
   */
  readonly jvmOptions?: KafkaMirrorMaker2SpecJvmOptions;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaMirrorMaker2Spec#affinity
   */
  readonly affinity?: KafkaMirrorMaker2SpecAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaMirrorMaker2Spec#tolerations
   */
  readonly tolerations?: KafkaMirrorMaker2SpecTolerations[];

  /**
   * Logging configuration for Kafka Connect.
   *
   * @schema KafkaMirrorMaker2Spec#logging
   */
  readonly logging?: KafkaMirrorMaker2SpecLogging;

  /**
   * The Prometheus JMX Exporter configuration. See https://github.com/prometheus/jmx_exporter for details of the structure of this configuration.
   *
   * @schema KafkaMirrorMaker2Spec#metrics
   */
  readonly metrics?: any;

  /**
   * The configuration of tracing in Kafka Connect.
   *
   * @schema KafkaMirrorMaker2Spec#tracing
   */
  readonly tracing?: KafkaMirrorMaker2SpecTracing;

  /**
   * Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
   *
   * @schema KafkaMirrorMaker2Spec#template
   */
  readonly template?: KafkaMirrorMaker2SpecTemplate;

  /**
   * Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
   *
   * @schema KafkaMirrorMaker2Spec#externalConfiguration
   */
  readonly externalConfiguration?: KafkaMirrorMaker2SpecExternalConfiguration;

}

/**
 * @schema KafkaMirrorMaker2SpecClusters
 */
export interface KafkaMirrorMaker2SpecClusters {
  /**
   * Alias used to reference the Kafka cluster.
   *
   * @schema KafkaMirrorMaker2SpecClusters#alias
   */
  readonly alias: string;

  /**
   * A comma-separated list of `host:port` pairs for establishing the connection to the Kafka cluster.
   *
   * @schema KafkaMirrorMaker2SpecClusters#bootstrapServers
   */
  readonly bootstrapServers: string;

  /**
   * The MirrorMaker 2.0 cluster config. Properties with the following prefixes cannot be set: ssl., sasl., security., listeners, plugin.path, rest., bootstrap.servers, consumer.interceptor.classes, producer.interceptor.classes (with the exception of: ssl.endpoint.identification.algorithm, ssl.cipher.suites, ssl.protocol, ssl.enabled.protocols).
   *
   * @schema KafkaMirrorMaker2SpecClusters#config
   */
  readonly config?: any;

  /**
   * TLS configuration for connecting MirrorMaker 2.0 connectors to a cluster.
   *
   * @schema KafkaMirrorMaker2SpecClusters#tls
   */
  readonly tls?: KafkaMirrorMaker2SpecClustersTls;

  /**
   * Authentication configuration for connecting to the cluster.
   *
   * @schema KafkaMirrorMaker2SpecClusters#authentication
   */
  readonly authentication?: KafkaMirrorMaker2SpecClustersAuthentication;

}

/**
 * @schema KafkaMirrorMaker2SpecMirrors
 */
export interface KafkaMirrorMaker2SpecMirrors {
  /**
   * The alias of the source cluster used by the Kafka MirrorMaker 2.0 connectors. The alias must match a cluster in the list at `spec.clusters`.
   *
   * @schema KafkaMirrorMaker2SpecMirrors#sourceCluster
   */
  readonly sourceCluster: string;

  /**
   * The alias of the target cluster used by the Kafka MirrorMaker 2.0 connectors. The alias must match a cluster in the list at `spec.clusters`.
   *
   * @schema KafkaMirrorMaker2SpecMirrors#targetCluster
   */
  readonly targetCluster: string;

  /**
   * The specification of the Kafka MirrorMaker 2.0 source connector.
   *
   * @schema KafkaMirrorMaker2SpecMirrors#sourceConnector
   */
  readonly sourceConnector?: KafkaMirrorMaker2SpecMirrorsSourceConnector;

  /**
   * The specification of the Kafka MirrorMaker 2.0 checkpoint connector.
   *
   * @schema KafkaMirrorMaker2SpecMirrors#checkpointConnector
   */
  readonly checkpointConnector?: KafkaMirrorMaker2SpecMirrorsCheckpointConnector;

  /**
   * The specification of the Kafka MirrorMaker 2.0 heartbeat connector.
   *
   * @schema KafkaMirrorMaker2SpecMirrors#heartbeatConnector
   */
  readonly heartbeatConnector?: KafkaMirrorMaker2SpecMirrorsHeartbeatConnector;

  /**
   * A regular expression matching the topics to be mirrored, for example, "topic1\|topic2\|topic3". Comma-separated lists are also supported.
   *
   * @schema KafkaMirrorMaker2SpecMirrors#topicsPattern
   */
  readonly topicsPattern?: string;

  /**
   * A regular expression matching the topics to exclude from mirroring. Comma-separated lists are also supported.
   *
   * @schema KafkaMirrorMaker2SpecMirrors#topicsBlacklistPattern
   */
  readonly topicsBlacklistPattern?: string;

  /**
   * A regular expression matching the consumer groups to be mirrored. Comma-separated lists are also supported.
   *
   * @schema KafkaMirrorMaker2SpecMirrors#groupsPattern
   */
  readonly groupsPattern?: string;

  /**
   * A regular expression matching the consumer groups to exclude from mirroring. Comma-separated lists are also supported.
   *
   * @schema KafkaMirrorMaker2SpecMirrors#groupsBlacklistPattern
   */
  readonly groupsBlacklistPattern?: string;

}

/**
 * The maximum limits for CPU and memory resources and the requested initial resources.
 *
 * @schema KafkaMirrorMaker2SpecResources
 */
export interface KafkaMirrorMaker2SpecResources {
  /**
   * @schema KafkaMirrorMaker2SpecResources#limits
   */
  readonly limits?: any;

  /**
   * @schema KafkaMirrorMaker2SpecResources#requests
   */
  readonly requests?: any;

}

/**
 * Pod liveness checking.
 *
 * @schema KafkaMirrorMaker2SpecLivenessProbe
 */
export interface KafkaMirrorMaker2SpecLivenessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaMirrorMaker2SpecLivenessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaMirrorMaker2SpecLivenessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaMirrorMaker2SpecLivenessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaMirrorMaker2SpecLivenessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaMirrorMaker2SpecLivenessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * Pod readiness checking.
 *
 * @schema KafkaMirrorMaker2SpecReadinessProbe
 */
export interface KafkaMirrorMaker2SpecReadinessProbe {
  /**
   * Minimum consecutive failures for the probe to be considered failed after having succeeded. Defaults to 3. Minimum value is 1.
   *
   * @default 3. Minimum value is 1.
   * @schema KafkaMirrorMaker2SpecReadinessProbe#failureThreshold
   */
  readonly failureThreshold?: number;

  /**
   * The initial delay before first the health is first checked.
   *
   * @schema KafkaMirrorMaker2SpecReadinessProbe#initialDelaySeconds
   */
  readonly initialDelaySeconds?: number;

  /**
   * How often (in seconds) to perform the probe. Default to 10 seconds. Minimum value is 1.
   *
   * @default 10 seconds. Minimum value is 1.
   * @schema KafkaMirrorMaker2SpecReadinessProbe#periodSeconds
   */
  readonly periodSeconds?: number;

  /**
   * Minimum consecutive successes for the probe to be considered successful after having failed. Defaults to 1. Must be 1 for liveness. Minimum value is 1.
   *
   * @default 1. Must be 1 for liveness. Minimum value is 1.
   * @schema KafkaMirrorMaker2SpecReadinessProbe#successThreshold
   */
  readonly successThreshold?: number;

  /**
   * The timeout for each attempted health check.
   *
   * @schema KafkaMirrorMaker2SpecReadinessProbe#timeoutSeconds
   */
  readonly timeoutSeconds?: number;

}

/**
 * JVM Options for pods.
 *
 * @schema KafkaMirrorMaker2SpecJvmOptions
 */
export interface KafkaMirrorMaker2SpecJvmOptions {
  /**
   * A map of -XX options to the JVM.
   *
   * @schema KafkaMirrorMaker2SpecJvmOptions#-XX
   */
  readonly xx?: any;

  /**
   * -Xms option to to the JVM.
   *
   * @schema KafkaMirrorMaker2SpecJvmOptions#-Xms
   */
  readonly xms?: string;

  /**
   * -Xmx option to to the JVM.
   *
   * @schema KafkaMirrorMaker2SpecJvmOptions#-Xmx
   */
  readonly xmx?: string;

  /**
   * Specifies whether the Garbage Collection logging is enabled. The default is false.
   *
   * @schema KafkaMirrorMaker2SpecJvmOptions#gcLoggingEnabled
   */
  readonly gcLoggingEnabled?: boolean;

  /**
   * A map of additional system properties which will be passed using the `-D` option to the JVM.
   *
   * @schema KafkaMirrorMaker2SpecJvmOptions#javaSystemProperties
   */
  readonly javaSystemProperties?: KafkaMirrorMaker2SpecJvmOptionsJavaSystemProperties[];

}

/**
 * The pod's affinity rules.
 *
 * @schema KafkaMirrorMaker2SpecAffinity
 */
export interface KafkaMirrorMaker2SpecAffinity {
  /**
   * @schema KafkaMirrorMaker2SpecAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaMirrorMaker2SpecAffinityNodeAffinity;

  /**
   * @schema KafkaMirrorMaker2SpecAffinity#podAffinity
   */
  readonly podAffinity?: KafkaMirrorMaker2SpecAffinityPodAffinity;

  /**
   * @schema KafkaMirrorMaker2SpecAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaMirrorMaker2SpecAffinityPodAntiAffinity;

}

/**
 * @schema KafkaMirrorMaker2SpecTolerations
 */
export interface KafkaMirrorMaker2SpecTolerations {
  /**
   * @schema KafkaMirrorMaker2SpecTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaMirrorMaker2SpecTolerations#value
   */
  readonly value?: string;

}

/**
 * Logging configuration for Kafka Connect.
 *
 * @schema KafkaMirrorMaker2SpecLogging
 */
export interface KafkaMirrorMaker2SpecLogging {
  /**
   * A Map from logger name to logger level.
   *
   * @schema KafkaMirrorMaker2SpecLogging#loggers
   */
  readonly loggers?: any;

  /**
   * The name of the `ConfigMap` from which to get the logging configuration.
   *
   * @schema KafkaMirrorMaker2SpecLogging#name
   */
  readonly name?: string;

  /**
   * Logging type, must be either 'inline' or 'external'.
   *
   * @schema KafkaMirrorMaker2SpecLogging#type
   */
  readonly type: KafkaMirrorMaker2SpecLoggingType;

}

/**
 * The configuration of tracing in Kafka Connect.
 *
 * @schema KafkaMirrorMaker2SpecTracing
 */
export interface KafkaMirrorMaker2SpecTracing {
  /**
   * Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
   *
   * @schema KafkaMirrorMaker2SpecTracing#type
   */
  readonly type: KafkaMirrorMaker2SpecTracingType;

}

/**
 * Template for Kafka Connect and Kafka Connect S2I resources. The template allows users to specify how the `Deployment`, `Pods` and `Service` are generated.
 *
 * @schema KafkaMirrorMaker2SpecTemplate
 */
export interface KafkaMirrorMaker2SpecTemplate {
  /**
   * Template for Kafka Connect `Deployment`.
   *
   * @schema KafkaMirrorMaker2SpecTemplate#deployment
   */
  readonly deployment?: KafkaMirrorMaker2SpecTemplateDeployment;

  /**
   * Template for Kafka Connect `Pods`.
   *
   * @schema KafkaMirrorMaker2SpecTemplate#pod
   */
  readonly pod?: KafkaMirrorMaker2SpecTemplatePod;

  /**
   * Template for Kafka Connect API `Service`.
   *
   * @schema KafkaMirrorMaker2SpecTemplate#apiService
   */
  readonly apiService?: KafkaMirrorMaker2SpecTemplateApiService;

  /**
   * Template for the Kafka Connect container.
   *
   * @schema KafkaMirrorMaker2SpecTemplate#connectContainer
   */
  readonly connectContainer?: KafkaMirrorMaker2SpecTemplateConnectContainer;

  /**
   * Template for the Kafka init container.
   *
   * @schema KafkaMirrorMaker2SpecTemplate#initContainer
   */
  readonly initContainer?: KafkaMirrorMaker2SpecTemplateInitContainer;

  /**
   * Template for Kafka Connect `PodDisruptionBudget`.
   *
   * @schema KafkaMirrorMaker2SpecTemplate#podDisruptionBudget
   */
  readonly podDisruptionBudget?: KafkaMirrorMaker2SpecTemplatePodDisruptionBudget;

}

/**
 * Pass data from Secrets or ConfigMaps to the Kafka Connect pods and use them to configure connectors.
 *
 * @schema KafkaMirrorMaker2SpecExternalConfiguration
 */
export interface KafkaMirrorMaker2SpecExternalConfiguration {
  /**
   * Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as environment variables.
   *
   * @schema KafkaMirrorMaker2SpecExternalConfiguration#env
   */
  readonly env?: KafkaMirrorMaker2SpecExternalConfigurationEnv[];

  /**
   * Allows to pass data from Secret or ConfigMap to the Kafka Connect pods as volumes.
   *
   * @schema KafkaMirrorMaker2SpecExternalConfiguration#volumes
   */
  readonly volumes?: KafkaMirrorMaker2SpecExternalConfigurationVolumes[];

}

/**
 * TLS configuration for connecting MirrorMaker 2.0 connectors to a cluster.
 *
 * @schema KafkaMirrorMaker2SpecClustersTls
 */
export interface KafkaMirrorMaker2SpecClustersTls {
  /**
   * Trusted certificates for TLS connection.
   *
   * @schema KafkaMirrorMaker2SpecClustersTls#trustedCertificates
   */
  readonly trustedCertificates?: KafkaMirrorMaker2SpecClustersTlsTrustedCertificates[];

}

/**
 * Authentication configuration for connecting to the cluster.
 *
 * @schema KafkaMirrorMaker2SpecClustersAuthentication
 */
export interface KafkaMirrorMaker2SpecClustersAuthentication {
  /**
   * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#accessToken
   */
  readonly accessToken?: KafkaMirrorMaker2SpecClustersAuthenticationAccessToken;

  /**
   * Configure whether access token should be treated as JWT. This should be set to `false` if the authorization server returns opaque tokens. Defaults to `true`.
   *
   * @default true`.
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#accessTokenIsJwt
   */
  readonly accessTokenIsJwt?: boolean;

  /**
   * Reference to the `Secret` which holds the certificate and private key pair.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#certificateAndKey
   */
  readonly certificateAndKey?: KafkaMirrorMaker2SpecClustersAuthenticationCertificateAndKey;

  /**
   * OAuth Client ID which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#clientId
   */
  readonly clientId?: string;

  /**
   * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#clientSecret
   */
  readonly clientSecret?: KafkaMirrorMaker2SpecClustersAuthenticationClientSecret;

  /**
   * Enable or disable TLS hostname verification. Default value is `false`.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#disableTlsHostnameVerification
   */
  readonly disableTlsHostnameVerification?: boolean;

  /**
   * Set or limit time-to-live of the access tokens to the specified number of seconds. This should be set if the authorization server returns opaque tokens.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#maxTokenExpirySeconds
   */
  readonly maxTokenExpirySeconds?: number;

  /**
   * Reference to the `Secret` which holds the password.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#passwordSecret
   */
  readonly passwordSecret?: KafkaMirrorMaker2SpecClustersAuthenticationPasswordSecret;

  /**
   * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#refreshToken
   */
  readonly refreshToken?: KafkaMirrorMaker2SpecClustersAuthenticationRefreshToken;

  /**
   * OAuth scope to use when authenticating against the authorization server. Some authorization servers require this to be set. The possible values depend on how authorization server is configured. By default `scope` is not specified when doing the token endpoint request.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#scope
   */
  readonly scope?: string;

  /**
   * Trusted certificates for TLS connection to the OAuth server.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#tlsTrustedCertificates
   */
  readonly tlsTrustedCertificates?: KafkaMirrorMaker2SpecClustersAuthenticationTlsTrustedCertificates[];

  /**
   * Authorization server token endpoint URI.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#tokenEndpointUri
   */
  readonly tokenEndpointUri?: string;

  /**
   * Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#type
   */
  readonly type: KafkaMirrorMaker2SpecClustersAuthenticationType;

  /**
   * Username used for the authentication.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthentication#username
   */
  readonly username?: string;

}

/**
 * The specification of the Kafka MirrorMaker 2.0 source connector.
 *
 * @schema KafkaMirrorMaker2SpecMirrorsSourceConnector
 */
export interface KafkaMirrorMaker2SpecMirrorsSourceConnector {
  /**
   * The maximum number of tasks for the Kafka Connector.
   *
   * @schema KafkaMirrorMaker2SpecMirrorsSourceConnector#tasksMax
   */
  readonly tasksMax?: number;

  /**
   * The Kafka Connector configuration. The following properties cannot be set: connector.class, tasks.max.
   *
   * @schema KafkaMirrorMaker2SpecMirrorsSourceConnector#config
   */
  readonly config?: any;

  /**
   * Whether the connector should be paused. Defaults to false.
   *
   * @default false.
   * @schema KafkaMirrorMaker2SpecMirrorsSourceConnector#pause
   */
  readonly pause?: boolean;

}

/**
 * The specification of the Kafka MirrorMaker 2.0 checkpoint connector.
 *
 * @schema KafkaMirrorMaker2SpecMirrorsCheckpointConnector
 */
export interface KafkaMirrorMaker2SpecMirrorsCheckpointConnector {
  /**
   * The maximum number of tasks for the Kafka Connector.
   *
   * @schema KafkaMirrorMaker2SpecMirrorsCheckpointConnector#tasksMax
   */
  readonly tasksMax?: number;

  /**
   * The Kafka Connector configuration. The following properties cannot be set: connector.class, tasks.max.
   *
   * @schema KafkaMirrorMaker2SpecMirrorsCheckpointConnector#config
   */
  readonly config?: any;

  /**
   * Whether the connector should be paused. Defaults to false.
   *
   * @default false.
   * @schema KafkaMirrorMaker2SpecMirrorsCheckpointConnector#pause
   */
  readonly pause?: boolean;

}

/**
 * The specification of the Kafka MirrorMaker 2.0 heartbeat connector.
 *
 * @schema KafkaMirrorMaker2SpecMirrorsHeartbeatConnector
 */
export interface KafkaMirrorMaker2SpecMirrorsHeartbeatConnector {
  /**
   * The maximum number of tasks for the Kafka Connector.
   *
   * @schema KafkaMirrorMaker2SpecMirrorsHeartbeatConnector#tasksMax
   */
  readonly tasksMax?: number;

  /**
   * The Kafka Connector configuration. The following properties cannot be set: connector.class, tasks.max.
   *
   * @schema KafkaMirrorMaker2SpecMirrorsHeartbeatConnector#config
   */
  readonly config?: any;

  /**
   * Whether the connector should be paused. Defaults to false.
   *
   * @default false.
   * @schema KafkaMirrorMaker2SpecMirrorsHeartbeatConnector#pause
   */
  readonly pause?: boolean;

}

/**
 * @schema KafkaMirrorMaker2SpecJvmOptionsJavaSystemProperties
 */
export interface KafkaMirrorMaker2SpecJvmOptionsJavaSystemProperties {
  /**
   * The system property name.
   *
   * @schema KafkaMirrorMaker2SpecJvmOptionsJavaSystemProperties#name
   */
  readonly name?: string;

  /**
   * The system property value.
   *
   * @schema KafkaMirrorMaker2SpecJvmOptionsJavaSystemProperties#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaMirrorMaker2SpecAffinityNodeAffinity
 */
export interface KafkaMirrorMaker2SpecAffinityNodeAffinity {
  /**
   * @schema KafkaMirrorMaker2SpecAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaMirrorMaker2SpecAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaMirrorMaker2SpecAffinityPodAffinity
 */
export interface KafkaMirrorMaker2SpecAffinityPodAffinity {
  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaMirrorMaker2SpecAffinityPodAntiAffinity
 */
export interface KafkaMirrorMaker2SpecAffinityPodAntiAffinity {
  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * Logging type, must be either 'inline' or 'external'.
 *
 * @schema KafkaMirrorMaker2SpecLoggingType
 */
export enum KafkaMirrorMaker2SpecLoggingType {
  /** inline */
  INLINE = "inline",
  /** external */
  EXTERNAL = "external",
}

/**
 * Type of the tracing used. Currently the only supported type is `jaeger` for Jaeger tracing.
 *
 * @schema KafkaMirrorMaker2SpecTracingType
 */
export enum KafkaMirrorMaker2SpecTracingType {
  /** jaeger */
  JAEGER = "jaeger",
}

/**
 * Template for Kafka Connect `Deployment`.
 *
 * @schema KafkaMirrorMaker2SpecTemplateDeployment
 */
export interface KafkaMirrorMaker2SpecTemplateDeployment {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaMirrorMaker2SpecTemplateDeployment#metadata
   */
  readonly metadata?: KafkaMirrorMaker2SpecTemplateDeploymentMetadata;

}

/**
 * Template for Kafka Connect `Pods`.
 *
 * @schema KafkaMirrorMaker2SpecTemplatePod
 */
export interface KafkaMirrorMaker2SpecTemplatePod {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaMirrorMaker2SpecTemplatePod#metadata
   */
  readonly metadata?: KafkaMirrorMaker2SpecTemplatePodMetadata;

  /**
   * List of references to secrets in the same namespace to use for pulling any of the images used by this Pod. When the `STRIMZI_IMAGE_PULL_SECRETS` environment variable in Cluster Operator and the `imagePullSecrets` option are specified, only the `imagePullSecrets` variable is used and the `STRIMZI_IMAGE_PULL_SECRETS` variable is ignored.
   *
   * @schema KafkaMirrorMaker2SpecTemplatePod#imagePullSecrets
   */
  readonly imagePullSecrets?: KafkaMirrorMaker2SpecTemplatePodImagePullSecrets[];

  /**
   * Configures pod-level security attributes and common container settings.
   *
   * @schema KafkaMirrorMaker2SpecTemplatePod#securityContext
   */
  readonly securityContext?: KafkaMirrorMaker2SpecTemplatePodSecurityContext;

  /**
   * The grace period is the duration in seconds after the processes running in the pod are sent a termination signal, and the time when the processes are forcibly halted with a kill signal. Set this value to longer than the expected cleanup time for your process. Value must be a non-negative integer. A zero value indicates delete immediately. You might need to increase the grace period for very large Kafka clusters, so that the Kafka brokers have enough time to transfer their work to another broker before they are terminated. Defaults to 30 seconds.
   *
   * @default 30 seconds.
   * @schema KafkaMirrorMaker2SpecTemplatePod#terminationGracePeriodSeconds
   */
  readonly terminationGracePeriodSeconds?: number;

  /**
   * The pod's affinity rules.
   *
   * @schema KafkaMirrorMaker2SpecTemplatePod#affinity
   */
  readonly affinity?: KafkaMirrorMaker2SpecTemplatePodAffinity;

  /**
   * The pod's tolerations.
   *
   * @schema KafkaMirrorMaker2SpecTemplatePod#tolerations
   */
  readonly tolerations?: KafkaMirrorMaker2SpecTemplatePodTolerations[];

  /**
   * The name of the priority class used to assign priority to the pods. For more information about priority classes, see {K8sPriorityClass}.
   *
   * @schema KafkaMirrorMaker2SpecTemplatePod#priorityClassName
   */
  readonly priorityClassName?: string;

  /**
   * The name of the scheduler used to dispatch this `Pod`. If not specified, the default scheduler will be used.
   *
   * @schema KafkaMirrorMaker2SpecTemplatePod#schedulerName
   */
  readonly schedulerName?: string;

  /**
   * The pod's HostAliases. HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified.
   *
   * @schema KafkaMirrorMaker2SpecTemplatePod#hostAliases
   */
  readonly hostAliases?: KafkaMirrorMaker2SpecTemplatePodHostAliases[];

}

/**
 * Template for Kafka Connect API `Service`.
 *
 * @schema KafkaMirrorMaker2SpecTemplateApiService
 */
export interface KafkaMirrorMaker2SpecTemplateApiService {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaMirrorMaker2SpecTemplateApiService#metadata
   */
  readonly metadata?: KafkaMirrorMaker2SpecTemplateApiServiceMetadata;

}

/**
 * Template for the Kafka Connect container.
 *
 * @schema KafkaMirrorMaker2SpecTemplateConnectContainer
 */
export interface KafkaMirrorMaker2SpecTemplateConnectContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainer#env
   */
  readonly env?: KafkaMirrorMaker2SpecTemplateConnectContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainer#securityContext
   */
  readonly securityContext?: KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext;

}

/**
 * Template for the Kafka init container.
 *
 * @schema KafkaMirrorMaker2SpecTemplateInitContainer
 */
export interface KafkaMirrorMaker2SpecTemplateInitContainer {
  /**
   * Environment variables which should be applied to the container.
   *
   * @schema KafkaMirrorMaker2SpecTemplateInitContainer#env
   */
  readonly env?: KafkaMirrorMaker2SpecTemplateInitContainerEnv[];

  /**
   * Security context for the container.
   *
   * @schema KafkaMirrorMaker2SpecTemplateInitContainer#securityContext
   */
  readonly securityContext?: KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext;

}

/**
 * Template for Kafka Connect `PodDisruptionBudget`.
 *
 * @schema KafkaMirrorMaker2SpecTemplatePodDisruptionBudget
 */
export interface KafkaMirrorMaker2SpecTemplatePodDisruptionBudget {
  /**
   * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
   *
   * @schema KafkaMirrorMaker2SpecTemplatePodDisruptionBudget#metadata
   */
  readonly metadata?: KafkaMirrorMaker2SpecTemplatePodDisruptionBudgetMetadata;

  /**
   * Maximum number of unavailable pods to allow automatic Pod eviction. A Pod eviction is allowed when the `maxUnavailable` number of pods or fewer are unavailable after the eviction. Setting this value to 0 prevents all voluntary evictions, so the pods must be evicted manually. Defaults to 1.
   *
   * @default 1.
   * @schema KafkaMirrorMaker2SpecTemplatePodDisruptionBudget#maxUnavailable
   */
  readonly maxUnavailable?: number;

}

/**
 * @schema KafkaMirrorMaker2SpecExternalConfigurationEnv
 */
export interface KafkaMirrorMaker2SpecExternalConfigurationEnv {
  /**
   * Name of the environment variable which will be passed to the Kafka Connect pods. The name of the environment variable cannot start with `KAFKA_` or `STRIMZI_`.
   *
   * @schema KafkaMirrorMaker2SpecExternalConfigurationEnv#name
   */
  readonly name: string;

  /**
   * Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
   *
   * @schema KafkaMirrorMaker2SpecExternalConfigurationEnv#valueFrom
   */
  readonly valueFrom: KafkaMirrorMaker2SpecExternalConfigurationEnvValueFrom;

}

/**
 * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumes
 */
export interface KafkaMirrorMaker2SpecExternalConfigurationVolumes {
  /**
   * Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
   *
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumes#configMap
   */
  readonly configMap?: KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMap;

  /**
   * Name of the volume which will be added to the Kafka Connect pods.
   *
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumes#name
   */
  readonly name: string;

  /**
   * Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
   *
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumes#secret
   */
  readonly secret?: KafkaMirrorMaker2SpecExternalConfigurationVolumesSecret;

}

/**
 * @schema KafkaMirrorMaker2SpecClustersTlsTrustedCertificates
 */
export interface KafkaMirrorMaker2SpecClustersTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaMirrorMaker2SpecClustersTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaMirrorMaker2SpecClustersTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * Link to Kubernetes Secret containing the access token which was obtained from the authorization server.
 *
 * @schema KafkaMirrorMaker2SpecClustersAuthenticationAccessToken
 */
export interface KafkaMirrorMaker2SpecClustersAuthenticationAccessToken {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthenticationAccessToken#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthenticationAccessToken#secretName
   */
  readonly secretName: string;

}

/**
 * Reference to the `Secret` which holds the certificate and private key pair.
 *
 * @schema KafkaMirrorMaker2SpecClustersAuthenticationCertificateAndKey
 */
export interface KafkaMirrorMaker2SpecClustersAuthenticationCertificateAndKey {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthenticationCertificateAndKey#certificate
   */
  readonly certificate: string;

  /**
   * The name of the private key in the Secret.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthenticationCertificateAndKey#key
   */
  readonly key: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthenticationCertificateAndKey#secretName
   */
  readonly secretName: string;

}

/**
 * Link to Kubernetes Secret containing the OAuth client secret which the Kafka client can use to authenticate against the OAuth server and use the token endpoint URI.
 *
 * @schema KafkaMirrorMaker2SpecClustersAuthenticationClientSecret
 */
export interface KafkaMirrorMaker2SpecClustersAuthenticationClientSecret {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthenticationClientSecret#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthenticationClientSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Reference to the `Secret` which holds the password.
 *
 * @schema KafkaMirrorMaker2SpecClustersAuthenticationPasswordSecret
 */
export interface KafkaMirrorMaker2SpecClustersAuthenticationPasswordSecret {
  /**
   * The name of the key in the Secret under which the password is stored.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthenticationPasswordSecret#password
   */
  readonly password: string;

  /**
   * The name of the Secret containing the password.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthenticationPasswordSecret#secretName
   */
  readonly secretName: string;

}

/**
 * Link to Kubernetes Secret containing the refresh token which can be used to obtain access token from the authorization server.
 *
 * @schema KafkaMirrorMaker2SpecClustersAuthenticationRefreshToken
 */
export interface KafkaMirrorMaker2SpecClustersAuthenticationRefreshToken {
  /**
   * The key under which the secret value is stored in the Kubernetes Secret.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthenticationRefreshToken#key
   */
  readonly key: string;

  /**
   * The name of the Kubernetes Secret containing the secret value.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthenticationRefreshToken#secretName
   */
  readonly secretName: string;

}

/**
 * @schema KafkaMirrorMaker2SpecClustersAuthenticationTlsTrustedCertificates
 */
export interface KafkaMirrorMaker2SpecClustersAuthenticationTlsTrustedCertificates {
  /**
   * The name of the file certificate in the Secret.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthenticationTlsTrustedCertificates#certificate
   */
  readonly certificate: string;

  /**
   * The name of the Secret containing the certificate.
   *
   * @schema KafkaMirrorMaker2SpecClustersAuthenticationTlsTrustedCertificates#secretName
   */
  readonly secretName: string;

}

/**
 * Authentication type. Currently the only supported types are `tls`, `scram-sha-512`, and `plain`. `scram-sha-512` type uses SASL SCRAM-SHA-512 Authentication. `plain` type uses SASL PLAIN Authentication. `oauth` type uses SASL OAUTHBEARER Authentication. The `tls` type uses TLS Client Authentication. The `tls` type is supported only over TLS connections.
 *
 * @schema KafkaMirrorMaker2SpecClustersAuthenticationType
 */
export enum KafkaMirrorMaker2SpecClustersAuthenticationType {
  /** tls */
  TLS = "tls",
  /** scram-sha-512 */
  SCRAM_SHA_512 = "scram-sha-512",
  /** plain */
  PLAIN = "plain",
  /** oauth */
  OAUTH = "oauth",
}

/**
 * @schema KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaMirrorMaker2SpecTemplateDeploymentMetadata
 */
export interface KafkaMirrorMaker2SpecTemplateDeploymentMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMaker2SpecTemplateDeploymentMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMaker2SpecTemplateDeploymentMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaMirrorMaker2SpecTemplatePodMetadata
 */
export interface KafkaMirrorMaker2SpecTemplatePodMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMaker2SpecTemplatePodMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMaker2SpecTemplatePodMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodImagePullSecrets
 */
export interface KafkaMirrorMaker2SpecTemplatePodImagePullSecrets {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodImagePullSecrets#name
   */
  readonly name?: string;

}

/**
 * Configures pod-level security attributes and common container settings.
 *
 * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContext
 */
export interface KafkaMirrorMaker2SpecTemplatePodSecurityContext {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContext#fsGroup
   */
  readonly fsGroup?: number;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContext#fsGroupChangePolicy
   */
  readonly fsGroupChangePolicy?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaMirrorMaker2SpecTemplatePodSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContext#supplementalGroups
   */
  readonly supplementalGroups?: number[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContext#sysctls
   */
  readonly sysctls?: KafkaMirrorMaker2SpecTemplatePodSecurityContextSysctls[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaMirrorMaker2SpecTemplatePodSecurityContextWindowsOptions;

}

/**
 * The pod's affinity rules.
 *
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinity
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinity {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinity#nodeAffinity
   */
  readonly nodeAffinity?: KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinity;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinity#podAffinity
   */
  readonly podAffinity?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinity;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinity#podAntiAffinity
   */
  readonly podAntiAffinity?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinity;

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodTolerations
 */
export interface KafkaMirrorMaker2SpecTemplatePodTolerations {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodTolerations#effect
   */
  readonly effect?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodTolerations#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodTolerations#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodTolerations#tolerationSeconds
   */
  readonly tolerationSeconds?: number;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodTolerations#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodHostAliases
 */
export interface KafkaMirrorMaker2SpecTemplatePodHostAliases {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodHostAliases#hostnames
   */
  readonly hostnames?: string[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodHostAliases#ip
   */
  readonly ip?: string;

}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaMirrorMaker2SpecTemplateApiServiceMetadata
 */
export interface KafkaMirrorMaker2SpecTemplateApiServiceMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMaker2SpecTemplateApiServiceMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMaker2SpecTemplateApiServiceMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * @schema KafkaMirrorMaker2SpecTemplateConnectContainerEnv
 */
export interface KafkaMirrorMaker2SpecTemplateConnectContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext
 */
export interface KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextCapabilities;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextWindowsOptions;

}

/**
 * @schema KafkaMirrorMaker2SpecTemplateInitContainerEnv
 */
export interface KafkaMirrorMaker2SpecTemplateInitContainerEnv {
  /**
   * The environment variable key.
   *
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerEnv#name
   */
  readonly name?: string;

  /**
   * The environment variable value.
   *
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerEnv#value
   */
  readonly value?: string;

}

/**
 * Security context for the container.
 *
 * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext
 */
export interface KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext#allowPrivilegeEscalation
   */
  readonly allowPrivilegeEscalation?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext#capabilities
   */
  readonly capabilities?: KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextCapabilities;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext#privileged
   */
  readonly privileged?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext#procMount
   */
  readonly procMount?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext#readOnlyRootFilesystem
   */
  readonly readOnlyRootFilesystem?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext#runAsGroup
   */
  readonly runAsGroup?: number;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext#runAsNonRoot
   */
  readonly runAsNonRoot?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext#runAsUser
   */
  readonly runAsUser?: number;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext#seLinuxOptions
   */
  readonly seLinuxOptions?: KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeLinuxOptions;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContext#windowsOptions
   */
  readonly windowsOptions?: KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextWindowsOptions;

}

/**
 * Metadata to apply to the `PodDistruptionBugetTemplate` resource.
 *
 * @schema KafkaMirrorMaker2SpecTemplatePodDisruptionBudgetMetadata
 */
export interface KafkaMirrorMaker2SpecTemplatePodDisruptionBudgetMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMaker2SpecTemplatePodDisruptionBudgetMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaMirrorMaker2SpecTemplatePodDisruptionBudgetMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Value of the environment variable which will be passed to the Kafka Connect pods. It can be passed either as a reference to Secret or ConfigMap field. The field has to specify exactly one Secret or ConfigMap.
 *
 * @schema KafkaMirrorMaker2SpecExternalConfigurationEnvValueFrom
 */
export interface KafkaMirrorMaker2SpecExternalConfigurationEnvValueFrom {
  /**
   * Refernce to a key in a ConfigMap.
   *
   * @schema KafkaMirrorMaker2SpecExternalConfigurationEnvValueFrom#configMapKeyRef
   */
  readonly configMapKeyRef?: KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromConfigMapKeyRef;

  /**
   * Reference to a key in a Secret.
   *
   * @schema KafkaMirrorMaker2SpecExternalConfigurationEnvValueFrom#secretKeyRef
   */
  readonly secretKeyRef?: KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromSecretKeyRef;

}

/**
 * Reference to a key in a ConfigMap. Exactly one Secret or ConfigMap has to be specified.
 *
 * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMap
 */
export interface KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMap {
  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMap#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMap#items
   */
  readonly items?: KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMapItems[];

  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMap#name
   */
  readonly name?: string;

  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMap#optional
   */
  readonly optional?: boolean;

}

/**
 * Reference to a key in a Secret. Exactly one Secret or ConfigMap has to be specified.
 *
 * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesSecret
 */
export interface KafkaMirrorMaker2SpecExternalConfigurationVolumesSecret {
  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesSecret#defaultMode
   */
  readonly defaultMode?: number;

  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesSecret#items
   */
  readonly items?: KafkaMirrorMaker2SpecExternalConfigurationVolumesSecretItems[];

  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesSecret#optional
   */
  readonly optional?: boolean;

  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesSecret#secretName
   */
  readonly secretName?: string;

}

/**
 * @schema KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContextSeLinuxOptions
 */
export interface KafkaMirrorMaker2SpecTemplatePodSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContextSysctls
 */
export interface KafkaMirrorMaker2SpecTemplatePodSecurityContextSysctls {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContextSysctls#name
   */
  readonly name?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContextSysctls#value
   */
  readonly value?: string;

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContextWindowsOptions
 */
export interface KafkaMirrorMaker2SpecTemplatePodSecurityContextWindowsOptions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinity
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinity {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution;

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinity
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinity {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinity
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinity {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinity#preferredDuringSchedulingIgnoredDuringExecution
   */
  readonly preferredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinity#requiredDuringSchedulingIgnoredDuringExecution
   */
  readonly requiredDuringSchedulingIgnoredDuringExecution?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[];

}

/**
 * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextCapabilities
 */
export interface KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextCapabilities {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeLinuxOptions
 */
export interface KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextWindowsOptions
 */
export interface KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateConnectContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextCapabilities
 */
export interface KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextCapabilities {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextCapabilities#add
   */
  readonly add?: string[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextCapabilities#drop
   */
  readonly drop?: string[];

}

/**
 * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeLinuxOptions
 */
export interface KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeLinuxOptions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeLinuxOptions#level
   */
  readonly level?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeLinuxOptions#role
   */
  readonly role?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeLinuxOptions#type
   */
  readonly type?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextSeLinuxOptions#user
   */
  readonly user?: string;

}

/**
 * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextWindowsOptions
 */
export interface KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextWindowsOptions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextWindowsOptions#gmsaCredentialSpec
   */
  readonly gmsaCredentialSpec?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextWindowsOptions#gmsaCredentialSpecName
   */
  readonly gmsaCredentialSpecName?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplateInitContainerSecurityContextWindowsOptions#runAsUserName
   */
  readonly runAsUserName?: string;

}

/**
 * Refernce to a key in a ConfigMap.
 *
 * @schema KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromConfigMapKeyRef
 */
export interface KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromConfigMapKeyRef {
  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromConfigMapKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromConfigMapKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromConfigMapKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * Reference to a key in a Secret.
 *
 * @schema KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromSecretKeyRef
 */
export interface KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromSecretKeyRef {
  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromSecretKeyRef#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromSecretKeyRef#name
   */
  readonly name?: string;

  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationEnvValueFromSecretKeyRef#optional
   */
  readonly optional?: boolean;

}

/**
 * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMapItems
 */
export interface KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMapItems {
  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMapItems#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMapItems#mode
   */
  readonly mode?: number;

  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesConfigMapItems#path
   */
  readonly path?: string;

}

/**
 * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesSecretItems
 */
export interface KafkaMirrorMaker2SpecExternalConfigurationVolumesSecretItems {
  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesSecretItems#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesSecretItems#mode
   */
  readonly mode?: number;

  /**
   * @schema KafkaMirrorMaker2SpecExternalConfigurationVolumesSecretItems#path
   */
  readonly path?: string;

}

/**
 * @schema KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#preference
   */
  readonly preference?: KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution#nodeSelectorTerms
   */
  readonly nodeSelectorTerms?: KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[];

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#podAffinityTerm
   */
  readonly podAffinityTerm?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution#weight
   */
  readonly weight?: number;

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference#matchFields
   */
  readonly matchFields?: KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[];

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms#matchFields
   */
  readonly matchFields?: KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[];

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#labelSelector
   */
  readonly labelSelector?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#namespaces
   */
  readonly namespaces?: string[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm#topologyKey
   */
  readonly topologyKey?: string;

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchExpressions
   */
  readonly matchExpressions?: KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[];

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector#matchLabels
   */
  readonly matchLabels?: any;

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions
 */
export interface KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#key
   */
  readonly key?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#operator
   */
  readonly operator?: string;

  /**
   * @schema KafkaMirrorMaker2SpecTemplatePodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * 
 *
 * @schema KafkaRebalance
 */
export class KafkaRebalance extends ApiObject {
  /**
   * Returns the apiVersion and kind for "KafkaRebalance"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kafka.strimzi.io/v1alpha1',
    kind: 'KafkaRebalance',
  }

  /**
   * Renders a Kubernetes manifest for "KafkaRebalance".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KafkaRebalanceProps = {}): any {
    return {
      ...KafkaRebalance.GVK,
      ...props,
    };
  }

  /**
   * Defines a "KafkaRebalance" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KafkaRebalanceProps = {}) {
    super(scope, id, KafkaRebalance.manifest(props));
  }
}

/**
 * @schema KafkaRebalance
 */
export interface KafkaRebalanceProps {
  /**
   * The specification of the Kafka rebalance.
   *
   * @schema KafkaRebalance#spec
   */
  readonly spec?: KafkaRebalanceSpec;

}

/**
 * The specification of the Kafka rebalance.
 *
 * @schema KafkaRebalanceSpec
 */
export interface KafkaRebalanceSpec {
  /**
   * A list of goals, ordered by decreasing priority, to use for generating and executing the rebalance proposal. The supported goals are available at https://github.com/linkedin/cruise-control#goals. If an empty goals list is provided, the goals declared in the default.goals Cruise Control configuration parameter are used.
   *
   * @schema KafkaRebalanceSpec#goals
   */
  readonly goals?: string[];

  /**
   * Whether to allow the hard goals specified in the Kafka CR to be skipped in optimization proposal generation. This can be useful when some of those hard goals are preventing a balance solution being found. Default is false.
   *
   * @default false.
   * @schema KafkaRebalanceSpec#skipHardGoalCheck
   */
  readonly skipHardGoalCheck?: boolean;

  /**
   * A regular expression where any matching topics will be excluded from the calculation of optimization proposals. This expression will be parsed by the java.util.regex.Pattern class; for more information on the supported formar consult the documentation for that class.
   *
   * @schema KafkaRebalanceSpec#excludedTopics
   */
  readonly excludedTopics?: string;

  /**
   * The upper bound of ongoing partition replica movements going into/out of each broker. Default is 5.
   *
   * @default 5.
   * @schema KafkaRebalanceSpec#concurrentPartitionMovementsPerBroker
   */
  readonly concurrentPartitionMovementsPerBroker?: number;

  /**
   * The upper bound of ongoing partition replica movements between disks within each broker. Default is 2.
   *
   * @default 2.
   * @schema KafkaRebalanceSpec#concurrentIntraBrokerPartitionMovements
   */
  readonly concurrentIntraBrokerPartitionMovements?: number;

  /**
   * The upper bound of ongoing partition leadership movements. Default is 1000.
   *
   * @default 1000.
   * @schema KafkaRebalanceSpec#concurrentLeaderMovements
   */
  readonly concurrentLeaderMovements?: number;

  /**
   * The upper bound, in bytes per second, on the bandwidth used to move replicas. There is no limit by default.
   *
   * @schema KafkaRebalanceSpec#replicationThrottle
   */
  readonly replicationThrottle?: number;

  /**
   * A list of strategy class names used to determine the execution order for the replica movements in the generated optimization proposal. By default BaseReplicaMovementStrategy is used, which will execute the replica movements in the order that they were generated.
   *
   * @schema KafkaRebalanceSpec#replicaMovementStrategies
   */
  readonly replicaMovementStrategies?: string[];

}

/**
 * 
 *
 * @schema KafkaTopic
 */
export class KafkaTopic extends ApiObject {
  /**
   * Returns the apiVersion and kind for "KafkaTopic"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kafka.strimzi.io/v1beta1',
    kind: 'KafkaTopic',
  }

  /**
   * Renders a Kubernetes manifest for "KafkaTopic".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KafkaTopicProps = {}): any {
    return {
      ...KafkaTopic.GVK,
      ...props,
    };
  }

  /**
   * Defines a "KafkaTopic" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KafkaTopicProps = {}) {
    super(scope, id, KafkaTopic.manifest(props));
  }
}

/**
 * @schema KafkaTopic
 */
export interface KafkaTopicProps {
  /**
   * The specification of the topic.
   *
   * @schema KafkaTopic#spec
   */
  readonly spec?: KafkaTopicSpec;

}

/**
 * The specification of the topic.
 *
 * @schema KafkaTopicSpec
 */
export interface KafkaTopicSpec {
  /**
   * The number of partitions the topic should have. This cannot be decreased after topic creation. It can be increased after topic creation, but it is important to understand the consequences that has, especially for topics with semantic partitioning.
   *
   * @schema KafkaTopicSpec#partitions
   */
  readonly partitions: number;

  /**
   * The number of replicas the topic should have.
   *
   * @schema KafkaTopicSpec#replicas
   */
  readonly replicas: number;

  /**
   * The topic configuration.
   *
   * @schema KafkaTopicSpec#config
   */
  readonly config?: any;

  /**
   * The name of the topic. When absent this will default to the metadata.name of the topic. It is recommended to not set this unless the topic name is not a valid Kubernetes resource name.
   *
   * @schema KafkaTopicSpec#topicName
   */
  readonly topicName?: string;

}

/**
 * 
 *
 * @schema KafkaUser
 */
export class KafkaUser extends ApiObject {
  /**
   * Returns the apiVersion and kind for "KafkaUser"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kafka.strimzi.io/v1beta1',
    kind: 'KafkaUser',
  }

  /**
   * Renders a Kubernetes manifest for "KafkaUser".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: KafkaUserProps = {}): any {
    return {
      ...KafkaUser.GVK,
      ...props,
    };
  }

  /**
   * Defines a "KafkaUser" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: KafkaUserProps = {}) {
    super(scope, id, KafkaUser.manifest(props));
  }
}

/**
 * @schema KafkaUser
 */
export interface KafkaUserProps {
  /**
   * The specification of the user.
   *
   * @schema KafkaUser#spec
   */
  readonly spec?: KafkaUserSpec;

}

/**
 * The specification of the user.
 *
 * @schema KafkaUserSpec
 */
export interface KafkaUserSpec {
  /**
   * Authentication mechanism enabled for this Kafka user.
   *
   * @schema KafkaUserSpec#authentication
   */
  readonly authentication?: KafkaUserSpecAuthentication;

  /**
   * Authorization rules for this Kafka user.
   *
   * @schema KafkaUserSpec#authorization
   */
  readonly authorization?: KafkaUserSpecAuthorization;

  /**
   * Quotas on requests to control the broker resources used by clients. Network bandwidth and request rate quotas can be enforced.Kafka documentation for Kafka User quotas can be found at http://kafka.apache.org/documentation/#design_quotas.
   *
   * @schema KafkaUserSpec#quotas
   */
  readonly quotas?: KafkaUserSpecQuotas;

  /**
   * Template to specify how Kafka User `Secrets` are generated.
   *
   * @schema KafkaUserSpec#template
   */
  readonly template?: KafkaUserSpecTemplate;

}

/**
 * Authentication mechanism enabled for this Kafka user.
 *
 * @schema KafkaUserSpecAuthentication
 */
export interface KafkaUserSpecAuthentication {
  /**
   * Authentication type.
   *
   * @schema KafkaUserSpecAuthentication#type
   */
  readonly type: KafkaUserSpecAuthenticationType;

}

/**
 * Authorization rules for this Kafka user.
 *
 * @schema KafkaUserSpecAuthorization
 */
export interface KafkaUserSpecAuthorization {
  /**
   * List of ACL rules which should be applied to this user.
   *
   * @schema KafkaUserSpecAuthorization#acls
   */
  readonly acls: KafkaUserSpecAuthorizationAcls[];

  /**
   * Authorization type. Currently the only supported type is `simple`. `simple` authorization type uses Kafka's `kafka.security.authorizer.AclAuthorizer` class for authorization.
   *
   * @schema KafkaUserSpecAuthorization#type
   */
  readonly type: KafkaUserSpecAuthorizationType;

}

/**
 * Quotas on requests to control the broker resources used by clients. Network bandwidth and request rate quotas can be enforced.Kafka documentation for Kafka User quotas can be found at http://kafka.apache.org/documentation/#design_quotas.
 *
 * @schema KafkaUserSpecQuotas
 */
export interface KafkaUserSpecQuotas {
  /**
   * A quota on the maximum bytes per-second that each client group can fetch from a broker before the clients in the group are throttled. Defined on a per-broker basis.
   *
   * @schema KafkaUserSpecQuotas#consumerByteRate
   */
  readonly consumerByteRate?: number;

  /**
   * A quota on the maximum bytes per-second that each client group can publish to a broker before the clients in the group are throttled. Defined on a per-broker basis.
   *
   * @schema KafkaUserSpecQuotas#producerByteRate
   */
  readonly producerByteRate?: number;

  /**
   * A quota on the maximum CPU utilization of each client group as a percentage of network and I/O threads.
   *
   * @schema KafkaUserSpecQuotas#requestPercentage
   */
  readonly requestPercentage?: number;

}

/**
 * Template to specify how Kafka User `Secrets` are generated.
 *
 * @schema KafkaUserSpecTemplate
 */
export interface KafkaUserSpecTemplate {
  /**
   * Template for KafkaUser resources. The template allows users to specify how the `Secret` with password or TLS certificates is generated.
   *
   * @schema KafkaUserSpecTemplate#secret
   */
  readonly secret?: KafkaUserSpecTemplateSecret;

}

/**
 * Authentication type.
 *
 * @schema KafkaUserSpecAuthenticationType
 */
export enum KafkaUserSpecAuthenticationType {
  /** tls */
  TLS = "tls",
  /** scram-sha-512 */
  SCRAM_SHA_512 = "scram-sha-512",
}

/**
 * @schema KafkaUserSpecAuthorizationAcls
 */
export interface KafkaUserSpecAuthorizationAcls {
  /**
   * The host from which the action described in the ACL rule is allowed or denied.
   *
   * @schema KafkaUserSpecAuthorizationAcls#host
   */
  readonly host?: string;

  /**
   * Operation which will be allowed or denied. Supported operations are: Read, Write, Create, Delete, Alter, Describe, ClusterAction, AlterConfigs, DescribeConfigs, IdempotentWrite and All.
   *
   * @schema KafkaUserSpecAuthorizationAcls#operation
   */
  readonly operation: KafkaUserSpecAuthorizationAclsOperation;

  /**
   * Indicates the resource for which given ACL rule applies.
   *
   * @schema KafkaUserSpecAuthorizationAcls#resource
   */
  readonly resource: KafkaUserSpecAuthorizationAclsResource;

  /**
   * The type of the rule. Currently the only supported type is `allow`. ACL rules with type `allow` are used to allow user to execute the specified operations. Default value is `allow`.
   *
   * @schema KafkaUserSpecAuthorizationAcls#type
   */
  readonly type?: KafkaUserSpecAuthorizationAclsType;

}

/**
 * Authorization type. Currently the only supported type is `simple`. `simple` authorization type uses Kafka's `kafka.security.authorizer.AclAuthorizer` class for authorization.
 *
 * @schema KafkaUserSpecAuthorizationType
 */
export enum KafkaUserSpecAuthorizationType {
  /** simple */
  SIMPLE = "simple",
}

/**
 * Template for KafkaUser resources. The template allows users to specify how the `Secret` with password or TLS certificates is generated.
 *
 * @schema KafkaUserSpecTemplateSecret
 */
export interface KafkaUserSpecTemplateSecret {
  /**
   * Metadata applied to the resource.
   *
   * @schema KafkaUserSpecTemplateSecret#metadata
   */
  readonly metadata?: KafkaUserSpecTemplateSecretMetadata;

}

/**
 * Operation which will be allowed or denied. Supported operations are: Read, Write, Create, Delete, Alter, Describe, ClusterAction, AlterConfigs, DescribeConfigs, IdempotentWrite and All.
 *
 * @schema KafkaUserSpecAuthorizationAclsOperation
 */
export enum KafkaUserSpecAuthorizationAclsOperation {
  /** Read */
  READ = "Read",
  /** Write */
  WRITE = "Write",
  /** Create */
  CREATE = "Create",
  /** Delete */
  DELETE = "Delete",
  /** Alter */
  ALTER = "Alter",
  /** Describe */
  DESCRIBE = "Describe",
  /** ClusterAction */
  CLUSTER_ACTION = "ClusterAction",
  /** AlterConfigs */
  ALTER_CONFIGS = "AlterConfigs",
  /** DescribeConfigs */
  DESCRIBE_CONFIGS = "DescribeConfigs",
  /** IdempotentWrite */
  IDEMPOTENT_WRITE = "IdempotentWrite",
  /** All */
  ALL = "All",
}

/**
 * Indicates the resource for which given ACL rule applies.
 *
 * @schema KafkaUserSpecAuthorizationAclsResource
 */
export interface KafkaUserSpecAuthorizationAclsResource {
  /**
   * Name of resource for which given ACL rule applies. Can be combined with `patternType` field to use prefix pattern.
   *
   * @schema KafkaUserSpecAuthorizationAclsResource#name
   */
  readonly name?: string;

  /**
   * Describes the pattern used in the resource field. The supported types are `literal` and `prefix`. With `literal` pattern type, the resource field will be used as a definition of a full name. With `prefix` pattern type, the resource name will be used only as a prefix. Default value is `literal`.
   *
   * @schema KafkaUserSpecAuthorizationAclsResource#patternType
   */
  readonly patternType?: KafkaUserSpecAuthorizationAclsResourcePatternType;

  /**
   * Resource type. The available resource types are `topic`, `group`, `cluster`, and `transactionalId`.
   *
   * @schema KafkaUserSpecAuthorizationAclsResource#type
   */
  readonly type: KafkaUserSpecAuthorizationAclsResourceType;

}

/**
 * The type of the rule. Currently the only supported type is `allow`. ACL rules with type `allow` are used to allow user to execute the specified operations. Default value is `allow`.
 *
 * @schema KafkaUserSpecAuthorizationAclsType
 */
export enum KafkaUserSpecAuthorizationAclsType {
  /** allow */
  ALLOW = "allow",
  /** deny */
  DENY = "deny",
}

/**
 * Metadata applied to the resource.
 *
 * @schema KafkaUserSpecTemplateSecretMetadata
 */
export interface KafkaUserSpecTemplateSecretMetadata {
  /**
   * Labels added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaUserSpecTemplateSecretMetadata#labels
   */
  readonly labels?: any;

  /**
   * Annotations added to the resource template. Can be applied to different resources such as `StatefulSets`, `Deployments`, `Pods`, and `Services`.
   *
   * @schema KafkaUserSpecTemplateSecretMetadata#annotations
   */
  readonly annotations?: any;

}

/**
 * Describes the pattern used in the resource field. The supported types are `literal` and `prefix`. With `literal` pattern type, the resource field will be used as a definition of a full name. With `prefix` pattern type, the resource name will be used only as a prefix. Default value is `literal`.
 *
 * @schema KafkaUserSpecAuthorizationAclsResourcePatternType
 */
export enum KafkaUserSpecAuthorizationAclsResourcePatternType {
  /** literal */
  LITERAL = "literal",
  /** prefix */
  PREFIX = "prefix",
}

/**
 * Resource type. The available resource types are `topic`, `group`, `cluster`, and `transactionalId`.
 *
 * @schema KafkaUserSpecAuthorizationAclsResourceType
 */
export enum KafkaUserSpecAuthorizationAclsResourceType {
  /** topic */
  TOPIC = "topic",
  /** group */
  GROUP = "group",
  /** cluster */
  CLUSTER = "cluster",
  /** transactionalId */
  TRANSACTIONAL_ID = "transactionalId",
}

